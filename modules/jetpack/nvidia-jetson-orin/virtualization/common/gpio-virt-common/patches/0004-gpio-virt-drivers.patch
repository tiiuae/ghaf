diff --git a/drivers/Kconfig b/drivers/Kconfig
index dcecc9f6e33f..ed7d58d68ba6 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -235,4 +235,10 @@ source "drivers/interconnect/Kconfig"
 source "drivers/counter/Kconfig"
 
 source "drivers/most/Kconfig"
+
+if ARCH_TEGRA
+source "drivers/gpio-host-proxy/Kconfig"
+source "drivers/gpio-guest-proxy/Kconfig"
+endif
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
--- a/drivers/Makefile	2024-05-02 12:06:58.097355696 +0000
+++ b/drivers/Makefile	2024-07-09 14:52:57.660206313 +0000
@@ -193,0 +194,5 @@
+#
+#
+#
+obj-y	+= gpio-host-proxy/
+obj-y	+= gpio-guest-proxy/
diff --git a/drivers/gpio-guest-proxy/Kconfig b/drivers/gpio-guest-proxy/Kconfig
new file mode 100644
index 0000000..e25a19a
--- /dev/null
+++ b/drivers/gpio-guest-proxy/Kconfig
@@ -0,0 +1,11 @@
+config TEGRA_GPIO_GUEST_PROXY
+	depends on GPIO_TEGRA && GPIO_TEGRA186
+		bool "Tegra GPIO guest proxy driver"
+		help
+		The Tegra GPIO guest proxy driver, virtualise GPIO __iomem initalised by host, 
+		allowing the guest to access host GPIO.
+
+		Say Y here to enable this driver and to compile this driver as a module, 
+		choose M here. If unsure, say N
+
+
diff --git a/drivers/gpio-guest-proxy/Makefile b/drivers/gpio-guest-proxy/Makefile
new file mode 100644
index 0000000..2580e02
--- /dev/null
+++ b/drivers/gpio-guest-proxy/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_TEGRA_GPIO_GUEST_PROXY) += gpio-guest-proxy.o
diff --git a/drivers/gpio-guest-proxy/gpio-guest-proxy.c b/drivers/gpio-guest-proxy/gpio-guest-proxy.c
new file mode 100644
index 0000000..b128178
--- /dev/null
+++ b/drivers/gpio-guest-proxy/gpio-guest-proxy.c
@@ -0,0 +1,805 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/**
+ * NVIDIA GPIO Guest Proxy Kernel Module
+ * (c) 2023 Unikie, Oy
+ * (c) 2023 Kim Sandstrom kim.sandstrom@unikie.com
+ *
+ **/
+
+#include <linux/module.h>	  // Core header for modules.
+#include <linux/device.h>	  // Supports driver model.
+#include <linux/kernel.h>	  // Kernel header for convenient functions.
+#include <linux/fs.h>		  // File-system support.
+#include <linux/uaccess.h>	  // User access copy function support.
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/memory_hotplug.h>
+#include <linux/io.h>
+#include <linux/gpio/driver.h>
+#include <linux/of_device.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/namei.h>
+#include <linux/delay.h>
+
+#include "../gpio-host-proxy/gpio-host-proxy.h"
+
+#define DEVICE_NAME "gpio-guest" // Device name.
+#define CLASS_NAME "char"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kim Sandstrom");
+MODULE_DESCRIPTION("NVidia GPIO Guest Proxy Kernel Module");
+MODULE_VERSION("0.0");
+
+#define GPIO_DEBUG
+#define GPIO_DEBUG_VERBOSE       // also activates deb_verbose commands
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__ , kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__ , kbasename(__FILE__), ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+  #define deb_error(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+  extern void hexDump (
+    const char * deviceName,
+    const char * desc,
+    const void * addr,
+    const int len
+  );
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
+// MEM_SIZE defined in gpio-host-proxy.h
+static volatile void __iomem  *mem_iova = NULL;
+
+extern struct gpio_chip *find_chip_by_name(const char *);
+extern struct gpio_chip *find_chip_by_id(int);
+extern const char **tegra_chiplabel;
+
+extern int gpio_outloud;
+extern uint64_t gpio_vpa;
+
+static char return_buffer[MEM_SIZE];   // using the same size as the input buffer
+static int *return_value = (int *)return_buffer;  // local return value for chardev interaction
+
+/* functions redirected to guest-proxy from gpio-tegra186.c
+ * from setup of gpio_chip in tegra186_gpio_probe
+ */
+
+/* guest_chardev_transfer
+ * a helper function to transfer between guest and host using /dev/gpio-host
+ * mgs: is a pointer to data -- in practice tegra_gpio_pt and tegra_gpio_pt_extended structs
+ * generic return: poiter to return data, may be NULL if we do not expect a return value
+ */ 
+void guest_chardev_transfer(void *msg, char msg_len, int *generic_return)
+{
+  // encode message length into first byte (LSB bit is preserved for other use)
+  unsigned char *length = (unsigned char *)msg;
+  *length = *length | (unsigned char)msg_len << 1;
+
+  if(msg_len & 0x80) {
+    deb_error("Illegal message length\n"); // msb will be deleted and must be zero
+  }
+
+	// deb_debug("\n");
+  #ifdef GPIO_DEBUG_VERBOSE
+    deb_verbose("PT transfer signal is: %c", *((char *)msg + 1));
+    hexDump(DEVICE_NAME, "transfer", msg, msg_len);
+  #endif
+
+	// Execute the request by copying to io memory
+	memcpy_toio(mem_iova, msg, msg_len);
+  deb_verbose("PT request value is copied, length = %d", msg_len);
+
+  // deb_verbose("PT generic_return pointer: 0x%llX\n", (long long int)generic_return);
+  // check if we expect a return value
+  if(generic_return) {
+    // Read response from io_buffer
+    memcpy_fromio(generic_return, mem_iova, sizeof(*generic_return)); // 32 bits
+    // memcpy_fromio(msg, mem_iova, sizeof(*generic_return));  // copy return value to message buffer  32 bits
+
+    deb_verbose("PT return value 0x%X, is copied", *generic_return);  }
+}
+
+_Static_assert(sizeof(u32) == sizeof(int), "return size assertion failed");
+
+// redirect static inline u32 readl_x(const volatile void __iomem *addr)
+inline u32 readl_redirect( void * addr, const unsigned char rwltype) {
+  u32 ret = 0;
+  struct tegra_readl_writel rwlmsg;
+
+  rwlmsg.signal = GPIO_READL;
+  rwlmsg.length = 0; // will be updated later
+  rwlmsg.rwltype = rwltype;
+  rwlmsg.address = addr;
+  rwlmsg.value = 0;  // value field is not used for readl
+
+  guest_chardev_transfer(&rwlmsg, sizeof(rwlmsg), &ret);
+  return ret;
+}
+EXPORT_SYMBOL_GPL(readl_redirect);
+
+// redirect: static inline void writel_x(u32 value, volatile void __iomem *addr)
+inline void writel_redirect( u32 value, void * addr, const unsigned char rwltype) {
+  struct tegra_readl_writel rwlmsg;
+
+  rwlmsg.signal = GPIO_WRITEL;
+  rwlmsg.length = 0; // will be updated later
+  rwlmsg.rwltype = rwltype;
+  rwlmsg.address = addr;
+  rwlmsg.value = value;
+
+  guest_chardev_transfer(&rwlmsg, sizeof(rwlmsg), NULL);
+}
+EXPORT_SYMBOL_GPL(writel_redirect);
+
+int gpiochip_generic_request_redirect(struct gpio_chip *chip, unsigned offset) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_REQ;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+void gpiochip_generic_free_redirect(struct gpio_chip *chip, unsigned offset) {
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_FREE;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), NULL);
+}
+
+int tegra186_gpio_get_direction_redirect(struct gpio_chip *chip,
+				       unsigned int offset) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_GET_DIR;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+int tegra186_gpio_direction_input_redirect(struct gpio_chip *chip,
+					 unsigned int offset) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_SET_IN;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+int tegra186_gpio_direction_output_redirect(struct gpio_chip *chip,
+					  unsigned int offset, int level) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_SET_OUT;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = level;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+int tegra186_gpio_get_redirect(struct gpio_chip *chip, unsigned int offset) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_GET;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+void tegra186_gpio_set_redirect(struct gpio_chip *chip, unsigned int offset,
+			      int level) {
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_SET;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = level;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), NULL);
+}
+
+void tegra186_gpio_set_by_name_redirect(const char *name, unsigned int offset,
+			      int level) {
+  struct tegra_gpio_pt msg;
+  struct gpio_chip *chip = find_chip_by_name(name);
+  msg.signal = GPIO_SET_BY_NAME;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = level;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), NULL);
+}
+
+int tegra186_gpio_set_config_redirect(struct gpio_chip *chip,
+				    unsigned int offset,
+				    unsigned long config) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_CONFIG;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+int tegra_gpio_timestamp_control_redirect(struct gpio_chip *chip, unsigned offset,
+					int enable) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_TIMESTAMP_CTRL;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+int tegra_gpio_timestamp_read_redirect(struct gpio_chip *chip, unsigned offset,
+				     u64 *ts) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_TIMESTAMP_READ;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+int tegra_gpio_suspend_configure_redirect(struct gpio_chip *chip, unsigned offset,
+					enum gpiod_flags dflags) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_SUSPEND_CONF;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+// TODO,  this probably does not work because action parameters should be in gpio_chip struct, but guest did not copy the over the passthrough interface
+int tegra186_gpio_add_pin_ranges_redirect(struct gpio_chip *chip) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_ADD_PINRANGES;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = 0;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+// unpreserve_all_tegrachips also does unhooking ?
+extern void unpreserve_all_tegrachips(void);
+struct gpio_chip * find_chip_by_id(int id);
+
+/**
+ * Important variables that store data and keep track of relevant information.
+ */
+static int major_number;
+
+static struct class *gpio_guest_proxy_class = NULL;	///< The device-driver class struct pointer
+static struct device *gpio_guest_proxy_device = NULL; ///< The device-driver device struct pointer
+
+/**
+ * Prototype functions for file operations.
+ */
+static int open(struct inode *, struct file *);
+static int close(struct inode *, struct file *);
+static ssize_t read(struct file *, char *, size_t, loff_t *);
+static ssize_t write(struct file *, const char *, size_t, loff_t *);
+
+/**
+ * File operations structure and the functions it points to.
+ */
+static struct file_operations fops =
+	{
+		.owner = THIS_MODULE,
+		.open = open,
+		.release = close,
+		.read = read,
+		.write = write
+	};
+
+static bool is_set_up = false;
+
+/**
+ * Initializes module at installation
+ */
+int tegra_gpio_guest_init(void)
+{
+  // Note: gpio is not referenced, the init is agnostic to which chip triggered this function
+  // In an earlier versio of the code we stored the gpio struct pointer in a static table
+  // int this_chip_id = gpio.gpio->gpiodev.id;
+  // char this_de:avice[12];
+  if(is_set_up) { 
+    deb_error("Attempting to set up guest driver twice\n");
+    return -EPERM;
+  }
+
+	deb_info("installing module.");
+
+	if(!gpio_vpa){
+		pr_err("Failed, gpio_vpa not defined");
+    return -1;
+	}
+	deb_info("gpio_vpa: 0x%llx", gpio_vpa);
+
+	// Allocate a major number for the device.
+	major_number = register_chrdev(0, DEVICE_NAME, &fops);
+	if (major_number < 0)
+	{
+		pr_err("could not register number.");
+		return major_number;
+	}
+	deb_info("registered correctly with major number %d", major_number);
+
+	// Register the device class
+	gpio_guest_proxy_class = class_create(THIS_MODULE, CLASS_NAME);
+	if (IS_ERR(gpio_guest_proxy_class))
+	{ // Check for error and clean up if there is
+		unregister_chrdev(major_number, DEVICE_NAME);
+		deb_error("Failed to register device class\n");
+		return PTR_ERR(gpio_guest_proxy_class); // Correct way to return an error on a pointer
+	}
+	deb_info("device class registered correctly\n");
+
+	// Register the device driver
+	gpio_guest_proxy_device = device_create(gpio_guest_proxy_class, NULL, MKDEV(major_number, 0), NULL, DEVICE_NAME);
+	if (IS_ERR(gpio_guest_proxy_device))
+	{								 // Clean up if there is an error
+		class_destroy(gpio_guest_proxy_class); 
+		unregister_chrdev(major_number, DEVICE_NAME);
+		deb_error("Failed to create the device\n");
+		return PTR_ERR(gpio_guest_proxy_device);
+	}
+	deb_info("device class created correctly\n"); // Made it! device was initialized
+
+	// map iomem
+	mem_iova = ioremap(gpio_vpa, MEM_SIZE);
+
+	if (!mem_iova) {
+        deb_error("ioremap failed\n");
+        return -ENOMEM;
+  }
+
+	deb_info("mem_iova: 0x%llx\n", (long long unsigned int)mem_iova);
+
+  is_set_up = true;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(tegra_gpio_guest_init);
+
+/*
+ * Removes module, sends appropriate message to kernel
+ */
+void tegra_gpio_guest_cleanup(void)
+{
+	deb_info("removing module.\n");
+
+	// unmap iomem
+	iounmap((void __iomem*)gpio_vpa);
+
+  // gpio_unhook is called by unpreserve_all_tegrachips()
+  // gpio_unhook()
+  // clean up shared memory with stock driver and unhook all functions
+  unpreserve_all_tegrachips();
+
+	device_destroy(gpio_guest_proxy_class, MKDEV(major_number, 0)); // remove the device
+	class_unregister(gpio_guest_proxy_class);						  // unregister the device class
+	class_destroy(gpio_guest_proxy_class);						  // remove the device class
+	unregister_chrdev(major_number, DEVICE_NAME);		  // unregister the major number
+	deb_info("Goodbye from the LKM!\n");
+	unregister_chrdev(major_number, DEVICE_NAME);
+
+  is_set_up = false;
+	return;
+}
+
+
+
+
+/*
+ * Opens device module, sends appropriate message to kernel
+ */
+static int open(struct inode *inodep, struct file *filep)
+{
+	deb_info("device opened.\n");
+    gpio_outloud = 1;
+	return 0;
+}
+
+/*
+ * Closes device module, sends appropriate message to kernel
+ */
+static int close(struct inode *inodep, struct file *filep)
+{
+	deb_info("device closed.\n");
+    gpio_outloud = 0;
+	return 0;
+}
+
+/*
+ * Reads from device, displays in userspace, and deletes the read data
+ */
+static ssize_t read(struct file *filp, char *buf, size_t len, loff_t *offset) {
+    int remaining_length = sizeof(*return_value) - *offset;
+
+	  deb_info("guest: read gpio chardev\n");
+	  deb_verbose("guest: read op: len = %ld, offset = %lld, *return_value = 0x%X\n", len, *offset, *return_value);
+
+    if ( remaining_length < 0 ) {
+	      deb_info("guest: unrecoverable length *error*, remaining_length = %d\n", remaining_length);
+        return -EINVAL;
+    }
+
+    if ( len > remaining_length ) {
+	      deb_info("guest: recoverable length *error*, len = %ld, remaining_length = %d, rlen = %ld\n", len, remaining_length, sizeof(*return_value));
+        len = remaining_length - *offset;
+    }
+
+    if (copy_to_user(buf + *offset, return_buffer + *offset, len)) {
+	      deb_info("guest: failed to copy to user\n");
+        return -EFAULT;
+    }
+
+    *offset += len;
+
+    // Check if all data was copied
+    if (sizeof(*return_value) < len) {
+	      deb_info("guest: not all bytes were copied\n");
+        // If not, set the error status and return the number of bytes actually copied
+        // return -EINVAL;
+    }
+
+    // Otherwise, indicate success by returning the number of bytes requested
+    return len;
+}
+
+/*
+ * Writes to the device
+ */
+
+// TODO this is shared code with host proxy include function from there
+// look at line 335 of this file
+// extern static ssize_t chardev_write(struct file *filep, const char *buffer, size_t len, loff_t *offset)
+
+static ssize_t write(struct file *filep, const char *buffer, size_t len, loff_t *offset)
+{
+	int ret;
+	// unsigned long int ret_l;
+	struct tegra_gpio_pt *kbuf = NULL;
+	tegra_gpio_pt_extended *kbuf_ext = NULL;
+  // unsigned char *mask;
+
+  /*
+	static struct file *file;
+	static struct inode *inode = NULL;
+  */
+	struct gpio_chip *chip;
+  /*
+  #ifdef GPIO_DEBUG_VERBOSE
+	  struct gpio_chip *chip_alt;
+  #endif
+  */
+
+	char *buffer_pos = (char *)buffer;
+
+	deb_info("## writeing %zu bytes to chardev ##", len);
+
+  // We allow tegra_gpio_pt alone or with tegra_gpio_pt_extended
+	if( len != sizeof(struct tegra_gpio_pt) && len != sizeof(struct tegra_gpio_pt) + sizeof(tegra_gpio_pt_extended) )  {
+		pr_err("Illegal chardev data length. Expected %ld or %ld, got %ld", sizeof(struct tegra_gpio_pt), sizeof(struct tegra_gpio_pt) + sizeof(tegra_gpio_pt_extended), len);
+    hexDump (DEVICE_NAME, "Chardev (guest) input error", buffer, len);
+		return -ENOEXEC;
+    return 0;
+	}
+
+  if(!offset) {
+    pr_err("offset pointer is null, ignoring offset\n");
+  }
+  else {
+	  buffer_pos += (*offset);
+  }
+
+	kbuf = kmalloc(len, GFP_KERNEL);
+	if ( !kbuf ) {
+	  pr_err("kbuf memory allocation failed\n");
+	  return -ENOMEM;
+	}
+	memset(kbuf, 0, len);
+
+	// Copy header
+  if (copy_from_user(kbuf, buffer_pos, sizeof(struct tegra_gpio_pt))) {
+    pr_err("copy_from_user failed\n");
+    kfree(kbuf);
+    return -ENOMEM;
+  }
+  // deb_verbose("kbuf is set up at kbuf=%p", kbuf);
+
+  /* not necessary; only present in input to qemu passthough device
+  // mask away length from first byte where it is encoded in the top 7 bits (chipnum is lowest bit)
+  mask = (unsigned char *)kbuf;
+  *mask = *mask && 0x01;
+  */
+
+  // we are not checking if tegra_gpio_pt_extended is used, we only check for memory allocation
+  if( len == (sizeof(struct tegra_gpio_pt) + sizeof(tegra_gpio_pt_extended) ) ) {
+    kbuf_ext = (tegra_gpio_pt_extended *)(kbuf + 1);
+      deb_verbose("kbuf_ext is set up at kbuf_ext=%p", kbuf_ext);
+  }
+
+  // print copied user parameters
+  hexDump (DEVICE_NAME, "Chardev input", kbuf, len);
+
+  // make gpio-host type call to gpio
+	deb_verbose("Passthrough from guest with signal: %c, Chip %d, Offset %d, Level %d", kbuf->signal, kbuf->chipnum, kbuf->offset, kbuf->level);
+
+  chip = find_chip_by_id(kbuf->chipnum);
+
+  switch (kbuf->signal) {
+    case GPIO_REQ:
+      /*
+      #ifdef GPIO_DEBUG_VERBOSE
+        chip_alt = find_chip_by_name(tegra_chiplabel[kbuf->chipnum]);
+        if(chip != chip_alt) {
+          deb_debug("conflicting chip pointers -- primary %p, alternative %p", chip, chip_alt);
+          chip = chip_alt; // we assume find_chip_by_name is more reliable
+        }
+      #endif
+      */
+      if(!chip) {
+        pr_err("In GPIO_REQ, chip pointer's pvalue is unexpectedly NULL for chip %s\n", tegra_chiplabel[kbuf->chipnum]);
+        kfree(kbuf);
+        return -ENODEV;
+      }
+      deb_verbose("GPIO_REQ, using GPIO chip %s, for device %d\n", chip->label, kbuf->chipnum);
+      ret = chip->request(chip, kbuf->offset);
+	    goto end;
+    break;
+    case GPIO_FREE:
+      deb_verbose("GPIO_FREE\n");
+      chip->free(chip, kbuf->offset);
+      // chip_alt = NULL;
+      goto end;
+    break;
+    case GPIO_GET_DIR:
+      deb_verbose("GPIO_GET_DIR\n");
+      ret = chip->get_direction(chip, kbuf->offset);
+      goto retval;
+    break;
+    case GPIO_SET_IN:
+      deb_verbose("GPIO_SET_IN\n");
+      ret = chip->direction_input(chip, kbuf->offset);
+      goto retval;
+    break;
+    case GPIO_SET_OUT:
+      deb_verbose("GPIO_SET_OUT\n");
+      ret = chip->direction_output(chip, kbuf->offset, kbuf->level);
+      goto retval;
+    break;
+    case GPIO_GET:
+      deb_verbose("GPIO_GET\n");
+      ret = chip->get(chip, kbuf->offset);
+      goto retval;
+    break;
+    case GPIO_SET:
+      deb_verbose("GPIO_SET, set %d at offset 0x%x in gpiochip %s\n", kbuf->level, kbuf->offset, chip->label);
+      chip->set(chip, kbuf->offset, kbuf->level);
+	    goto end;
+    break;
+    case GPIO_CONFIG:
+      deb_verbose("GPIO_CONFIG\n");
+      chip->set_config(chip, kbuf->offset, kbuf_ext->config); // arg mapped to unsigned long config
+	    goto end;
+    break;
+    case GPIO_TIMESTAMP_CTRL:
+      deb_verbose("GPIO_TIMESTAMP_CTRL\n");
+      ret = chip->timestamp_control(chip, kbuf->offset, kbuf->level);	// mapping level onto enable
+      goto retval;
+    break;
+    case GPIO_TIMESTAMP_READ:
+      deb_verbose("GPIO_TIMESTAMP_READ\n");
+      ret = chip->timestamp_read(chip, kbuf->offset, (u64 *)buffer_pos);	// timestamp is u64, return value as pointer
+      if(ret) {
+        pr_err("GPIO_TIMESTAMP_READ error\n");
+        goto end;
+      }
+      // timestamp_read returns value directly to buffer_pos
+      goto end;
+    break;
+    case GPIO_SUSPEND_CONF:
+      deb_verbose("GPIO_SUSPEND_CONF\n");
+      if(!kbuf_ext) {
+        pr_err("Parameter error in GPIO_SUSPEND_CONF\n");
+        return -EINVAL;
+      }
+      ret = chip->suspend_configure(chip, kbuf->offset, kbuf_ext->dflags);
+      goto retval;
+    break;
+    case GPIO_ADD_PINRANGES:
+      deb_verbose("GPIO_ADD_PINRANGES\n");
+      ret = chip->add_pin_ranges(chip);
+      goto retval;
+    break;
+  };
+
+  /* ioctl signals use flieops because it relises on the standard gpio chardevs
+  static const struct file_operations gpio_fileops = {
+  .release = gpio_chrdev_release,
+  .open = gpio_chrdev_open,
+  .poll = lineinfo_watch_poll,
+  .read = lineinfo_watch_read,
+  .owner = THIS_MODULE,
+  .llseek = no_llseek,
+  .unlocked_ioctl = gpio_ioctl,
+  #ifdef CONFIG_COMPAT
+    .compat_ioctl = gpio_ioctl_compat,
+  #endif
+  };
+  */
+
+  /* ioctl is exluded from this version
+  if(kbuf_ext) {
+    switch (kbuf->signal) {
+  */
+      /* commands to ioctl below (the std gpio chardev)
+      * not fully implemented
+      * linehandle_create  -- when userspace requests output (called by gpio_ioctl) -- bypasses the chardev
+      * linehandle_ioctl   -- linehandle_ioctl when userspace does actual io (toggles pin)
+      *    cmd:
+      *    GPIOHANDLE_GET_LINE_VALUES_IOCTL,
+      *    GPIOHANDLE_SET_LINE_VALUES_IOCTL,
+      *    GPIOHANDLE_SET_CONFIG_IOCTL
+      *    arg: user input or output
+      */
+  /* ioctl is exluded from this version
+      // We could want to use the stock gpio chardev (/dev/gpiochip0 and /dev/gpiochip1) /bc userspace functions use it
+      // this code is not yet complete and it mey be better to use the stock devices directly.
+      case GPIO_CHARDEV_OPEN:	// .open = gpio_chrdev_open
+        file = filp_open(tegra_chiplabel[kbuf->chipnum], O_RDWR, 0);
+          if (IS_ERR(file)) {
+            pr_err("GPIO, failed to open chardev for chip %s: %ld", tegra_chiplabel[kbuf->chipnum], PTR_ERR(file));
+            kfree(kbuf);
+            return -ENOENT;
+          }
+        // note: inode and file are static variables
+        inode = file->f_path.dentry->d_inode;
+        // defined as: static int gpio_chrdev_open(struct inode *inode, struct file *file)
+        ret = file->f_op->open(inode, file);
+        goto retval;
+      break;
+      case GPIO_CHARDEV_IOCTL:	// .unlocked_ioctl = gpio_ioctl
+        // user space triggers gpio_ioctl -- it is .unlocked_ioctl on the chardev
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static long gpio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+        ret_l = file->f_op->unlocked_ioctl(file, kbuf->cmd, kbuf_ext->arg);	// arg is pointer data which should have been copied from userspace
+        goto retlong;
+      break;
+      case GPIO_CHARDEV_RELEASE: // .release = gpio_chrdev_release
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static int gpio_chrdev_release(struct inode *inode, struct file *file)
+        ret = file->f_op->release(inode, file);
+        goto retval;
+      break;
+      case GPIO_CHARDEV_POLL: // .poll = lineinfo_watch_poll
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static __poll_t lineinfo_watch_poll(struct file *file, struct poll_table_struct *pollt)
+        ret = file->f_op->poll(file, kbuf_ext->poll);	// TODO arg is pointer data which should have been copied
+        goto retval;	// __poll_t is of size unsigned int
+      break;
+      case GPIO_CHARDEV_READ: // .read = lineinfo_watch_read
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static ssize_t lineinfo_watch_read(struct file *file, char __user *buf, size_t count, loff_t *off)
+        ret = file->f_op->read(file, buffer_pos, kbuf_ext->count, NULL);		//
+        if (ret) {
+          pr_err("Reading lineinfo returned zero\n");
+          kfree(kbuf);
+          return -EFAULT;
+        }
+      return -ENXIO;
+      case GPIO_CHARDEV_OWNER: // .owner = THIS_MODULE
+        if (copy_to_user(buffer_pos, file->f_op->owner->name, strlen(file->f_op->owner->name)+1)) {
+          pr_err("GPIO, copying user return value failed\n");
+          kfree(kbuf);
+          return -EFAULT;
+        }
+      break;
+      default:
+        pr_err("GPIO, Illegal proxy signal type\n");
+        kfree(kbuf);
+        return -EPERM;
+      break;
+    };
+  };
+
+	goto end;
+
+	retlong:
+	if ( copy_to_user(buffer_pos, &ret_l, sizeof(ret_l)) ) {
+:		pr_err("GPIO, copying int user return value failed\n");
+		kfree(kbuf);
+		return -EFAULT;
+	};
+  */
+
+	goto end;
+
+	retval:
+  *return_value = ret;
+  deb_verbose("retval (guest): 0x%X", ret);
+	if ( copy_to_user((void *)buffer, &ret, sizeof(ret)) ) {
+		pr_err("GPIO, copying int user return value failed\n");
+		kfree(kbuf);
+		return -EFAULT;
+	};
+
+	goto end;
+
+	end:
+	kfree(kbuf);
+	return len;
+}
diff --git a/drivers/gpio-host-proxy/Kconfig b/drivers/gpio-host-proxy/Kconfig
new file mode 100644
index 0000000..3047dab
--- /dev/null
+++ b/drivers/gpio-host-proxy/Kconfig
@@ -0,0 +1,10 @@
+config TEGRA_GPIO_HOST_PROXY
+	depends on GPIO_TEGRA && GPIO_TEGRA186
+		bool "Tegra GPIO host proxy support"
+		help
+		Exposes the GPIO capabilities __iomem to the user space, in order to support the 
+		GPIO passthrough to virtual machines.
+
+		Say Y here to enable this driver and to compile this driver as a module, 
+		choose M here. If unsure, say N
+
diff --git a/drivers/gpio-host-proxy/Makefile b/drivers/gpio-host-proxy/Makefile
new file mode 100644
index 0000000..c2e0184
--- /dev/null
+++ b/drivers/gpio-host-proxy/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_TEGRA_GPIO_HOST_PROXY) += gpio-host-proxy.o
diff --git a/drivers/gpio-host-proxy/gpio-host-proxy.c b/drivers/gpio-host-proxy/gpio-host-proxy.c
new file mode 100644
index 0000000..42c200e
--- /dev/null
+++ b/drivers/gpio-host-proxy/gpio-host-proxy.c
@@ -0,0 +1,708 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/**
+ * NVIDIA GPIO host Proxy Kernel Module
+ * (c) 2023 Unikie, Oy
+ * (c) 2023 Kim Sandstrom kim.sandstrom@unikie.com
+ *
+ **/
+#include <linux/module.h>	  // Core header for modules.
+#include <linux/device.h>	  // Supports driver model.
+#include <linux/kernel.h>	  // Kernel header for convenient functions.
+#include <linux/fs.h>		  // File-system support.
+#include <linux/uaccess.h>	  // User access copy function support.
+#include <linux/slab.h>
+//#include <soc/tegra/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/gpio/driver.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/namei.h>
+#include <linux/delay.h>
+
+#include "../gpio-host-proxy/gpio-host-proxy.h"
+const unsigned char rwl_std_type     = RWL_STD;
+const unsigned char rwl_raw_type     = RWL_RAW;
+const unsigned char rwl_relaxed_type = RWL_RELAXED;
+
+#define DEVICE_NAME "gpio-host"   // Device name.
+#define CLASS_NAME  "chardrv"	  // < The device class -- this is a character device driver
+
+MODULE_LICENSE("GPL\n");						///< The license type -- this affects available functionality
+MODULE_AUTHOR("Kim SandstrÃ¶m\n");					///< The author -- visible when you use modinfo
+MODULE_DESCRIPTION("NVidia GPIO Host Proxy Kernel Module\n");	///< The description -- see modinfo
+MODULE_VERSION("0.0\n");						///< A version number to inform users
+
+#define GPIO_DEBUG
+#define GPIO_DEBUG_VERBOSE       // also activates deb_verbose commands
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, kbasename(__FILE__), ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
+extern struct gpio_chip *find_chip_by_name(const char *);
+extern struct gpio_chip *find_chip_by_id(int);
+const char *tegra_chiplabel[2] = {TEGRA_GPIO_LABEL,TEGRA_GPIO_AON_LABEL};
+EXPORT_SYMBOL_GPL(tegra_chiplabel);
+
+/**
+ * Important variables that store data and keep track of relevant information.
+ */
+static int major_number;
+
+static struct class *gpio_host_proxy_class = NULL;	///< The device-driver class struct pointer
+static struct device *gpio_host_proxy_device = NULL; ///< The device-driver device struct pointer
+
+/**
+ * Prototype functions for file operations.
+ */
+static int open(struct inode *, struct file *);
+static int close(struct inode *, struct file *);
+static ssize_t read(struct file *, char *, size_t, loff_t *);
+static ssize_t write(struct file *, const char *, size_t, loff_t *);
+
+static char return_buffer[MEM_SIZE];   // using the same size as the input buffer
+static int *return_value = (int *)return_buffer;  // local return value for chardev interaction
+
+/**
+ * File operations structure and the functions it points to.
+ */
+static struct file_operations fops =
+	{
+		.owner = THIS_MODULE,
+		.open = open,
+		.release = close,
+		.read = read,
+		.write = write
+	};
+
+// GPIO allowed resources structure
+// static struct gpio_allowed_res gpio_ares;
+
+#ifdef GPIO_DEBUG_VERBOSE
+  // Usage:
+  //   hexDump(devName, desc, addr, len, perLine);
+  //     devName  name of device being debugged, for reference
+  //     desc:    if non-NULL, printed as a description before hex dump.
+  //     addr:    the address to start dumping from.
+  //     len:     the number of bytes to dump.
+  //     perLine: number of bytes on each output line.
+  void hexDump (
+    const char * deviceName,
+    const char * desc,
+    const void * addr,
+    const int len
+  ) {
+    // Silently ignore silly per-line values.
+
+    int i;
+    unsigned char buff[17];
+    unsigned char out_buff[4000];
+    unsigned char *p_out_buff = out_buff;
+    const unsigned char * pc = (const unsigned char *)addr;
+
+
+
+    // Output description if given.
+
+    if (desc != NULL) printk ("%s:\n", desc);
+
+    // Length checks.
+
+    if (len == 0) {
+      printk("%s:   ZERO LENGTH\n", deviceName);
+      return;
+    }
+    if (len < 0) {
+      printk("%s:   NEGATIVE LENGTH: %d\n", deviceName, len);
+      return;
+    }
+
+    if(len > 400){
+      printk("%s:   VERY LONG: %d\n", deviceName, len);
+      return;
+    }
+
+    // Process every byte of hexDump data.
+
+    for (i = 0; i < len; i++) {
+      // Multiple of perLine means new or first line (with line offset).
+
+      if ((i % 16) == 0) {
+        // Only print previous-line ASCII buffer for lines beyond first.
+
+        if (i != 0) {
+          p_out_buff += sprintf (p_out_buff, "  %s\n", buff);
+        }
+        // Output the offset of current line.
+
+        p_out_buff += sprintf (p_out_buff,"  %04x ", i);
+      }
+
+      // Now the hex code for the specific character.
+
+      p_out_buff += sprintf (p_out_buff, " %02x", pc[i]);
+
+      // And buffer a printable ASCII character for later.
+
+      if ((pc[i] < 0x20) || (pc[i] > 0x7e)) // isprint() may be better.
+        buff[i % 16] = '.';
+      else
+        buff[i % 16] = pc[i];
+      buff[(i % 16) + 1] = '\0';
+    }
+
+    // Pad out last line if not exactly perLine characters.
+
+    while ((i % 16) != 0) {
+      p_out_buff += sprintf (p_out_buff, "   ");
+      i++;
+    }
+
+    // And print the final ASCII buffer.
+
+    p_out_buff += sprintf (p_out_buff, "  %s\n", buff);
+
+    printk("%s: %s", deviceName, out_buff);
+  }
+  EXPORT_SYMBOL_GPL(hexDump);
+#else
+  #define hexDump(...)
+#endif
+
+/**
+ * Initializes module at installation
+ */
+static int gpio_host_proxy_probe(struct platform_device *pdev)
+{
+  // int i;
+	deb_info("installing module.\n");
+
+  // *********************
+  // start of TODO clocks and resets -- this commect section is probably not valid
+
+  //	// Read allowed clocks and reset from the device tree
+  //	// if clocks or resets are not defined, not initialize the module
+  //	gpio_ares.clocks_size = of_property_read_variable_u32_array(pdev->dev.of_node,
+  //		"allowed-clocks", gpio_ares.clock, 0, GPIO_HOST_MAX_CLOCKS_SIZE);
+  //
+  //	if(gpio_ares.clocks_size <= 0){
+  //		pr_err("No allowed clocks defined\n");
+  //		return EINVAL;
+  //	}
+  //
+  //	deb_info("gpio_ares.clocks_size: %d", gpio_ares.clocks_size);
+  //	for (i = 0; i < gpio_ares.clocks_size; i++)	{
+  //		deb_info("gpio_ares.clock %d", gpio_ares.clock[i]);
+  //	}
+  //
+  //	gpio_ares.resets_size = of_property_read_variable_u32_array(pdev->dev.of_node,
+  //		"allowed-resets", gpio_ares.reset, 0, GPIO_HOST_MAX_RESETS_SIZE);
+  //
+  //	if(gpio_ares.resets_size <= 0){
+  //		pr_err("No allowed resets defined\n");
+  //		return EINVAL;
+  //	}
+  //
+  //	deb_info("gpio_ares.resets_size: %d", gpio_ares.resets_size);
+  //	for (i = 0; i < gpio_ares.resets_size; i++)	{
+  //		deb_info("gpio_ares.reset %d", gpio_ares.reset[i]);
+  //	}
+  // end of TODO clocks and resets
+  // *********************
+
+	// Allocate a major number for the device.
+	major_number = register_chrdev(0, DEVICE_NAME, &fops);
+	if (major_number < 0)
+	{
+		pr_err("could not register number.\n");
+		return major_number;
+	}
+	deb_info("registered correctly with major number %d", major_number);
+
+	// Register the device class
+	gpio_host_proxy_class = class_create(THIS_MODULE, CLASS_NAME);
+	if (IS_ERR(gpio_host_proxy_class))
+	{ // Check for error and clean up if there is
+		unregister_chrdev(major_number, DEVICE_NAME);
+		pr_err("Failed to register device class\n");
+		return PTR_ERR(gpio_host_proxy_class); // Correct way to return an error on a pointer
+	}
+	deb_info("device class registered correctly\n");
+
+	// Register the device driver
+	gpio_host_proxy_device = device_create(gpio_host_proxy_class, NULL, MKDEV(major_number, 0), NULL, DEVICE_NAME);
+	if (IS_ERR(gpio_host_proxy_device))
+	{ // Clean up if there is an error
+		class_destroy(gpio_host_proxy_class);
+		unregister_chrdev(major_number, DEVICE_NAME);
+		pr_err("Failed to create the device\n");
+		return PTR_ERR(gpio_host_proxy_device);
+	}
+
+	deb_info("device class created correctly\n"); // Made it! device was initialized
+
+	return 0;
+}
+
+/*
+ * Removes module, sends appropriate message to kernel
+ */
+static int gpio_host_proxy_remove(struct platform_device *pdev)
+{
+	deb_info("removing module.\n");
+	device_destroy(gpio_host_proxy_class, MKDEV(major_number, 0)); // remove the device
+	class_unregister(gpio_host_proxy_class);						  // unregister the device class
+	class_destroy(gpio_host_proxy_class);						  // remove the device class
+	unregister_chrdev(major_number, DEVICE_NAME);		  // unregister the major number
+	deb_info("Goodbye from the LKM!\n");
+	unregister_chrdev(major_number, DEVICE_NAME);
+	return 0;
+}
+
+/*
+ * Opens device module, sends appropriate message to kernel
+ */
+static int open(struct inode *inodep, struct file *filep)
+{
+	deb_info("device opened.\n");
+	return 0;
+}
+
+/*
+ * Closes device module, sends appropriate message to kernel
+ */
+static int close(struct inode *inodep, struct file *filep)
+{
+	deb_info("device closed.\n");
+	return 0;
+}
+
+/*
+ * Reads from device, displays in userspace, and deletes the read data
+ */
+static ssize_t read(struct file *filp, char *buf, size_t len, loff_t *offset) {
+    int remaining_length = sizeof(*return_value) - *offset;
+
+	  deb_info("host: read gpio chardev\n");
+	  deb_verbose("host: read op: len = %ld, offset = %lld, *return_value = 0x%X\n", len, *offset, *return_value);
+
+    if ( remaining_length < 0 ) {
+	      deb_info("host: unrecoverable length *error*, remaining_length = %d\n", remaining_length);
+        return -EINVAL;
+    }
+
+    if ( len > remaining_length ) {
+	      deb_info("host: recoverable length *error*, len = %ld, remaining_length = %d, rlen = %ld\n", len, remaining_length, sizeof(*return_value));
+        len = remaining_length - *offset;
+    }
+
+    if (copy_to_user(buf + *offset, return_buffer + *offset, len)) {
+	      deb_info("host: failed to copy to user\n");
+        return -EFAULT;
+    }
+
+    *offset += len;
+
+    // Check if all data was copied
+    if (sizeof(*return_value) < len) {
+	      deb_info("host: not all bytes were copied\n");
+        // If not, set the error status and return the number of bytes actually copied
+        // return -EINVAL;
+    }
+    
+    // Otherwise, indicate success by returning the number of bytes requested
+    return len;
+}
+
+/*
+ * Writes to the device
+ */
+
+static ssize_t write(struct file *filep, const char *buffer, size_t len, loff_t *offset)
+{
+  int ret;  // 32 bits
+	// unsigned long int ret_l;
+	struct tegra_gpio_pt *kbuf = NULL;
+  struct tegra_readl_writel *kbuf_rw = NULL;
+	tegra_gpio_pt_extended *kbuf_ext = NULL;
+  // unsigned char *mask;
+
+  /*
+	static struct file *file;
+	static struct inode *inode = NULL;
+  */
+	struct gpio_chip *chip;
+  #ifdef GPIO_DEBUG
+	  struct gpio_chip *chip_alt;
+  #endif
+
+	char *buffer_pos = (char *)buffer;
+
+	deb_info("## writeing %zu bytes to chardev ##", len);
+
+  // We allow tegra_gpio_pt alone or with tegra_gpio_pt_extended
+	if( len != sizeof(struct tegra_gpio_pt) && 
+      len != sizeof(struct tegra_gpio_pt) + sizeof(tegra_gpio_pt_extended) &&
+      len != sizeof(struct tegra_readl_writel) )  {
+		pr_err("Illegal chardev data length. Expected %ld, %ld or %ld, but got %ld\n", 
+         sizeof(struct tegra_gpio_pt), 
+         sizeof(struct tegra_gpio_pt) + sizeof(tegra_gpio_pt_extended),
+         sizeof(struct tegra_readl_writel), 
+         len);
+    hexDump (DEVICE_NAME, "Chardev (host) input error", buffer, len);
+		return -ENOEXEC;  // we dont want kernel panic
+	}
+
+  if(!offset) {
+    pr_err("offset pointer is null, ignoring offset\n");
+  }
+  else {
+	  buffer_pos += (*offset);
+  }
+
+	kbuf = kmalloc(len, GFP_KERNEL);
+	if ( !kbuf ) {
+	  pr_err("kbuf memory allocation failed\n");
+	  return -ENOMEM;
+	}
+	memset(kbuf, 0, len);
+
+	// Copy header
+  if (copy_from_user(kbuf, buffer_pos, sizeof(struct tegra_gpio_pt))) {
+    pr_err("copy_from_user failed\n");
+    kfree(kbuf);
+    return -ENOMEM;
+  }
+  // deb_verbose("kbuf is set up at kbuf=%p", kbuf);
+
+  /* this should already been done by the passthrough qemu device
+  // mask away length from first byte where it is encoded in the top 7 bits (chipnum is lowest bit)
+  mask = (unsigned char *)kbuf;
+  *mask = *mask && 0x01;
+  */
+  
+  // we are not checking if tegra_gpio_pt_extended is used, we only check for memory allocation
+  if( len == (sizeof(struct tegra_gpio_pt) + sizeof(tegra_gpio_pt_extended) ) ) {
+    kbuf_ext = (tegra_gpio_pt_extended *)(kbuf + 1);
+    deb_verbose("kbuf_ext is set up at kbuf_ext=%p", kbuf_ext);
+  }
+
+  // print copied user parameters
+  hexDump (DEVICE_NAME, "Chardev input", kbuf, len);
+
+  // make gpio-host type call to gpio
+	deb_verbose("Passthrough in host with signal: %c, Chip %d, Offset %d, Level %d", kbuf->signal, kbuf->chipnum, kbuf->offset, kbuf->level);
+  /*
+  #ifdef GPIO_DEBUG
+  deb_verbose("Debug abort\n");
+  return 0;
+  #endif
+  */
+
+  switch (kbuf->signal) {
+    case GPIO_READL:
+      kbuf_rw = (struct tegra_readl_writel *)kbuf;
+      deb_verbose("readl debug A\n");
+      switch (kbuf_rw->rwltype) {
+        case RWL_STD:
+          ret = (int)readl(kbuf_rw->address);
+        break;
+        case RWL_RAW:
+          ret = (int)__raw_readl(kbuf_rw->address);
+        break;
+        case RWL_RELAXED:
+          ret = (int)readl_relaxed(kbuf_rw->address);
+        break;
+      }
+      deb_verbose("readl debug B\n");
+      goto retval;
+    break;
+    case GPIO_WRITEL:
+      kbuf_rw = (struct tegra_readl_writel *)kbuf;
+      deb_verbose("writel debug A\n");
+      switch (kbuf_rw->rwltype) {
+        case RWL_STD:
+          writel(kbuf_rw->value, kbuf_rw->address);
+        break;
+        case RWL_RAW:
+          __raw_writel(kbuf_rw->value, kbuf_rw->address);
+        break;
+        case RWL_RELAXED:
+          writel_relaxed(kbuf_rw->value, kbuf_rw->address);
+        break;
+      deb_verbose("writel debug B\n");
+      goto end;
+      }
+    break;
+  }
+  // if switch above is triggered we will either goto retval or goto end
+
+  chip = find_chip_by_id(kbuf->chipnum);
+
+  switch (kbuf->signal) {
+    case GPIO_REQ:
+      #ifdef GPIO_DEBUG_VERBOSE
+        chip_alt = find_chip_by_name(tegra_chiplabel[kbuf->chipnum]);
+        if(chip != chip_alt) {
+          deb_debug("conflicting chip pointers -- primary %p, alternative %p", chip, chip_alt);
+          chip = chip_alt; // we assume find_chip_by_name is more reliable
+        }
+      #endif
+      if(!chip) {
+        pr_err("In GPIO_REQ, chip pointer's pvalue is unexpectedly NULL for chip %s\n", tegra_chiplabel[kbuf->chipnum]);
+        kfree(kbuf);
+        return -ENODEV;
+      }
+      deb_verbose("GPIO_REQ, using GPIO chip %s, for device %d\n", chip->label, kbuf->chipnum);
+      ret = chip->request(chip, kbuf->offset);
+	    goto end;
+    break;
+    case GPIO_FREE:
+      deb_verbose("GPIO_FREE\n");
+      chip->free(chip, kbuf->offset);
+      // chip_alt = NULL;
+      goto end;
+    break;
+    case GPIO_GET_DIR:
+      deb_verbose("GPIO_GET_DIR\n");
+      ret = chip->get_direction(chip, kbuf->offset);
+      goto retval;
+    break;
+    case GPIO_SET_IN:
+      deb_verbose("GPIO_SET_IN\n");
+      ret = chip->direction_input(chip, kbuf->offset);
+      goto retval;
+    break;
+    case GPIO_SET_OUT:
+      deb_verbose("GPIO_SET_OUT\n");
+      ret = chip->direction_output(chip, kbuf->offset, kbuf->level);
+      goto retval;
+    break;
+    case GPIO_GET:
+      deb_verbose("GPIO_GET\n");
+      ret = chip->get(chip, kbuf->offset);
+      goto retval;
+    break;
+    case GPIO_SET:
+      deb_verbose("GPIO_SET, set %d at offset 0x%x in gpiochip %s\n", kbuf->level, kbuf->offset, chip->label);
+      chip->set(chip, kbuf->offset, kbuf->level);
+	    goto end;
+    break;
+    case GPIO_CONFIG:
+      deb_verbose("GPIO_CONFIG\n");
+      chip->set_config(chip, kbuf->offset, kbuf_ext->config); // arg mapped to unsigned long config
+	    goto end;
+    break;
+    case GPIO_TIMESTAMP_CTRL:
+      deb_verbose("GPIO_TIMESTAMP_CTRL\n");
+      ret = chip->timestamp_control(chip, kbuf->offset, kbuf->level);	// mapping level onto enable
+      goto retval;
+    break;
+    case GPIO_TIMESTAMP_READ:
+      deb_verbose("GPIO_TIMESTAMP_READ\n");
+      ret = chip->timestamp_read(chip, kbuf->offset, (u64 *)buffer_pos);	// timestamp is u64, return value as pointer
+      if(ret) {
+        pr_err("GPIO_TIMESTAMP_READ error\n");
+        goto end;
+      }
+      // timestamp_read returns value directly to buffer_pos
+      goto end;
+    break;
+    case GPIO_SUSPEND_CONF:
+      deb_verbose("GPIO_SUSPEND_CONF\n");
+      if(!kbuf_ext) {
+        pr_err("Parameter error in GPIO_SUSPEND_CONF\n");
+        return -EINVAL;
+      }
+      ret = chip->suspend_configure(chip, kbuf->offset, kbuf_ext->dflags);
+      goto retval;
+    break;
+    case GPIO_ADD_PINRANGES:
+      deb_verbose("GPIO_ADD_PINRANGES\n");
+      ret = chip->add_pin_ranges(chip);
+      goto retval;
+    break;
+  };
+
+  /* ioctl signals use flieops because it relises on the standard gpio chardevs
+  static const struct file_operations gpio_fileops = {
+  .release = gpio_chrdev_release,
+  .open = gpio_chrdev_open,
+  .poll = lineinfo_watch_poll,
+  .read = lineinfo_watch_read,
+  .owner = THIS_MODULE,
+  .llseek = no_llseek,
+  .unlocked_ioctl = gpio_ioctl,
+  #ifdef CONFIG_COMPAT
+    .compat_ioctl = gpio_ioctl_compat,
+  #endif
+  };
+  */
+
+  /*
+  if(kbuf_ext) {
+    switch (kbuf->signal) {
+*/
+      /* commands to ioctl below (the std gpio chardev)
+      * not fully implemented
+      * linehandle_create  -- when userspace requests output (called by gpio_ioctl) -- bypasses the chardev
+      * linehandle_ioctl   -- linehandle_ioctl when userspace does actual io (toggles pin)
+      *    cmd:
+      *    GPIOHANDLE_GET_LINE_VALUES_IOCTL,
+      *    GPIOHANDLE_SET_LINE_VALUES_IOCTL,
+      *    GPIOHANDLE_SET_CONFIG_IOCTL
+      *    arg: user input or output
+      */
+/*
+      // We could want to use the stock gpio chardev (/dev/gpiochip0 and /dev/gpiochip1) /bc userspace functions use it
+      // this code is not yet complete and it mey be better to use the stock devices directly.
+      case GPIO_CHARDEV_OPEN:	// .open = gpio_chrdev_open
+        file = filp_open(tegra_chiplabel[kbuf->chipnum], O_RDWR, 0);
+          if (IS_ERR(file)) {
+            pr_err("GPIO, failed to open chardev for chip %s: %ld", tegra_chiplabel[kbuf->chipnum], PTR_ERR(file));
+            kfree(kbuf);
+            return -ENOENT;
+          }
+        // note: inode and file are static variables
+        inode = file->f_path.dentry->d_inode;
+        // defined as: static int gpio_chrdev_open(struct inode *inode, struct file *file)
+        ret = file->f_op->open(inode, file);
+        goto retval;
+      break;
+      case GPIO_CHARDEV_IOCTL:	// .unlocked_ioctl = gpio_ioctl
+        // user space triggers gpio_ioctl -- it is .unlocked_ioctl on the chardev
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static long gpio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+        ret_l = file->f_op->unlocked_ioctl(file, kbuf->cmd, kbuf_ext->arg);	// arg is pointer data which should have been copied from userspace
+        goto retlong;
+      break;
+      case GPIO_CHARDEV_RELEASE: // .release = gpio_chrdev_release
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static int gpio_chrdev_release(struct inode *inode, struct file *file)
+        ret = file->f_op->release(inode, file);
+        goto retval;
+      break;
+      case GPIO_CHARDEV_POLL: // .poll = lineinfo_watch_poll
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        })
+        // defined as: static __poll_t lineinfo_watch_poll(struct file *file, struct poll_table_struct *pollt)
+        ret = file->f_op->poll(file, kbuf_ext->poll);	// TODO arg is pointer data which should have been copied
+        goto retval;	// __poll_t is of size unsigned int
+      break;
+      case GPIO_CHARDEV_READ: // .read = lineinfo_watch_read
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static ssize_t lineinfo_watch_read(struct file *file, char __user *buf, size_t count, loff_t *off)
+        ret = file->f_op->read(file, buffer_pos, kbuf_ext->count, NULL);		//
+        if (ret) {
+          pr_err("Reading lineinfo returned zero\n");
+          kfree(kbuf);
+          return -EFAULT;
+        }
+      return -ENXIO;
+      case GPIO_CHARDEV_OWNER: // .owner = THIS_MODULE
+        if (copy_to_user(buffer_pos, file->f_op->owner->name, strlen(file->f_op->owner->name)+1)) {
+          pr_err("GPIO, copying user return value failed\n");
+          kfree(kbuf);
+          return -EFAULT;
+        }
+      break;
+      default:
+        pr_err("GPIO, Illegal proxy signal type\n");
+        kfree(kbuf);
+        return -EPERM;
+      break;
+    };
+  };
+
+	goto end;
+
+	retlong:
+	if ( copy_to_user(buffer_pos, &ret_l, sizeof(ret_l)) ) {
+		pr_err("GPIO, copying int user return value failed\n");
+		kfree(kbuf);
+		return -EFAULT;
+	};
+  */
+
+	goto end;
+
+	retval:
+  *return_value = ret;
+  deb_verbose("retval (host): 0x%X", ret);
+	if ( copy_to_user((void *)buffer, &ret, sizeof(ret)) ) {
+		pr_err("GPIO, copying unsigned int user return value failed\n");
+		kfree(kbuf);
+		return -EFAULT;
+	};
+
+	end:
+	kfree(kbuf);
+	return len; // return length of read data
+}
+
+/* module creation -- see also gpio_host_proxy_probe and gpio_host_proxy_remove */
+
+static const struct of_device_id gpio_host_proxy_ids[] = {
+	{ .compatible = "nvidia,gpio-host-proxy" },
+	{ }
+};
+
+static struct platform_driver gpio_host_proxy_driver = {
+	.driver = {
+    .name = "gpio_host_proxy",
+    .owner = THIS_MODULE,
+    .of_match_table = gpio_host_proxy_ids,
+	},
+	.probe = gpio_host_proxy_probe,
+	.remove = gpio_host_proxy_remove,
+};
+// builtin_platform_driver(gpio_host_proxy_driver);
+
+static int __init gpio_host_proxy_init(void)
+{
+    int ret = 0;
+
+    ret = platform_driver_register(&gpio_host_proxy_driver);
+    if (ret != 0) {
+        pr_err("GPIO, Error %d registering gpio host proxy driver", ret);
+    } else {
+        deb_info("GPIO gpio host proxy driver registered successfully\n");
+    }
+
+    return ret;
+}
+
+static void __exit gpio_host_proxy_exit(void)
+{
+    platform_driver_unregister(&gpio_host_proxy_driver);
+    deb_info("GPIO gpio host proxy driver unregistered\n");
+}
+
+module_init(gpio_host_proxy_init);
+module_exit(gpio_host_proxy_exit);
diff --git a/drivers/gpio-host-proxy/gpio-host-proxy.h b/drivers/gpio-host-proxy/gpio-host-proxy.h
new file mode 100644
index 0000000..55cdbaa
--- /dev/null
+++ b/drivers/gpio-host-proxy/gpio-host-proxy.h
@@ -0,0 +1,115 @@
+#ifndef __GPIO_HOST_PROXY__H__
+#define __GPIO_HOST_PROXY__H__
+
+#include <linux/types.h>  // For __iomem definition
+#include <linux/io.h>	// For functions related to I/O operations
+#include <stddef.h>
+#include <linux/gpio/consumer.h>	// for gpiod_flags
+
+// as a workaround this struct is copied here from drivers/gpio/gpiolib.h in kernel-5.10
+// including the original header file does not work becaue proxy drivers are in an overlay 
+// and relative paths will change (kernel-5.10 will be renamed)
+// #include ../kernel-5.10/drivers/gpio/gpiolib.h
+// this copied struct is incomplete and subset of the "real" one
+struct gpio_device {
+	int			id;
+	struct device		dev;
+  // a huge number of members are removed here -- do not "sizeof" this struct !!!
+};
+
+// size of qemu iomem. 
+// Note: Must be synchronized with value in qemu (hw/misc/nvidia_gpio_guest.c)
+#define MEM_SIZE 0x80
+
+/* values to be used as "signal" values in struct tegra_gpio_pt */
+
+// Note: signals with message size of 8 have a signal value greater than or equal to ascii char 'A'
+#define GPIO_SET             's'   // set level
+#define GPIO_GET             'g'   // get level
+#define GPIO_GET_DIR         'd'   // get direction
+#define GPIO_SET_IN          'i'   // set direction to input
+#define GPIO_SET_OUT         'o'   // set direction to output
+#define GPIO_CONFIG          'c'   // set config
+#define GPIO_SET_BY_NAME     'n'   // set config
+
+#define GPIO_REQ             'r'   // generic request
+#define GPIO_FREE            'f'   // free
+
+#define GPIO_TIMESTAMP_CTRL  'C'   // timestamp control
+#define GPIO_TIMESTAMP_READ  'T'   // timestamp read
+#define GPIO_SUSPEND_CONF    'S'   // suspend configure
+#define GPIO_ADD_PINRANGES   'P'   // add_pin_ranges
+
+// helpers to identify chip
+#define TEGRA_GPIO_CHIP       0    // tegra-gpio gpio_main_chip
+#define TEGRA_GPIO_AON_CHIP   1    // tegra-gpio-aon gpio_aon_chip
+#define TEGRA_GPIO_LABEL      "tegra234-gpio\x00\x00\x00\x00\x00\x00\x00"  // gpio_main_chip / gpiochip0 --padded to 20 bytes
+#define TEGRA_GPIO_AON_LABEL  "tegra234-gpio-aon\x00\x00\x00"              // gpio_aon_chip  / gpiochip1 --padded to 20 bytes
+#define LABEL_SIZE            20
+
+// Note: signals with message size of 16 have a signal value less than ascii char 'A'
+
+#define GPIO_READL            '<'
+#define GPIO_WRITEL           '>'
+
+#define RWL_STD               '0'   // general readl/writeL
+#define RWL_RAW               '1'   // __raw assembler version of readl/writel
+#define RWL_RELAXED           '2'   // __relaxed assembler version of readl/writel
+                                    //
+#define GPIO_CHARDEV_OPEN     '1'   // .open = gpio_chrdev_open
+#define GPIO_CHARDEV_IOCTL    '2'   // .unlocked_ioctl = gpio_ioctl -- handles IO operation, get linehandle, set direction
+#define GPIO_CHARDEV_POLL     '3'   // .poll = lineinfo_watch_poll
+#define GPIO_CHARDEV_READ     '4'   // .read = lineinfo_watch_read
+#define GPIO_CHARDEV_OWNER    '5'   // .owner = THIS_MODULE
+#define GPIO_CHARDEV_SEEK     '6'   // .llseek = no_llseek
+#define GPIO_CHARDEV_RELEASE  '7'   // .release = gpio_chrdev_release
+
+
+// Note this extern is also in gpio-proxy.h in the kernel source tree (this proxy code might be in an overlay)
+extern const unsigned char rwl_std_type;
+extern const unsigned char rwl_raw_type;
+extern const unsigned char rwl_relaxed_type;
+
+// sizeof is rounded to even 64 bit passhtough writes -- no need to optimise size further on an aarch64
+struct tegra_readl_writel {
+  unsigned char length;       // shift right one bit, most LSB is ignored
+  unsigned char signal;       // Note: 'signal' field is overlapping (based on field offset) with signal in struct tegra_gpio_pt
+  unsigned char rwltype;      // type of readl/writel call; std, raw, relaxed
+  unsigned char pad[1];       // to get no word wrap at mod 64 bit message size
+  u32 value;
+  void * address;
+};
+
+// struct __attribute__((packed)) tegra_gpio_pt {
+struct tegra_gpio_pt {
+  unsigned char chipnum;      // lowest bit is number of gpio chip (gpiochip0 or gpiochip1), top 7 bits are message length
+  unsigned char signal;       // defines operation
+  unsigned char level;        // level to set gpio pin to
+  unsigned char offset;       // address offset for gpio pin
+  // u32 cmd;                    // gpio_ioctl command
+  // tegra_gpio_pt_extended p2;          // extended parameters -- in second word of struct
+};
+
+union extended {
+  // int level;                // pin level to be set
+  unsigned long config;     // pin configuration
+  int enable;
+  size_t count;             // lineinfo read size
+  struct poll_table_struct *poll;
+  enum gpiod_flags dflags;
+  u64 arg;                  // gpio_ioctl argument (this is interpreted as a pointer)
+};
+
+typedef union extended tegra_gpio_pt_extended;
+
+#define MAX_CHIP 2
+
+_Static_assert( sizeof(struct tegra_readl_writel) == 16,
+               "tegra_readl_writel size is not 16 bytes." );
+
+_Static_assert( sizeof(struct tegra_gpio_pt) == 4,
+               "tegra_gpio_pt size is not 4 bytes." );
+
+_Static_assert( sizeof(tegra_gpio_pt_extended) == 8,
+               "tegra_gpio_pt_extended size is not 8 bytes." );
+#endif
