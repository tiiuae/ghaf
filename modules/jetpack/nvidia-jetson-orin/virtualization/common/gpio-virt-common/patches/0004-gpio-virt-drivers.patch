diff --git a/drivers/Kconfig b/drivers/Kconfig
index dcecc9f6e33f..ed7d58d68ba6 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -235,4 +235,10 @@ source "drivers/interconnect/Kconfig"
 source "drivers/counter/Kconfig"
 
 source "drivers/most/Kconfig"
+
+if ARCH_TEGRA
+source "drivers/gpio-host-proxy/Kconfig"
+source "drivers/gpio-guest-proxy/Kconfig"
+endif
+
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
--- a/drivers/Makefile	2024-02-23 12:43:23.937526730 +0000
+++ b/drivers/Makefile	2024-05-02 07:08:17.247764422 +0000
@@ -193,0 +194,5 @@
+#
+#
+#
+obj-y	+= gpio-host-proxy/
+obj-y	+= gpio-guest-proxy/
diff --git a/drivers/gpio-guest-proxy/Kconfig b/drivers/gpio-guest-proxy/Kconfig
new file mode 100644
index 0000000..e25a19a
--- /dev/null
+++ b/drivers/gpio-guest-proxy/Kconfig
@@ -0,0 +1,11 @@
+config TEGRA_GPIO_GUEST_PROXY
+	depends on GPIO_TEGRA && GPIO_TEGRA186
+		bool "Tegra GPIO guest proxy driver"
+		help
+		The Tegra GPIO guest proxy driver, virtualise GPIO __iomem initalised by host, 
+		allowing the guest to access host GPIO.
+
+		Say Y here to enable this driver and to compile this driver as a module, 
+		choose M here. If unsure, say N
+
+
diff --git a/drivers/gpio-guest-proxy/Makefile b/drivers/gpio-guest-proxy/Makefile
new file mode 100644
index 0000000..2580e02
--- /dev/null
+++ b/drivers/gpio-guest-proxy/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_TEGRA_GPIO_GUEST_PROXY) += gpio-guest-proxy.o
diff --git a/drivers/gpio-guest-proxy/gpio-guest-proxy.c b/drivers/gpio-guest-proxy/gpio-guest-proxy.c
new file mode 100644
index 0000000..95aa5be
--- /dev/null
+++ b/drivers/gpio-guest-proxy/gpio-guest-proxy.c
@@ -0,0 +1,775 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/**
+ * NVIDIA GPIO Guest Proxy Kernel Module
+ * (c) 2023 Unikie, Oy
+ * (c) 2023 Kim Sandstrom kim.sandstrom@unikie.com
+ *
+ **/
+
+#include <linux/module.h>	  // Core header for modules.
+#include <linux/device.h>	  // Supports driver model.
+#include <linux/kernel.h>	  // Kernel header for convenient functions.
+#include <linux/fs.h>		  // File-system support.
+#include <linux/uaccess.h>	  // User access copy function support.
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/memory_hotplug.h>
+#include <linux/io.h>
+#include "../gpio-host-proxy/gpio-host-proxy.h"
+#include <linux/gpio/driver.h>
+#include <linux/of_device.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/namei.h>
+#include <linux/delay.h>
+
+// we need a workaround for this -- relevant data copied to gpio-host-proxy.h
+// #include "$(abs_srctree)/drivers/gpio/gpiolib.h"
+
+
+
+#define DEVICE_NAME "gpio-guest" // Device name.
+#define CLASS_NAME "char"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kim Sandstrom");
+MODULE_DESCRIPTION("NVidia GPIO Guest Proxy Kernel Module");
+MODULE_VERSION("0.0");
+
+#define GPIO_DEBUG
+#define GPIO_DEBUG_VERBOSE       // also activates deb_verbose commands
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, __FILE__, ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__ , __FILE__, ##__VA_ARGS__)
+  #define deb_error(fmt, ...)    printk(KERN_ERR "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__ , __FILE__, ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+  #define deb_error(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+  extern void hexDump (
+    const char * deviceName,
+    const char * desc,
+    const void * addr,
+    const int len
+  );
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
+#define MEM_SIZE       0x0600   // size of passthrough memory (mem_iova) -- larger than needed
+static volatile void __iomem  *mem_iova = NULL;
+
+extern struct gpio_chip *find_chip_by_name(const char *);
+extern struct gpio_chip *find_chip_by_id(int);
+extern const char **tegra_chiplabel;
+
+extern int gpio_outloud;
+extern uint64_t gpio_vpa;
+
+/* functions redirected to guest-proxy from gpio-tegra186.c
+ * from setup of gpio_chip in tegra186_gpio_probe
+ */
+
+/* guest_chardev_transfer
+ * a helper function to transfer between guest and host using /dev/gpio-host
+ * mgs: is a pointer to data -- in practice tegra_gpio_pt and tegra_gpio_pt_extended structs
+ * generic return: poiter to return data, may be NULL if we do not expect a return value
+ */ 
+void guest_chardev_transfer(void *msg, int msg_len, int *generic_return)
+{
+	unsigned char *io_buffer;
+
+	deb_debug("\n");
+
+	// Copy msg, to io_buffer
+	io_buffer = kmalloc(msg_len, GFP_KERNEL);
+	memset(io_buffer, 0, msg_len);
+  memcpy(io_buffer, msg, msg_len);
+
+  #ifdef GPIO_DEBUG_VERBOSE
+    hexDump(DEVICE_NAME, "msg", &msg, msg_len);
+    deb_verbose("msg signal is: %c\n", *(char *)msg);
+  #endif
+
+	// Execute the request by copying the io_buffer
+	memcpy_toio(mem_iova, io_buffer, msg_len);
+
+	// Read response to io_buffer
+	memcpy_fromio(io_buffer, mem_iova, sizeof(*generic_return));
+
+  // check if we expect a return value
+  if(generic_return) {
+	// Copy reply to io_buffer
+	memcpy(generic_return, io_buffer, sizeof(*generic_return));
+	deb_verbose("return value is copied %d\n", *generic_return);
+  }
+
+  kfree(io_buffer);
+}
+
+int gpiochip_generic_request_redirect(struct gpio_chip *chip, unsigned offset) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_REQ;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+void gpiochip_generic_free_redirect(struct gpio_chip *chip, unsigned offset) {
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_FREE;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), NULL);
+}
+
+int tegra186_gpio_get_direction_redirect(struct gpio_chip *chip,
+				       unsigned int offset) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_GET_DIR;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+int tegra186_gpio_direction_input_redirect(struct gpio_chip *chip,
+					 unsigned int offset) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_SET_IN;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+int tegra186_gpio_direction_output_redirect(struct gpio_chip *chip,
+					  unsigned int offset, int level) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_SET_OUT;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = level;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+int tegra186_gpio_get_redirect(struct gpio_chip *chip, unsigned int offset) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_GET;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+void tegra186_gpio_set_redirect(struct gpio_chip *chip, unsigned int offset,
+			      int level) {
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_SET;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = level;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), NULL);
+}
+
+void tegra186_gpio_set_by_name_redirect(const char *name, unsigned int offset,
+			      int level) {
+  struct tegra_gpio_pt msg;
+  struct gpio_chip *chip = find_chip_by_name(name);
+  msg.signal = GPIO_SET_BY_NAME;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = level;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), NULL);
+}
+
+int tegra186_gpio_set_config_redirect(struct gpio_chip *chip,
+				    unsigned int offset,
+				    unsigned long config) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_CONFIG;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+int tegra_gpio_timestamp_control_redirect(struct gpio_chip *chip, unsigned offset,
+					int enable) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_TIMESTAMP_CTRL;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+int tegra_gpio_timestamp_read_redirect(struct gpio_chip *chip, unsigned offset,
+				     u64 *ts) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_TIMESTAMP_READ;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+int tegra_gpio_suspend_configure_redirect(struct gpio_chip *chip, unsigned offset,
+					enum gpiod_flags dflags) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_SUSPEND_CONF;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = offset;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+// TODO,  this probably does not work because action parameters should be in gpio_chip struct, but guest did not copy the over the passthrough interface
+int tegra186_gpio_add_pin_ranges_redirect(struct gpio_chip *chip) {
+  int ret = 0;
+  struct tegra_gpio_pt msg;
+
+  msg.signal = GPIO_ADD_PINRANGES;
+  msg.chipnum = chip->gpiodev->id;
+  msg.level = 0;
+  msg.offset = 0;
+
+  guest_chardev_transfer(&msg, sizeof(msg), &ret);
+  return ret;
+}
+
+/*
+// export of redirection functions
+EXPORT_SYMBOL_GPL(gpiochip_generic_request_redirect);
+EXPORT_SYMBOL_GPL(gpiochip_generic_free_redirect);
+EXPORT_SYMBOL_GPL(tegra186_gpio_get_direction_redirect);
+EXPORT_SYMBOL_GPL(tegra186_gpio_direction_input_redirect);
+EXPORT_SYMBOL_GPL(tegra186_gpio_direction_output_redirect);
+EXPORT_SYMBOL_GPL(tegra186_gpio_get_redirect);
+EXPORT_SYMBOL_GPL(tegra186_gpio_set_redirect);
+EXPORT_SYMBOL_GPL(tegra186_gpio_set_by_name_redirect);
+EXPORT_SYMBOL_GPL(tegra186_gpio_set_config_redirect);
+EXPORT_SYMBOL_GPL(tegra_gpio_timestamp_control_redirect);
+EXPORT_SYMBOL_GPL(tegra_gpio_timestamp_read_redirect);
+EXPORT_SYMBOL_GPL(tegra_gpio_suspend_configure_redirect);
+EXPORT_SYMBOL_GPL(tegra186_gpio_add_pin_ranges_redirect);
+*/
+
+// unpreserve_all_tegrachips also does unhooking ?
+extern void unpreserve_all_tegrachips(void);
+struct gpio_chip * find_chip_by_id(int id);
+
+/**
+ * Important variables that store data and keep track of relevant information.
+ */
+static int major_number;
+
+static struct class *gpio_guest_proxy_class = NULL;	///< The device-driver class struct pointer
+static struct device *gpio_guest_proxy_device = NULL; ///< The device-driver device struct pointer
+
+/**
+ * Prototype functions for file operations.
+ */
+static int open(struct inode *, struct file *);
+static int close(struct inode *, struct file *);
+static ssize_t read(struct file *, char *, size_t, loff_t *);
+static ssize_t write(struct file *, const char *, size_t, loff_t *);
+
+/**
+ * File operations structure and the functions it points to.
+ */
+static struct file_operations fops =
+	{
+		.owner = THIS_MODULE,
+		.open = open,
+		.release = close,
+		.read = read,
+		.write = write
+	};
+
+static bool is_set_up = false;
+
+/**
+ * Initializes module at installation
+ */
+int tegra_gpio_guest_init(void)
+{
+  // Note: gpio is not referenced, the init is agnostic to which chip triggered this function
+  // In an earlier versio of the code we stored the gpio struct pointer in a static table
+  // int this_chip_id = gpio.gpio->gpiodev.id;
+  // char this_device[12];
+  if(is_set_up) { 
+    deb_error("Attempting to set up guest driver twice\n");
+    return -EPERM;
+  }
+
+	deb_info("installing module.");
+
+	deb_info("gpio_vpa: 0x%llx", gpio_vpa);
+
+	if(!gpio_vpa){
+		pr_err("Failed, gpio_vpa not defined");
+	}
+
+
+	// Allocate a major number for the device.
+	major_number = register_chrdev(0, DEVICE_NAME, &fops);
+	if (major_number < 0)
+	{
+		pr_err("could not register number.");
+		return major_number;
+	}
+	deb_info("registered correctly with major number %d", major_number);
+
+	// Register the device class
+	gpio_guest_proxy_class = class_create(THIS_MODULE, CLASS_NAME);
+	if (IS_ERR(gpio_guest_proxy_class))
+	{ // Check for error and clean up if there is
+		unregister_chrdev(major_number, DEVICE_NAME);
+		deb_error("Failed to register device class\n");
+		return PTR_ERR(gpio_guest_proxy_class); // Correct way to return an error on a pointer
+	}
+	deb_info("device class registered correctly\n");
+
+	// Register the device driver
+	gpio_guest_proxy_device = device_create(gpio_guest_proxy_class, NULL, MKDEV(major_number, 0), NULL, DEVICE_NAME);
+	if (IS_ERR(gpio_guest_proxy_device))
+	{								 // Clean up if there is an error
+		class_destroy(gpio_guest_proxy_class); 
+		unregister_chrdev(major_number, DEVICE_NAME);
+		deb_error("Failed to create the device\n");
+		return PTR_ERR(gpio_guest_proxy_device);
+	}
+	deb_info("device class created correctly\n"); // Made it! device was initialized
+
+	// map iomem
+	mem_iova = ioremap(gpio_vpa, MEM_SIZE);
+
+	if (!mem_iova) {
+        deb_error("ioremap failed\n");
+        return -ENOMEM;
+  }
+
+	deb_info("gpio_vpa: 0x%llX, mem_iova: %p\n", gpio_vpa, mem_iova);
+
+  // gpio_hook is called by preserve_tegrachip() in gpio_tegra186.c -- don't call it here
+  // gpio_hook()
+
+  is_set_up = true;
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(tegra_gpio_guest_init);
+
+/*
+ * Removes module, sends appropriate message to kernel
+ */
+void tegra_gpio_guest_cleanup(void)
+{
+	deb_info("removing module.\n");
+
+	// unmap iomem
+	iounmap((void __iomem*)gpio_vpa);
+
+  // gpio_unhook is called by unpreserve_all_tegrachips()
+  // gpio_unhook()
+  // clean up shared memory with stock driver and unhook all functions
+  unpreserve_all_tegrachips();
+
+	device_destroy(gpio_guest_proxy_class, MKDEV(major_number, 0)); // remove the device
+	class_unregister(gpio_guest_proxy_class);						  // unregister the device class
+	class_destroy(gpio_guest_proxy_class);						  // remove the device class
+	unregister_chrdev(major_number, DEVICE_NAME);		  // unregister the major number
+	deb_info("Goodbye from the LKM!\n");
+	unregister_chrdev(major_number, DEVICE_NAME);
+
+  is_set_up = false;
+	return;
+}
+
+
+
+
+/*
+ * Opens device module, sends appropriate message to kernel
+ */
+static int open(struct inode *inodep, struct file *filep)
+{
+	deb_info("device opened.\n");
+    gpio_outloud = 1;
+	return 0;
+}
+
+/*
+ * Closes device module, sends appropriate message to kernel
+ */
+static int close(struct inode *inodep, struct file *filep)
+{
+	deb_info("device closed.\n");
+    gpio_outloud = 0;
+	return 0;
+}
+
+/*
+ * Reads from device, displays in userspace, and deletes the read data
+ */
+static ssize_t read(struct file *filep, char *buffer, size_t len, loff_t *offset)
+{
+	deb_info("read stub");
+	return 0;
+}
+
+/*
+ * Writes to the device
+ */
+
+// TODO this is shared code with host proxy include function from there
+// look at line 335 of this file
+// extern static ssize_t chardev_write(struct file *filep, const char *buffer, size_t len, loff_t *offset)
+
+static ssize_t write(struct file *filep, const char *buffer, size_t len, loff_t *offset)
+{
+	unsigned int ret;
+	unsigned long int ret_l;
+	struct tegra_gpio_pt *kbuf = NULL;
+	tegra_gpio_pt_extended *kbuf_ext = NULL;
+
+	static struct file *file;
+	static struct inode *inode = NULL;
+	struct gpio_chip *chip;
+  #ifdef GPIO_DEBUG
+	  struct gpio_chip *chip_alt;
+  #endif
+
+	char *return_buffer = (char *)buffer;
+	char *read_buffer = (char *)buffer;
+
+	deb_info("writeing %zu bytes to chardev", len);
+
+  /* removed because condition is covered by susequent checks on 'len'
+	if (len > 65535) {
+		pr_err("count %zu exceeds max # of bytes allowed, aborting write", len);
+		return -EINVAL;
+	} */
+
+  // We allow tegra_gpio_pt alone or with tegra_gpio_pt_extended (verify later)
+	if( len != sizeof(struct tegra_gpio_pt) && len != sizeof(struct tegra_gpio_pt) + sizeof(tegra_gpio_pt_extended) )  {
+		pr_err("Illegal chardev data length. Expected %ld or %ld, got %ld", sizeof(struct tegra_gpio_pt), sizeof(struct tegra_gpio_pt) + sizeof(tegra_gpio_pt_extended), len);
+		return -ENOEXEC;
+	}
+
+  if(!offset) {
+    pr_err("offset pointer is null, ignoring offset\n");
+  }
+  else {
+	  read_buffer += (*offset);
+  }
+
+	kbuf = kmalloc(len, GFP_KERNEL);
+	if ( !kbuf ) {
+	  pr_err("kbuf memory allocation failed\n");
+	  return -ENOMEM;
+	}
+	memset(kbuf, 0, len);
+
+	// Copy header
+  if (copy_from_user(kbuf, read_buffer, sizeof(struct tegra_gpio_pt))) {
+    pr_err("copy_from_user failed\n");
+    kfree(kbuf);
+    return -ENOMEM;
+  }
+  deb_verbose("kbuf is set up, kbuf=%p", kbuf);
+
+  if( len == (sizeof(struct tegra_gpio_pt) + sizeof(tegra_gpio_pt_extended) ) ) {
+    kbuf_ext = (tegra_gpio_pt_extended *)(kbuf + 1);
+    deb_verbose("kbuf_ext is set up kbuf_ext=%p", kbuf_ext);
+  }
+
+	// print copied user parameters
+  hexDump (DEVICE_NAME, "Chardev input", kbuf, len);
+
+
+  // make gpio-host type call to gpio
+	deb_verbose("enter switch with signal: %c, Chip %d, Offset %d, Level %d", kbuf->signal, kbuf->chipnum, kbuf->offset, kbuf->level);
+
+  switch (kbuf->signal) {
+    case GPIO_REQ:
+      // if(kbuf->chipnum & 0xfe) {    // 0 and 1 are allowed values & mask allows fastcheck, marginal save
+      if(kbuf->chipnum >= MAX_CHIP) {  // direct copmparison is more future flexible
+        // te!, 
+        pr_err("Illegal value for chip number\n");
+        kfree(kbuf);
+        return -ENODEV;
+      }
+      chip = find_chip_by_id(kbuf->chipnum);
+      #ifdef GPIO_DEBUG_VERBOSE
+        chip_alt = find_chip_by_name(tegra_chiplabel[kbuf->chipnum]);
+        if(chip != chip_alt)
+          deb_debug("conflicting chip pointers -- primary %p, alternative %p", chip, chip_alt);
+      #endif
+      if(!chip) {
+        pr_err("In GPIO_REQ, chip pointer's pvalue is unexpectedly NULL for chip %s\n", tegra_chiplabel[kbuf->chipnum]);
+        kfree(kbuf);
+        return -ENODEV;
+      }
+
+      deb_verbose("GPIO_REQ, using GPIO chip %s, for device %d, pvalue = %p", chip->label, kbuf->chipnum, chip);
+      ret = chip->request(chip, kbuf->offset);
+	    goto end;
+    break;
+    case GPIO_FREE:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_FREE\n");
+      chip->free(chip, kbuf->offset);
+      // chip_alt = NULL;
+      goto end;
+    break;
+    case GPIO_GET_DIR:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_GET_DIR\n");
+      ret = chip->get_direction(chip, kbuf->offset);
+      goto retval;
+    break;
+    case GPIO_SET_IN:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_SET_IN\n");
+      ret = chip->direction_input(chip, kbuf->offset);
+      goto retval;
+    break;
+    case GPIO_SET_OUT:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_SET_OUT, chip pvalue 0 %p", chip);
+      ret = chip->direction_output(chip, kbuf->offset, kbuf->level);
+      goto retval;
+    break;
+    case GPIO_GET:
+      deb_verbose("GPIO_GET\n");
+      chip = find_chip_by_id(kbuf->chipnum);
+      ret = chip->get(chip, kbuf->offset);
+      goto retval;
+    break;
+    case GPIO_SET:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_SET, set %d at offset 0x%x in gpiochip %s", kbuf->level, kbuf->offset, chip->label);
+      chip->set(chip, kbuf->offset, kbuf->level);
+	    goto end;
+    break;
+    case GPIO_CONFIG:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_CONFIG\n");
+      chip->set_config(chip, kbuf->offset, kbuf_ext->config); // arg mapped to unsigned long config
+	    goto end;
+    break;
+    case GPIO_TIMESTAMP_CTRL:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_TIMESTAMP_CTRL\n");
+      ret = chip->timestamp_control(chip, kbuf->offset, kbuf->level);	// mapping level onto enable
+      goto retval;
+    break;
+    case GPIO_TIMESTAMP_READ:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_TIMESTAMP_READ\n");
+      ret = chip->timestamp_read(chip, kbuf->offset, (u64 *)return_buffer);	// timestamp is u64, return value as pointer
+      if(ret) {
+        pr_err("GPIO_TIMESTAMP_READ error\n");
+        goto end;
+      }
+      // timestamp_read returns value directly to return_buffer
+      goto end;
+    break;
+    case GPIO_SUSPEND_CONF:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_SUSPEND_CONF\n");
+      if(!kbuf_ext) {
+        pr_err("Parameter error in GPIO_SUSPEND_CONF\n");
+        return -EINVAL;
+      }
+      ret = chip->suspend_configure(chip, kbuf->offset, kbuf_ext->dflags);
+      goto retval;
+    break;
+    case GPIO_ADD_PINRANGES:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_ADD_PINRANGES\n");
+      ret = chip->add_pin_ranges(chip);
+      goto retval;
+    break;
+  };
+
+  /* ioctl signals use flieops because it relises on the standard gpio chardevs
+  static const struct file_operations gpio_fileops = {
+  .release = gpio_chrdev_release,
+  .open = gpio_chrdev_open,
+  .poll = lineinfo_watch_poll,
+  .read = lineinfo_watch_read,
+  .owner = THIS_MODULE,
+  .llseek = no_llseek,
+  .unlocked_ioctl = gpio_ioctl,
+  #ifdef CONFIG_COMPAT
+    .compat_ioctl = gpio_ioctl_compat,
+  #endif
+  };
+  */
+
+  if(kbuf_ext) {
+    switch (kbuf->signal) {
+      /* commands to ioctl below (the std gpio chardev)
+      * not fully implemented
+      * linehandle_create  -- when userspace requests output (called by gpio_ioctl) -- bypasses the chardev
+      * linehandle_ioctl   -- linehandle_ioctl when userspace does actual io (toggles pin)
+      *    cmd:
+      *    GPIOHANDLE_GET_LINE_VALUES_IOCTL,
+      *    GPIOHANDLE_SET_LINE_VALUES_IOCTL,
+      *    GPIOHANDLE_SET_CONFIG_IOCTL
+      *    arg: user input or output
+      */
+
+      // We could want to use the stock gpio chardev (/dev/gpiochip0 and /dev/gpiochip1) /bc userspace functions use it
+      // this code is not yet complete and it mey be better to use the stock devices directly.
+      case GPIO_CHARDEV_OPEN:	// .open = gpio_chrdev_open
+        file = filp_open(tegra_chiplabel[kbuf->chipnum], O_RDWR, 0);
+          if (IS_ERR(file)) {
+            pr_err("GPIO, failed to open chardev for chip %s: %ld", tegra_chiplabel[kbuf->chipnum], PTR_ERR(file));
+            kfree(kbuf);
+            return -ENOENT;
+          }
+        // note: inode and file are static variables
+        inode = file->f_path.dentry->d_inode;
+        // defined as: static int gpio_chrdev_open(struct inode *inode, struct file *file)
+        ret = file->f_op->open(inode, file);
+        goto retval;
+      break;
+      case GPIO_CHARDEV_IOCTL:	// .unlocked_ioctl = gpio_ioctl
+        // user space triggers gpio_ioctl -- it is .unlocked_ioctl on the chardev
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static long gpio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+        ret_l = file->f_op->unlocked_ioctl(file, kbuf->cmd, kbuf_ext->arg);	// arg is pointer data which should have been copied from userspace
+        goto retlong;
+      break;
+      case GPIO_CHARDEV_RELEASE: // .release = gpio_chrdev_release
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static int gpio_chrdev_release(struct inode *inode, struct file *file)
+        ret = file->f_op->release(inode, file);
+        goto retval;
+      break;
+      case GPIO_CHARDEV_POLL: // .poll = lineinfo_watch_poll
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static __poll_t lineinfo_watch_poll(struct file *file, struct poll_table_struct *pollt)
+        ret = file->f_op->poll(file, kbuf_ext->poll);	// TODO arg is pointer data which should have been copied
+        goto retval;	// __poll_t is of size unsigned int
+      break;
+      case GPIO_CHARDEV_READ: // .read = lineinfo_watch_read
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static ssize_t lineinfo_watch_read(struct file *file, char __user *buf, size_t count, loff_t *off)
+        ret = file->f_op->read(file, return_buffer, kbuf_ext->count, NULL);		//
+        if (ret) {
+          pr_err("Reading lineinfo returned zero\n");
+          kfree(kbuf);
+          return -EFAULT;
+        }
+      return -ENXIO;
+      case GPIO_CHARDEV_OWNER: // .owner = THIS_MODULE
+        if (copy_to_user(return_buffer, file->f_op->owner->name, strlen(file->f_op->owner->name)+1)) {
+          pr_err("GPIO, copying user return value failed\n");
+          kfree(kbuf);
+          return -EFAULT;
+        }
+        // ret_sz = strlen(file->f_op->owner->name) + 1;
+        // goto generic_ret
+      break;
+      default:
+        pr_err("GPIO, Illegal proxy signal type\n");
+        kfree(kbuf);
+        return -EPERM;
+      break;
+    };
+  };
+
+	goto end;
+
+	retlong:
+	if ( copy_to_user(return_buffer, &ret_l, sizeof(ret_l)) ) {
+		pr_err("GPIO, copying int user return value failed\n");
+		kfree(kbuf);
+		return -EFAULT;
+	};
+
+	goto end;
+
+	retval:
+	if ( copy_to_user(return_buffer, &ret, sizeof(ret)) ) {
+		pr_err("GPIO, copying long int user return value failed\n");
+		kfree(kbuf);
+		return -EFAULT;
+	};
+
+	goto end;
+
+	end:
+	kfree(kbuf);
+	return len;
+}
diff --git a/drivers/gpio-host-proxy/Kconfig b/drivers/gpio-host-proxy/Kconfig
new file mode 100644
index 0000000..3047dab
--- /dev/null
+++ b/drivers/gpio-host-proxy/Kconfig
@@ -0,0 +1,10 @@
+config TEGRA_GPIO_HOST_PROXY
+	depends on GPIO_TEGRA && GPIO_TEGRA186
+		bool "Tegra GPIO host proxy support"
+		help
+		Exposes the GPIO capabilities __iomem to the user space, in order to support the 
+		GPIO passthrough to virtual machines.
+
+		Say Y here to enable this driver and to compile this driver as a module, 
+		choose M here. If unsure, say N
+
diff --git a/drivers/gpio-host-proxy/Makefile b/drivers/gpio-host-proxy/Makefile
new file mode 100644
index 0000000..c2e0184
--- /dev/null
+++ b/drivers/gpio-host-proxy/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_TEGRA_GPIO_HOST_PROXY) += gpio-host-proxy.o
diff --git a/drivers/gpio-host-proxy/gpio-host-proxy.c b/drivers/gpio-host-proxy/gpio-host-proxy.c
new file mode 100644
index 0000000..361804e
--- /dev/null
+++ b/drivers/gpio-host-proxy/gpio-host-proxy.c
@@ -0,0 +1,645 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/**
+ * NVIDIA GPIO Guest Proxy Kernel Module
+ * (c) 2023 Unikie, Oy
+ * (c) 2023 Kim Sandstrom kim.sandstrom@unikie.com
+ *
+ **/
+#include <linux/module.h>	  // Core header for modules.
+#include <linux/device.h>	  // Supports driver model.
+#include <linux/kernel.h>	  // Kernel header for convenient functions.
+#include <linux/fs.h>		  // File-system support.
+#include <linux/uaccess.h>	  // User access copy function support.
+#include <linux/slab.h>
+//#include <soc/tegra/gpio.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include "../gpio-host-proxy/gpio-host-proxy.h"
+#include <linux/gpio/driver.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/namei.h>
+#include <linux/delay.h>
+
+#define DEVICE_NAME "gpio-host"   // Device name.
+#define CLASS_NAME  "chardrv"	  // < The device class -- this is a character device driver
+
+MODULE_LICENSE("GPL\n");						///< The license type -- this affects available functionality
+MODULE_AUTHOR("Kim SandstrÃ¶m\n");					///< The author -- visible when you use modinfo
+MODULE_DESCRIPTION("NVidia GPIO Host Proxy Kernel Module\n");	///< The description -- see modinfo
+MODULE_VERSION("0.0\n");						///< A version number to inform users
+
+#define GPIO_DEBUG
+#define GPIO_DEBUG_VERBOSE       // also activates deb_verbose commands
+
+#ifdef GPIO_DEBUG
+  #define deb_info(fmt, ...)     printk(KERN_INFO "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, __FILE__, ##__VA_ARGS__)
+  #define deb_debug(fmt, ...)    printk(KERN_DEBUG "GPIO func \'%s\' in file \'%s\' -- " fmt, __func__, __FILE__, ##__VA_ARGS__)
+#else
+  #define deb_info(fmt, ...)
+  #define deb_debug(fmt, ...)
+#endif
+
+#ifdef GPIO_DEBUG_VERBOSE
+  #define deb_verbose           deb_debug
+#else
+  #define deb_verbose(fmt, ...)
+#endif
+
+extern struct gpio_chip *find_chip_by_name(const char *);
+extern struct gpio_chip *find_chip_by_id(int);
+const char *tegra_chiplabel[2] = {TEGRA_GPIO_LABEL,TEGRA_GPIO_AON_LABEL};
+EXPORT_SYMBOL_GPL(tegra_chiplabel);
+
+/**
+ * Important variables that store data and keep track of relevant information.
+ */
+static int major_number;
+
+static struct class *gpio_host_proxy_class = NULL;	///< The device-driver class struct pointer
+static struct device *gpio_host_proxy_device = NULL; ///< The device-driver device struct pointer
+
+/**
+ * Prototype functions for file operations.
+ */
+static int open(struct inode *, struct file *);
+static int close(struct inode *, struct file *);
+static ssize_t read(struct file *, char *, size_t, loff_t *);
+static ssize_t write(struct file *, const char *, size_t, loff_t *);
+
+/**
+ * File operations structure and the functions it points to.
+ */
+static struct file_operations fops =
+	{
+		.owner = THIS_MODULE,
+		.open = open,
+		.release = close,
+		.read = read,
+		.write = write
+	};
+
+// GPIO allowed resources structure
+// static struct gpio_allowed_res gpio_ares;
+
+#ifdef GPIO_DEBUG_VERBOSE
+  // Usage:
+  //   hexDump(devName, desc, addr, len, perLine);
+  //     devName  name of device being debugged, for reference
+  //     desc:    if non-NULL, printed as a description before hex dump.
+  //     addr:    the address to start dumping from.
+  //     len:     the number of bytes to dump.
+  //     perLine: number of bytes on each output line.
+  void hexDump (
+    const char * deviceName,
+    const char * desc,
+    const void * addr,
+    const int len
+  ) {
+    // Silently ignore silly per-line values.
+
+    int i;
+    unsigned char buff[17];
+    unsigned char out_buff[4000];
+    unsigned char *p_out_buff = out_buff;
+    const unsigned char * pc = (const unsigned char *)addr;
+
+
+
+    // Output description if given.
+
+    if (desc != NULL) printk ("%s:\n", desc);
+
+    // Length checks.
+
+    if (len == 0) {
+      printk("%s:   ZERO LENGTH\n", deviceName);
+      return;
+    }
+    if (len < 0) {
+      printk("%s:   NEGATIVE LENGTH: %d\n", deviceName, len);
+      return;
+    }
+
+    if(len > 400){
+      printk("%s:   VERY LONG: %d\n", deviceName, len);
+      return;
+    }
+
+    // Process every byte of hexDump data.
+
+    for (i = 0; i < len; i++) {
+      // Multiple of perLine means new or first line (with line offset).
+
+      if ((i % 16) == 0) {
+        // Only print previous-line ASCII buffer for lines beyond first.
+
+        if (i != 0) {
+          p_out_buff += sprintf (p_out_buff, "  %s\n", buff);
+        }
+        // Output the offset of current line.
+
+        p_out_buff += sprintf (p_out_buff,"  %04x ", i);
+      }
+
+      // Now the hex code for the specific character.
+
+      p_out_buff += sprintf (p_out_buff, " %02x", pc[i]);
+
+      // And buffer a printable ASCII character for later.
+
+      if ((pc[i] < 0x20) || (pc[i] > 0x7e)) // isprint() may be better.
+        buff[i % 16] = '.';
+      else
+        buff[i % 16] = pc[i];
+      buff[(i % 16) + 1] = '\0';
+    }
+
+    // Pad out last line if not exactly perLine characters.
+
+    while ((i % 16) != 0) {
+      p_out_buff += sprintf (p_out_buff, "   ");
+      i++;
+    }
+
+    // And print the final ASCII buffer.
+
+    p_out_buff += sprintf (p_out_buff, "  %s\n", buff);
+
+    printk("%s: %s", deviceName, out_buff);
+  }
+  EXPORT_SYMBOL_GPL(hexDump);
+#else
+  #define hexDump(...)
+#endif
+
+/**
+ * Initializes module at installation
+ */
+static int gpio_host_proxy_probe(struct platform_device *pdev)
+{
+  // int i;
+	deb_info("installing module.\n");
+
+  // *********************
+  // start of TODO clocks and resets -- this commect section is probably not valid
+
+  //	// Read allowed clocks and reset from the device tree
+  //	// if clocks or resets are not defined, not initialize the module
+  //	gpio_ares.clocks_size = of_property_read_variable_u32_array(pdev->dev.of_node,
+  //		"allowed-clocks", gpio_ares.clock, 0, GPIO_HOST_MAX_CLOCKS_SIZE);
+  //
+  //	if(gpio_ares.clocks_size <= 0){
+  //		pr_err("No allowed clocks defined\n");
+  //		return EINVAL;
+  //	}
+  //
+  //	deb_info("gpio_ares.clocks_size: %d", gpio_ares.clocks_size);
+  //	for (i = 0; i < gpio_ares.clocks_size; i++)	{
+  //		deb_info("gpio_ares.clock %d", gpio_ares.clock[i]);
+  //	}
+  //
+  //	gpio_ares.resets_size = of_property_read_variable_u32_array(pdev->dev.of_node,
+  //		"allowed-resets", gpio_ares.reset, 0, GPIO_HOST_MAX_RESETS_SIZE);
+  //
+  //	if(gpio_ares.resets_size <= 0){
+  //		pr_err("No allowed resets defined\n");
+  //		return EINVAL;
+  //	}
+  //
+  //	deb_info("gpio_ares.resets_size: %d", gpio_ares.resets_size);
+  //	for (i = 0; i < gpio_ares.resets_size; i++)	{
+  //		deb_info("gpio_ares.reset %d", gpio_ares.reset[i]);
+  //	}
+  // end of TODO clocks and resets
+  // *********************
+
+	// Allocate a major number for the device.
+	major_number = register_chrdev(0, DEVICE_NAME, &fops);
+	if (major_number < 0)
+	{
+		pr_err("could not register number.\n");
+		return major_number;
+	}
+	deb_info("registered correctly with major number %d", major_number);
+
+	// Register the device class
+	gpio_host_proxy_class = class_create(THIS_MODULE, CLASS_NAME);
+	if (IS_ERR(gpio_host_proxy_class))
+	{ // Check for error and clean up if there is
+		unregister_chrdev(major_number, DEVICE_NAME);
+		pr_err("Failed to register device class\n");
+		return PTR_ERR(gpio_host_proxy_class); // Correct way to return an error on a pointer
+	}
+	deb_info("device class registered correctly\n");
+
+	// Register the device driver
+	gpio_host_proxy_device = device_create(gpio_host_proxy_class, NULL, MKDEV(major_number, 0), NULL, DEVICE_NAME);
+	if (IS_ERR(gpio_host_proxy_device))
+	{ // Clean up if there is an error
+		class_destroy(gpio_host_proxy_class);
+		unregister_chrdev(major_number, DEVICE_NAME);
+		pr_err("Failed to create the device\n");
+		return PTR_ERR(gpio_host_proxy_device);
+	}
+
+	deb_info("device class created correctly\n"); // Made it! device was initialized
+
+	return 0;
+}
+
+/*
+ * Removes module, sends appropriate message to kernel
+ */
+static int gpio_host_proxy_remove(struct platform_device *pdev)
+{
+	deb_info("removing module.\n");
+	device_destroy(gpio_host_proxy_class, MKDEV(major_number, 0)); // remove the device
+	class_unregister(gpio_host_proxy_class);						  // unregister the device class
+	class_destroy(gpio_host_proxy_class);						  // remove the device class
+	unregister_chrdev(major_number, DEVICE_NAME);		  // unregister the major number
+	deb_info("Goodbye from the LKM!\n");
+	unregister_chrdev(major_number, DEVICE_NAME);
+	return 0;
+}
+
+/*
+ * Opens device module, sends appropriate message to kernel
+ */
+static int open(struct inode *inodep, struct file *filep)
+{
+	deb_info("device opened.\n");
+	return 0;
+}
+
+/*
+ * Closes device module, sends appropriate message to kernel
+ */
+static int close(struct inode *inodep, struct file *filep)
+{
+	deb_info("device closed.\n");
+	return 0;
+}
+
+/*
+ * Reads from device, displays in userspace, and deletes the read data
+ */
+static ssize_t read(struct file *filep, char *buffer, size_t len, loff_t *offset)
+{
+	deb_info("read stub\n");
+	return 0;
+}
+
+// TODO
+/*
+ * Checks if the value to transmit through the
+ * gpio-host is allowed by the device tree configuration
+ */
+/*
+static bool check_if_allowed(int val)
+{
+	return false;
+}
+*/
+
+/*
+ * Writes to the device
+ */
+
+static ssize_t write(struct file *filep, const char *buffer, size_t len, loff_t *offset)
+{
+	unsigned int ret;
+	unsigned long int ret_l;
+	struct tegra_gpio_pt *kbuf = NULL;
+	tegra_gpio_pt_extended *kbuf_ext = NULL;
+
+	static struct file *file;
+	static struct inode *inode = NULL;
+	struct gpio_chip *chip;
+  #ifdef GPIO_DEBUG
+	  struct gpio_chip *chip_alt;
+  #endif
+
+	char *return_buffer = (char *)buffer;
+	char *read_buffer = (char *)buffer;
+
+	deb_info("writeing %zu bytes to chardev", len);
+
+  /* removed because condition is covered by susequent checks on 'len'
+	if (len > 65535) {
+		pr_err("count %zu exceeds max # of bytes allowed, aborting write", len);
+		return -EINVAL;
+	} */
+
+  // We allow tegra_gpio_pt alone or with tegra_gpio_pt_extended (verify later)
+	if( len != sizeof(struct tegra_gpio_pt) && len != sizeof(struct tegra_gpio_pt) + sizeof(tegra_gpio_pt_extended) )  {
+		pr_err("Illegal chardev data length. Expected %ld or %ld, got %ld", sizeof(struct tegra_gpio_pt), sizeof(struct tegra_gpio_pt) + sizeof(tegra_gpio_pt_extended), len);
+		return -ENOEXEC;
+	}
+
+  if(!offset) {
+    pr_err("offset pointer is null, ignoring offset\n");
+  }
+  else {
+	  read_buffer += (*offset);
+  }
+
+	kbuf = kmalloc(len, GFP_KERNEL);
+	if ( !kbuf ) {
+	  pr_err("kbuf memory allocation failed\n");
+	  return -ENOMEM;
+	}
+	memset(kbuf, 0, len);
+
+	// Copy header
+  if (copy_from_user(kbuf, read_buffer, sizeof(struct tegra_gpio_pt))) {
+    pr_err("copy_from_user failed\n");
+    kfree(kbuf);
+    return -ENOMEM;
+  }
+  deb_verbose("kbuf is set up, kbuf=%p", kbuf);
+
+  if( len == (sizeof(struct tegra_gpio_pt) + sizeof(tegra_gpio_pt_extended) ) ) {
+    kbuf_ext = (tegra_gpio_pt_extended *)(kbuf + 1);
+    deb_verbose("kbuf_ext is set up kbuf_ext=%p", kbuf_ext);
+  }
+
+	// print copied user parameters
+  hexDump (DEVICE_NAME, "Chardev input", kbuf, len);
+
+  // make gpio-host type call to gpio
+	deb_verbose("enter switch with signal: %c, Chip %d, Offset %d, Level %d", kbuf->signal, kbuf->chipnum, kbuf->offset, kbuf->level);
+
+  switch (kbuf->signal) {
+    case GPIO_REQ:
+      // if(kbuf->chipnum & 0xfe) {    // 0 and 1 are allowed values & mask allows fastcheck, marginal save
+      if(kbuf->chipnum >= MAX_CHIP) {  // direct copmparison is more future flexible
+        // te!, 
+        pr_err("Illegal value for chip number\n");
+        kfree(kbuf);
+        return -ENODEV;
+      }
+      chip = find_chip_by_id(kbuf->chipnum);
+      #ifdef GPIO_DEBUG_VERBOSE
+        chip_alt = find_chip_by_name(tegra_chiplabel[kbuf->chipnum]);
+        if(chip != chip_alt)
+          deb_debug("conflicting chip pointers -- primary %p, alternative %p", chip, chip_alt);
+      #endif
+      if(!chip) {
+        pr_err("In GPIO_REQ, chip pointer's pvalue is unexpectedly NULL for chip %s\n", tegra_chiplabel[kbuf->chipnum]);
+        kfree(kbuf);
+        return -ENODEV;
+      }
+
+      deb_verbose("GPIO_REQ, using GPIO chip %s, for device %d, pvalue = %p", chip->label, kbuf->chipnum, chip);
+      ret = chip->request(chip, kbuf->offset);
+	    goto end;
+    break;
+    case GPIO_FREE:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_FREE\n");
+      chip->free(chip, kbuf->offset);
+      // chip_alt = NULL;
+      goto end;
+    break;
+    case GPIO_GET_DIR:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_GET_DIR\n");
+      ret = chip->get_direction(chip, kbuf->offset);
+      goto retval;
+    break;
+    case GPIO_SET_IN:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_SET_IN\n");
+      ret = chip->direction_input(chip, kbuf->offset);
+      goto retval;
+    break;
+    case GPIO_SET_OUT:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_SET_OUT, chip pvalue 0 %p", chip);
+      ret = chip->direction_output(chip, kbuf->offset, kbuf->level);
+      goto retval;
+    break;
+    case GPIO_GET:
+      deb_verbose("GPIO_GET\n");
+      chip = find_chip_by_id(kbuf->chipnum);
+      ret = chip->get(chip, kbuf->offset);
+      goto retval;
+    break;
+    case GPIO_SET:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_SET, set %d at offset 0x%x in gpiochip %s", kbuf->level, kbuf->offset, chip->label);
+      chip->set(chip, kbuf->offset, kbuf->level);
+	    goto end;
+    break;
+    case GPIO_CONFIG:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_CONFIG\n");
+      chip->set_config(chip, kbuf->offset, kbuf_ext->config); // arg mapped to unsigned long config
+	    goto end;
+    break;
+    case GPIO_TIMESTAMP_CTRL:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_TIMESTAMP_CTRL\n");
+      ret = chip->timestamp_control(chip, kbuf->offset, kbuf->level);	// mapping level onto enable
+      goto retval;
+    break;
+    case GPIO_TIMESTAMP_READ:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_TIMESTAMP_READ\n");
+      ret = chip->timestamp_read(chip, kbuf->offset, (u64 *)return_buffer);	// timestamp is u64, return value as pointer
+      if(ret) {
+        pr_err("GPIO_TIMESTAMP_READ error\n");
+        goto end;
+      }
+      // timestamp_read returns value directly to return_buffer
+      goto end;
+    break;
+    case GPIO_SUSPEND_CONF:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_SUSPEND_CONF\n");
+      if(!kbuf_ext) {
+        pr_err("Parameter error in GPIO_SUSPEND_CONF\n");
+        return -EINVAL;
+      }
+      ret = chip->suspend_configure(chip, kbuf->offset, kbuf_ext->dflags);
+      goto retval;
+    break;
+    case GPIO_ADD_PINRANGES:
+      chip = find_chip_by_id(kbuf->chipnum);
+      deb_verbose("GPIO_ADD_PINRANGES\n");
+      ret = chip->add_pin_ranges(chip);
+      goto retval;
+    break;
+  };
+
+  /* ioctl signals use flieops because it relises on the standard gpio chardevs
+  static const struct file_operations gpio_fileops = {
+  .release = gpio_chrdev_release,
+  .open = gpio_chrdev_open,
+  .poll = lineinfo_watch_poll,
+  .read = lineinfo_watch_read,
+  .owner = THIS_MODULE,
+  .llseek = no_llseek,
+  .unlocked_ioctl = gpio_ioctl,
+  #ifdef CONFIG_COMPAT
+    .compat_ioctl = gpio_ioctl_compat,
+  #endif
+  };
+  */
+
+  if(kbuf_ext) {
+    switch (kbuf->signal) {
+      /* commands to ioctl below (the std gpio chardev)
+      * not fully implemented
+      * linehandle_create  -- when userspace requests output (called by gpio_ioctl) -- bypasses the chardev
+      * linehandle_ioctl   -- linehandle_ioctl when userspace does actual io (toggles pin)
+      *    cmd:
+      *    GPIOHANDLE_GET_LINE_VALUES_IOCTL,
+      *    GPIOHANDLE_SET_LINE_VALUES_IOCTL,
+      *    GPIOHANDLE_SET_CONFIG_IOCTL
+      *    arg: user input or output
+      */
+
+      // We could want to use the stock gpio chardev (/dev/gpiochip0 and /dev/gpiochip1) /bc userspace functions use it
+      // this code is not yet complete and it mey be better to use the stock devices directly.
+      case GPIO_CHARDEV_OPEN:	// .open = gpio_chrdev_open
+        file = filp_open(tegra_chiplabel[kbuf->chipnum], O_RDWR, 0);
+          if (IS_ERR(file)) {
+            pr_err("GPIO, failed to open chardev for chip %s: %ld", tegra_chiplabel[kbuf->chipnum], PTR_ERR(file));
+            kfree(kbuf);
+            return -ENOENT;
+          }
+        // note: inode and file are static variables
+        inode = file->f_path.dentry->d_inode;
+        // defined as: static int gpio_chrdev_open(struct inode *inode, struct file *file)
+        ret = file->f_op->open(inode, file);
+        goto retval;
+      break;
+      case GPIO_CHARDEV_IOCTL:	// .unlocked_ioctl = gpio_ioctl
+        // user space triggers gpio_ioctl -- it is .unlocked_ioctl on the chardev
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static long gpio_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+        ret_l = file->f_op->unlocked_ioctl(file, kbuf->cmd, kbuf_ext->arg);	// arg is pointer data which should have been copied from userspace
+        goto retlong;
+      break;
+      case GPIO_CHARDEV_RELEASE: // .release = gpio_chrdev_release
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static int gpio_chrdev_release(struct inode *inode, struct file *file)
+        ret = file->f_op->release(inode, file);
+        goto retval;
+      break;
+      case GPIO_CHARDEV_POLL: // .poll = lineinfo_watch_poll
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static __poll_t lineinfo_watch_poll(struct file *file, struct poll_table_struct *pollt)
+        ret = file->f_op->poll(file, kbuf_ext->poll);	// TODO arg is pointer data which should have been copied
+        goto retval;	// __poll_t is of size unsigned int
+      break;
+      case GPIO_CHARDEV_READ: // .read = lineinfo_watch_read
+        if( !file ) {
+          pr_err("GPIO, chardev file was expected to be open\n");
+          kfree(kbuf);
+          return -ENOENT;
+        }
+        // defined as: static ssize_t lineinfo_watch_read(struct file *file, char __user *buf, size_t count, loff_t *off)
+        ret = file->f_op->read(file, return_buffer, kbuf_ext->count, NULL);		//
+        if (ret) {
+          pr_err("Reading lineinfo returned zero\n");
+          kfree(kbuf);
+          return -EFAULT;
+        }
+      return -ENXIO;
+      case GPIO_CHARDEV_OWNER: // .owner = THIS_MODULE
+        if (copy_to_user(return_buffer, file->f_op->owner->name, strlen(file->f_op->owner->name)+1)) {
+          pr_err("GPIO, copying user return value failed\n");
+          kfree(kbuf);
+          return -EFAULT;
+        }
+        // ret_sz = strlen(file->f_op->owner->name) + 1;
+        // goto generic_ret
+      break;
+      default:
+        pr_err("GPIO, Illegal proxy signal type\n");
+        kfree(kbuf);
+        return -EPERM;
+      break;
+    };
+  };
+
+	goto end;
+
+	retlong:
+	if ( copy_to_user(return_buffer, &ret_l, sizeof(ret_l)) ) {
+		pr_err("GPIO, copying int user return value failed\n");
+		kfree(kbuf);
+		return -EFAULT;
+	};
+
+	goto end;
+
+	retval:
+	if ( copy_to_user(return_buffer, &ret, sizeof(ret)) ) {
+		pr_err("GPIO, copying long int user return value failed\n");
+		kfree(kbuf);
+		return -EFAULT;
+	};
+
+	goto end;
+
+	end:
+	kfree(kbuf);
+	return len;
+}
+
+/* module creation -- see also gpio_host_proxy_probe and gpio_host_proxy_remove */
+
+static const struct of_device_id gpio_host_proxy_ids[] = {
+	{ .compatible = "nvidia,gpio-host-proxy" },
+	{ }
+};
+
+static struct platform_driver gpio_host_proxy_driver = {
+	.driver = {
+    .name = "gpio_host_proxy",
+    .owner = THIS_MODULE,
+    .of_match_table = gpio_host_proxy_ids,
+	},
+	.probe = gpio_host_proxy_probe,
+	.remove = gpio_host_proxy_remove,
+};
+// builtin_platform_driver(gpio_host_proxy_driver);
+
+static int __init gpio_host_proxy_init(void)
+{
+    int ret = 0;
+
+    ret = platform_driver_register(&gpio_host_proxy_driver);
+    if (ret != 0) {
+        pr_err("GPIO, Error %d registering gpio host proxy driver", ret);
+    } else {
+        deb_info("GPIO gpio host proxy driver registered successfully\n");
+    }
+
+    return ret;
+}
+
+static void __exit gpio_host_proxy_exit(void)
+{
+    platform_driver_unregister(&gpio_host_proxy_driver);
+    deb_info("GPIO gpio host proxy driver unregistered\n");
+}
+
+module_init(gpio_host_proxy_init);
+module_exit(gpio_host_proxy_exit);
diff --git a/drivers/gpio-host-proxy/gpio-host-proxy.h b/drivers/gpio-host-proxy/gpio-host-proxy.h
new file mode 100644
index 0000000..b714531
--- /dev/null
+++ b/drivers/gpio-host-proxy/gpio-host-proxy.h
@@ -0,0 +1,79 @@
+#ifndef __GPIO_HOST_PROXY__H__
+#define __GPIO_HOST_PROXY__H__
+
+#include <linux/types.h>  // For __iomem definition
+#include <linux/io.h>	// For functions related to I/O operations
+#include <stddef.h>
+#include <linux/gpio/consumer.h>	// for gpiod_flags
+
+// as a workaround this struct is copied here from drivers/gpio/gpiolib.h
+// including the original header file does not work becaue proxy drivers are overlay and absolute paths will change
+// this copied struct is incomplete and subset of the "real" one
+struct gpio_device {
+	int			id;
+	struct device		dev;
+  // a huge number of members are removed here -- do not sizeof this struct !!!
+};
+
+
+/* values to be used as "signal" values in struct tegra_gpio_pt */
+#define GPIO_CHARDEV_OPEN    '1'   // .open = gpio_chrdev_open
+#define GPIO_CHARDEV_IOCTL   '2'   // .unlocked_ioctl = gpio_ioctl -- handles IO operation, get linehandle, set direction
+#define GPIO_CHARDEV_POLL    '3'   // .poll = lineinfo_watch_poll
+#define GPIO_CHARDEV_READ    '4'   // .read = lineinfo_watch_read
+#define GPIO_CHARDEV_OWNER   '5'   // .owner = THIS_MODULE
+#define GPIO_CHARDEV_SEEK    '6'   // .llseek = no_llseek
+#define GPIO_CHARDEV_RELEASE '7'   // .release = gpio_chrdev_release
+
+#define GPIO_SET             's'   // set level
+#define GPIO_GET             'g'   // get level
+#define GPIO_GET_DIR         'd'   // get direction
+#define GPIO_SET_IN          'i'   // set direction to input
+#define GPIO_SET_OUT         'o'   // set direction to output
+#define GPIO_CONFIG          'c'   // set config
+#define GPIO_SET_BY_NAME     'n'   // set config
+
+#define GPIO_REQ             'r'   // generic request
+#define GPIO_FREE            'f'   // free
+
+#define GPIO_TIMESTAMP_CTRL  'C'   // timestamp control
+#define GPIO_TIMESTAMP_READ  'R'   // timestamp read
+#define GPIO_SUSPEND_CONF    'S'   // suspend configure
+#define GPIO_ADD_PINRANGES   'P'   // add_pin_ranges
+
+// helpers to identify chip
+#define TEGRA_GPIO_CHIP       0    // tegra-gpio gpio_main_chip
+#define TEGRA_GPIO_AON_CHIP   1    // tegra-gpio-aon gpio_aon_chip
+#define TEGRA_GPIO_LABEL      "tegra234-gpio\x00\x00\x00\x00\x00\x00\x00"  // gpio_main_chip / gpiochip0 --padded to 20 bytes
+#define TEGRA_GPIO_AON_LABEL  "tegra234-gpio-aon\x00\x00\x00"              // gpio_aon_chip  / gpiochip1 --padded to 20 bytes
+#define LABEL_SIZE            20
+
+// struct __attribute__((packed)) tegra_gpio_pt {
+struct tegra_gpio_pt {
+  unsigned char signal;       // defines operation
+  unsigned char chipnum;      // number of gpio chip (gpiochip0 or gpiochip1)
+  unsigned char level;        // padding to reach 8 byte word alignment
+  unsigned char offset;       // address offset for gpio pin
+  u32 cmd;                    // gpio_ioctl command
+  // tegra_gpio_pt_extended p2;          // extended parameters -- in second word of struct
+};
+
+typedef union extended {
+  // int level;                // pin level to be set
+  unsigned long config;     // pin configuration
+  int enable;
+  size_t count;             // lineinfo read size
+  struct poll_table_struct *poll;
+  enum gpiod_flags dflags ;
+  u64 arg;                  // gpio_ioctl argument (this is interpreted as a pointer)
+} tegra_gpio_pt_extended;
+
+#define MAX_CHIP 2
+
+_Static_assert( sizeof(struct tegra_gpio_pt) == 8,
+               "tegra_gpio_pt size is not 8 bytes." );
+
+_Static_assert( sizeof(tegra_gpio_pt_extended) == 8,
+               "tegra_gpio_pt_extended size is not 8 bytes." );
+
+#endif
