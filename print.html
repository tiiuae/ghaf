<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ghaf Framework</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Documentation for TII SSRC Secure Technologies.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><li class="part-title">Overview</li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> About Ghaf</a></li><li class="chapter-item expanded "><a href="features/features.html"><strong aria-hidden="true">2.</strong> Features</a></li><li class="chapter-item expanded "><a href="architecture/architecture.html"><strong aria-hidden="true">3.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/variants.html"><strong aria-hidden="true">3.1.</strong> Architectural Variants</a></li><li class="chapter-item expanded "><a href="architecture/adr.html"><strong aria-hidden="true">3.2.</strong> Architecture Decision Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/adr/minimal-host.html"><strong aria-hidden="true">3.2.1.</strong> Minimal Host</a></li><li class="chapter-item expanded "><a href="architecture/adr/netvm.html"><strong aria-hidden="true">3.2.2.</strong> Networking VM</a></li><li class="chapter-item expanded "><a href="architecture/adr/platform-bus-passthrough-support.html"><strong aria-hidden="true">3.2.3.</strong> Platform Bus for Rust VMM</a></li></ol></li><li class="chapter-item expanded "><a href="architecture/hardening.html"><strong aria-hidden="true">3.3.</strong> Hardening</a></li><li class="chapter-item expanded "><a href="architecture/secureboot.html"><strong aria-hidden="true">3.4.</strong> Secure Boot</a></li><li class="chapter-item expanded "><a href="architecture/stack.html"><strong aria-hidden="true">3.5.</strong> Stack</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">For Developers</li><li class="chapter-item expanded "><a href="appendices/contributing_general.html"><strong aria-hidden="true">4.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="ref_impl/reference_implementations.html"><strong aria-hidden="true">5.</strong> Reference Implementations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ref_impl/development.html"><strong aria-hidden="true">5.1.</strong> Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ref_impl/build_and_run.html"><strong aria-hidden="true">5.1.1.</strong> Build and Run</a></li><li class="chapter-item expanded "><a href="ref_impl/remote_build_setup.html"><strong aria-hidden="true">5.1.2.</strong> Running Remote Build on NixOS</a></li><li class="chapter-item expanded "><a href="ref_impl/installer.html"><strong aria-hidden="true">5.1.3.</strong> Installer</a></li><li class="chapter-item expanded "><a href="ref_impl/cross_compilation.html"><strong aria-hidden="true">5.1.4.</strong> Cross-Compilation</a></li><li class="chapter-item expanded "><a href="ref_impl/creating_appvm.html"><strong aria-hidden="true">5.1.5.</strong> Creating Application VM</a></li><li class="chapter-item expanded "><a href="ref_impl/labwc.html"><strong aria-hidden="true">5.1.6.</strong> labWC Desktop Environment</a></li></ol></li><li class="chapter-item expanded "><a href="ref_impl/ghaf-based-project.html"><strong aria-hidden="true">5.2.</strong> Ghaf as Library: Templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ref_impl/example_project.html"><strong aria-hidden="true">5.2.1.</strong> Example Project</a></li><li class="chapter-item expanded "><a href="ref_impl/modules_options.html"><strong aria-hidden="true">5.2.2.</strong> Modules Options</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="technologies/technologies.html"><strong aria-hidden="true">6.</strong> Technologies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="technologies/compartment.html"><strong aria-hidden="true">6.1.</strong> Compartmentalization</a></li><li class="chapter-item expanded "><a href="technologies/passthrough.html"><strong aria-hidden="true">6.2.</strong> Passthrough</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="technologies/vfio.html"><strong aria-hidden="true">6.2.1.</strong> Binding Device to VFIO Driver</a></li><li class="chapter-item expanded "><a href="technologies/nvidia_agx_pt_uart.html"><strong aria-hidden="true">6.2.2.</strong> NVIDIA Jetson AGX Orin: UART Passthrough</a></li><li class="chapter-item expanded "><a href="technologies/nvidia_agx_pt_pcie.html"><strong aria-hidden="true">6.2.3.</strong> NVIDIA Jetson AGX Orin: PCIe Passthrough</a></li><li class="chapter-item expanded "><a href="technologies/x86_pcie_crosvm.html"><strong aria-hidden="true">6.2.4.</strong> Generic x86: PCIe Passthrough on crosvm</a></li><li class="chapter-item expanded "><a href="technologies/nvidia_uarti_net_vm.html"><strong aria-hidden="true">6.2.5.</strong> NVIDIA Jetson: UARTI Passthrough to netvm</a></li><li class="chapter-item expanded "><a href="technologies/device_tree_overlays_pt.html"><strong aria-hidden="true">6.2.6.</strong> Device Tree Overlays for Passthrough</a></li></ol></li><li class="chapter-item expanded "><a href="technologies/nvidia_virtualization_bpmp.html"><strong aria-hidden="true">6.3.</strong> Platform Bus Virtualization: NVIDIA BPMP</a></li><li class="chapter-item expanded "><a href="technologies/hypervisor_options.html"><strong aria-hidden="true">6.4.</strong> Hypervisor Options</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Build System and Supply Chain</li><li class="chapter-item expanded "><a href="scs/ci-cd-system.html"><strong aria-hidden="true">7.</strong> Continuous Integration and Distribution</a></li><li class="chapter-item expanded "><a href="scs/scs.html"><strong aria-hidden="true">8.</strong> Supply Chain Security</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scs/slsa-framework.html"><strong aria-hidden="true">8.1.</strong> SLSA Framework</a></li><li class="chapter-item expanded "><a href="scs/basics.html"><strong aria-hidden="true">8.2.</strong> Basic Security Measures</a></li><li class="chapter-item expanded "><a href="scs/sbom.html"><strong aria-hidden="true">8.3.</strong> Software Bill of Materials</a></li><li class="chapter-item expanded "><a href="scs/pki.html"><strong aria-hidden="true">8.4.</strong> Public Key Infrastructure</a></li><li class="chapter-item expanded "><a href="scs/ghaf-security-fix-automation.html"><strong aria-hidden="true">8.5.</strong> Security Fix Automation</a></li></ol></li><li class="chapter-item expanded "><a href="release_notes/release_notes.html"><strong aria-hidden="true">9.</strong> Release Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="release_notes/ghaf-24.03.html"><strong aria-hidden="true">9.1.</strong> Release ghaf-24.03</a></li><li class="chapter-item expanded "><a href="release_notes/ghaf-23.12.html"><strong aria-hidden="true">9.2.</strong> Release ghaf-23.12</a></li><li class="chapter-item expanded "><a href="release_notes/ghaf-23.09.html"><strong aria-hidden="true">9.3.</strong> Release ghaf-23.09</a></li><li class="chapter-item expanded "><a href="release_notes/ghaf-23.06.html"><strong aria-hidden="true">9.4.</strong> Release ghaf-23.06</a></li><li class="chapter-item expanded "><a href="release_notes/ghaf-23.05.html"><strong aria-hidden="true">9.5.</strong> Release ghaf-23.05</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Ghaf Usage Scenarios</li><li class="chapter-item expanded "><a href="scenarios/showcases.html"><strong aria-hidden="true">10.</strong> Showcases</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scenarios/run_win_vm.html"><strong aria-hidden="true">10.1.</strong> Running Windows VM on Ghaf</a></li><li class="chapter-item expanded "><a href="scenarios/run_cuttlefish.html"><strong aria-hidden="true">10.2.</strong> Running Cuttlefish on Ghaf</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Build Your Environment</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="appendices/glossary.html"><strong aria-hidden="true">12.</strong> Glossary</a></li><li class="chapter-item expanded "><a href="research/research.html"><strong aria-hidden="true">13.</strong> Research Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="research/passthrough/ethernet.html"><strong aria-hidden="true">13.1.</strong> i.MX 8QM Ethernet Passthrough</a></li><li class="chapter-item expanded "><a href="research/installation.html"><strong aria-hidden="true">13.2.</strong> System Installation</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ghaf Framework</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tiiuae/ghaf" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="about-ghaf"><a class="header" href="#about-ghaf">About Ghaf</a></h1>
<p><em><a href="./appendices/glossary.html#ghaf">Ghaf Framework</a></em> is an open-source project that provides information about our work and studies in the security technologies field in the context of embedded virtualization.</p>
<p>The applied software research supports <em><a href="./appendices/glossary.html#ssrc">Secure Systems Research Center</a> (SSRC)</em> focus areas.</p>
<p><em>Ghaf Framework</em> can be used to build the <em>Ghaf Platform</em> that will provide an edge device software architecture with key features such as modularity and scalability through virtualization, support research and development of zero trust architecture (ZTA), and allow for low maintenance efforts while keeping the main code base stable and secure. The SSRC team focus is to research on enhancing ZTA to scale horizontally across edge HW platforms (phones, drones, laptops, communication modules) and vertically across SW platforms (Linux, Android, Browser, applications).</p>
<p>The Ghaf Platform is a baseline software platform for edge devices, utilizing a virtualized architecture for research and product development aiming to achieve the following core objectives: apply the general security principles of zero trust within the software architecture, and act as an enabler for ZTAs within organizations.</p>
<p><img src="./img/ghaf_platform_infrastructure.png" alt="Ghaf Platform Infrastructure" title="Typical devices and infrastructure around the Ghaf Platform" /></p>
<h2 id="embedded-virtualization"><a class="header" href="#embedded-virtualization">Embedded Virtualization</a></h2>
<p>Virtualization is one of the core enablers to transform the traditionally monolithic software stack within edge devices into isolated components with minimal TCB and clearly defined functionality.</p>
<p>The Ghaf Platform utilizes a collection of virtual machines (VMs) to define a system.</p>
<p>Contrary to the traditional monolithic OS, this concept allows to define and run host services in isolated environments, which breaks up the monolithic structure and allows for a modular system definition that is customizable for a specific use case. To this end, various applications and guest OSs can be deployed while simultaneously utilizing the Platform's features.</p>
<h2 id="ghaf-platform-applications"><a class="header" href="#ghaf-platform-applications">Ghaf Platform Applications</a></h2>
<p>The Ghaf Platform development is focused on the transition to a modular architecture for edge devices. Products such as secure phones, drones, laptops, and other communication devices have unique challenges in their respective hardware and software ecosystems.</p>
<p>Enabling the integration of individual technology stacks into an organizational framework can be a challenging task. The Ghaf Platform is designed to ease this process and enable research to overcome a number of challenges.</p>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<p>The design principles influencing the architecture of the Ghaf Platform are the following:</p>
<ul>
<li>
<p>Edge security</p>
<p>The Ghaf security architecture under development by SSRC aims to provide an understandable yet comprehensive view of security controls in the Platform so that vendors can make informed decisions and adopt the Platform for their use cases. The security architecture and subsequent research will be published by SSRC in a series of technical white papers.</p>
</li>
<li>
<p>Zero trust</p>
<p>The Ghaf Platform aims to apply the general security principles of zero trust within the software architecture and to act as an enabler for ZTA for edge devices within organizations.</p>
</li>
<li>
<p>Trusted computing base</p>
<p>The general principle for establishing the trusted Ghaf Platform code base is to rely on audited software and proven security modules while carefully evaluating and integrating new concepts. The modularized platform not only simplifies the integration of additional security measures but also facilitates the integration of hardware security features. Leveraging and contributing to open-source projects is not only a cornerstone for the Platform components' maintainability but also for the toolchain to increase transparency and auditability. By providing a hardened code base for the hypervisor and OS for the various VMs in the architecture, the Ghaf Platform leverages security benefits across all modules.</p>
</li>
<li>
<p>Configurable, declarative and reproducible</p>
</li>
</ul>
<h2 id="build-system-and-supply-chain"><a class="header" href="#build-system-and-supply-chain">Build System and Supply Chain</a></h2>
<p>As software supply chain security becomes more and more relevant to product security, it is necessary to provide mechanisms to assert reproducible builds, with a transparent chain from source code over the build environment to the final binaries. Such a system allows faster analysis of not only software bugs but also security vulnerabilities and their impact on a product without the need for extensive analysis. This approach further reduces the efforts required for patching and allows mechanisms for safe fallbacks to secure states.</p>
<p>For more information on Ghaf supply chain security, see <a href="./scs/scs.html">Supply Chain Security</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>The vision for the Ghaf platform is to create a virtualized, scalable reference platform that enables the building of secure products leveraging trusted, reusable, and portable software for edge devices. For more information on reference implementation for several devices, see <a href="features/../ref_impl/reference_implementations.html">Reference Implementations</a>.</p>
<p>Ghaf demo desktop and applications are illustrated in the screen capture below:
<img src="features/../img/ghaf_demo_desktop.png" alt="Ghaf demo desktop and application" /></p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<ul>
<li>‚úÖ‚Äîintegrated and tested in the <code>main</code> branch. No known regression.</li>
<li>üöß‚Äîprototyped or work in progress in the development branch.</li>
<li>‚ùå‚Äîthe feature has known regression or bugs.</li>
</ul>
<h3 id="reference-devices"><a class="header" href="#reference-devices">Reference Devices</a></h3>
<ul>
<li><code>Orin</code>‚ÄîNVIDIA Jetson AGX Orin as the main reference device.</li>
<li><code>x86</code>‚Äîgeneric x86_64; tested on Intel NUC (Next Unit of Computing) or laptop.</li>
<li><code>Lenovo X1</code>‚ÄîLenovo X1 Carbon Gen 11 laptop.</li>
<li><code>aarch64</code>‚Äîgeneric AArch64; tested on an ARM server, laptop (e.g. Apple MacBook's), or NVIDIA Jetson AGX Orin.</li>
<li><code>All variants</code>‚Äîsupported devices from <a href="https://tiiuae.github.io/ghaf/architecture/variants.html">Architectural Variants</a>.</li>
</ul>
<p>The following tables show the status of Ghaf Platform features:</p>
<h2 id="release-builds-and-hardware-architecture-support"><a class="header" href="#release-builds-and-hardware-architecture-support">Release Builds and Hardware Architecture Support</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Reference Device</th><th>Details</th></tr></thead><tbody>
<tr><td>Ghaf in virtual machine</td><td>‚úÖ</td><td><code>x86</code></td><td><code>nix run .#packages.x86_64-linux.vm-debug</code></td></tr>
<tr><td><code>aarch64</code> reference image</td><td>‚úÖ</td><td><code>Orin</code></td><td>Based on <a href="https://developer.nvidia.com/embedded/jetson-linux">Jetson Linux</a>, <a href="https://github.com/OE4T">OE4T</a> and <a href="https://github.com/anduril/jetpack-nixos">jetpack-nixos</a>.</td></tr>
<tr><td><code>aarch64</code> reference image</td><td>‚úÖ</td><td><code>imx8qm</code></td><td>Based on NXP BSP, implemented as <a href="https://github.com/NixOS/nixos-hardware/tree/master/nxp">nixos-hardware module</a></td></tr>
<tr><td><code>x86</code> generic image</td><td>‚úÖ</td><td><code>x86</code></td><td>Generic x86 computer, based on generic <a href="https://nixos.org/">NixOS</a>. NOTE: requires device specific configuration.</td></tr>
<tr><td><code>Lenovo X1</code> reference image</td><td>‚úÖ</td><td><code>Lenovo X1</code></td><td>x86_64 laptop computer, supports basic compartmentalized environment</td></tr>
<tr><td>Native build</td><td>‚úÖ</td><td><code>aarch64, x86</code></td><td>Remote <code>aarc64</code> nixos builders recommended</td></tr>
<tr><td>Cross-compilation</td><td>üöß</td><td><code>aarch64, riscv64</code></td><td>Depends on NixOS <code>nixpkgs 23.05</code> support for cross-compilation</td></tr>
<tr><td>CI builds</td><td>‚úÖ</td><td><code>All</code></td><td><a href="https://vedenemo.dev/">Only <code>main</code>-branch, not for all PRs</a>.</td></tr>
<tr><td>Emulated build</td><td>‚ùå</td><td><code>aarch64</code></td><td><code>binfmt</code>, may freeze the build machine. Not recommended. <a href="https://tiiuae.github.io/ghaf/ref_impl/cross_compilation.html#binfmt">See instructions.</a></td></tr>
</tbody></table>
</div>
<h2 id="development"><a class="header" href="#development">Development</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Reference Device</th><th>Details</th></tr></thead><tbody>
<tr><td>Quick target update</td><td>‚úÖ</td><td><code>all</code></td><td><code>nixos-rebuild --flake .#nvidia-jetson-orin-debug --target-host root@ghaf-host --fast switch</code></td></tr>
<tr><td><code>aarch64</code> device flashing</td><td>‚úÖ</td><td><code>Orin</code></td><td><a href="https://tiiuae.github.io/ghaf/ref_impl/build_and_run.html#flashing-nvidia-jetson-orin-agx">Full device software flashing using <code>x86</code> machine</a></td></tr>
<tr><td>root filesystem flashing</td><td>‚úÖ</td><td><code>x86, imx8qm</code></td><td><code>dd</code> image to bootable media - <a href="https://tiiuae.github.io/ghaf/ref_impl/build_and_run.html#running-ghaf-image-for-x86-computer">see</a></td></tr>
<tr><td>Debug: SSH</td><td>‚úÖ</td><td><code>Orin</code>, <code>x86</code></td><td>Host access only in <code>-debug</code>-target, see <a href="https://github.com/tiiuae/ghaf/blob/main/modules/development/authentication.nix">authentication.nix</a></td></tr>
<tr><td>Debug: Serial</td><td>‚úÖ</td><td><code>all</code></td><td>Host access only in <code>-debug</code>-target - e.g. <code>screen /dev/ttyACM0 115200</code></td></tr>
<tr><td>Compartmentalized environment</td><td>üöß</td><td><code>Lenovo X1</code></td><td>NetVM, GUI VM (with GPU passthrough) plus some Application VMs</td></tr>
</tbody></table>
</div>
<h2 id="target-architecture"><a class="header" href="#target-architecture">Target Architecture</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Reference Device</th><th>Details</th></tr></thead><tbody>
<tr><td><code>minimal host</code></td><td>üöß</td><td><a href="https://tiiuae.github.io/ghaf/architecture/variants.html"><code>all</code></a></td><td>See <a href="https://tiiuae.github.io/ghaf/architecture/adr/minimal-host.html">Minimal Host</a> and <a href="https://github.com/tiiuae/ghaf/pull/140">PR #140</a>.</td></tr>
<tr><td><code>netvm</code></td><td>‚úÖ</td><td><code>Orin</code></td><td>See <a href="https://tiiuae.github.io/ghaf/architecture/adr/netvm.html">netvm</a>. Passthrough with Wifi works but requires SSID/password configuration</td></tr>
<tr><td><code>idsvm</code></td><td>‚úÖ</td><td><code>Orin</code></td><td><a href="https://github.com/tiiuae/ghaf/pull/146">Defensive security VM placeholder PR open</a></td></tr>
<tr><td><code>guivm</code></td><td>üöß</td><td><code>All</code>, <code>Lenovo X1</code></td><td>Implemented for Lenovo X1 reference device, other devices have Wayland compositor running on the host.</td></tr>
<tr><td><code>appvm</code></td><td>üöß</td><td><code>All</code>, <code>Lenovo X1</code></td><td>Implemented for Lenovo X1 reference device: chromium, GALA and zathura VMs. Requires <code>guivm</code> in place</td></tr>
<tr><td><code>adminvm</code></td><td>‚úÖ</td><td><code>All</code></td><td>Not started</td></tr>
<tr><td>Inter VM comms - IP-based</td><td>üöß</td><td><code>All</code></td><td><code>-debug</code>-targets have network bridges to access VMs from host</td></tr>
<tr><td>Inter VM comms - shared memory</td><td>üöß</td><td><code>All</code></td><td></td></tr>
<tr><td>Inter VM Wayland</td><td>üöß</td><td><code>All</code></td><td>Currently it is <code>waypipe</code> over SSH, for test and demo purpose only</td></tr>
<tr><td>SW update</td><td>üöß</td><td><code>All</code></td><td>A/B update tooling being evaluated</td></tr>
<tr><td>USB passthrough</td><td>üöß</td><td><code>Orin</code></td><td>No reference implementation integrated yet</td></tr>
<tr><td>PCI passthrough</td><td>‚úÖ</td><td><code>All</code></td><td>Used for reference in <code>netvm</code> on <code>Orin</code></td></tr>
<tr><td>UART passthrough</td><td>üöß</td><td><code>Orin</code></td><td>See <a href="https://tiiuae.github.io/ghaf/build_config/passthrough/nvidia_agx_pt_uart.html">NVIDIA Jetson AGX Orin: UART Passthrough</a>. Not integrated to any VM.</td></tr>
<tr><td>ARM platform bus devices passthrough</td><td>üöß</td><td><code>Orin</code></td><td>NVIDIA BPMP virtualization being developed</td></tr>
</tbody></table>
</div>
<h2 id="applications-and-vm-control"><a class="header" href="#applications-and-vm-control">Applications and VM Control</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Reference Device</th><th>Details</th></tr></thead><tbody>
<tr><td>Wayland-compositor</td><td>üöß</td><td><code>Orin</code>, <code>x86</code></td><td>Implemented for <code>Lenovo X1</code></td></tr>
<tr><td>Chromium</td><td>üöß</td><td><code>Orin</code>, <code>x86</code></td><td>Implemented for <code>Lenovo X1</code></td></tr>
<tr><td>Element</td><td>üöß</td><td><code>Orin</code>, <code>x86</code></td><td>On host</td></tr>
<tr><td>Cloud Android (CVD) client application (GALA)</td><td>üöß</td><td><code>Orin</code>, <code>x86</code></td><td>Implemented for <code>Lenovo X1</code></td></tr>
<tr><td>Virtualization control</td><td>üöß</td><td><a href="https://tiiuae.github.io/ghaf/architecture/variants.html"><code>All</code></a></td><td>See <a href="https://github.com/tiiuae/vmd/blob/main/doc/design.md">vmd design</a>.</td></tr>
</tbody></table>
</div>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p><a href="https://github.com/tiiuae/ghaf/issues/150#issuecomment-1564061850">See discussion for the outline of next steps</a></p>
<p><img src="https://user-images.githubusercontent.com/1027150/241167552-bcb3a3f9-72f3-4b96-af8b-e9df6d1f3d5e.png" alt="Outline of next phases" /></p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The main architectural concept of the Ghaf Platform is to break up the traditional monolithic structure to modularized components, virtual machines (VM). These VMs on hardened host OS implement the Ghaf edge virtualization platform.</p>
<p>Embedded virtualization builds on cloud technologies in the development of end-to-end security. With hardware support for virtualization, we provide a hardened system of a small trusted computing base (TCB)‚Äîthin host‚Äîthat enables isolation of use cases and their resources. Use cases are protected in guest virtual machines (VMs). Embedded targets are small devices (personal or headless) instead of high-performance cloud servers. Our scope is illustrated in the following diagram. For more information, see <a href="architecture/architecture/stack.html">stack</a>.</p>
<p><img src="architecture/./../img/stack.drawio.png" alt="Scope!" title="Embedded Virtualization Scope" /></p>
<p>If you are interested in why we do something <em>this</em> way instead of <em>that</em> way, see <a href="architecture/adr.html">Architecture Decision Records</a>.</p>
<p>The Ghaf Platform components are used in reference configurations to build images for reference devices. For more information, see <a href="architecture/../ref_impl/reference_implementations.html">Reference Implementations</a>.</p>
<h2 id="in-this-chapter"><a class="header" href="#in-this-chapter">In This Chapter</a></h2>
<ul>
<li><a href="architecture/./variants.html">Architectural Variants</a></li>
<li><a href="architecture/./adr.html">Architecture Decision Records</a>
<ul>
<li><a href="architecture/./adr/minimal-host.html">Minimal Host</a></li>
<li><a href="architecture/./adr/netvm.html">Networking VM</a></li>
<li><a href="architecture/./adr/platform-bus-passthrough-support.html">Platform Bus for Rust VMM</a></li>
</ul>
</li>
<li><a href="architecture/./stack.html">Stack</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="architectural-variants"><a class="header" href="#architectural-variants">Architectural Variants</a></h1>
<p>The main scope of the Ghaf platform is edge virtualization. However, to support modular development and testing of the platform, variants are supported with the following definitions:</p>
<ul>
<li>
<p><code>Default</code><br />
A default variant. Supports <a href="architecture/./adr/minimal-host.html">minimal host</a>, GUI VM[^note] and <a href="architecture/./adr/netvm.html">netvm</a>. May host other VMs. For more information, see <a href="architecture/./stack.html">Stack</a>.</p>
</li>
<li>
<p><code>Headless</code><br />
A variant with <a href="architecture/./adr/minimal-host.html">minimal host</a> and <a href="architecture/./adr/netvm.html">netvm</a>. May host other VMs but does not have GUI VM or graphics stack on a host.</p>
</li>
<li>
<p><code>Host only</code>
A variant with <a href="architecture/./adr/minimal-host.html">minimal host</a> <em>only</em>. A user can manually install software to a host, including VMs (if supported by hardware).</p>
</li>
<li>
<p><code>No virtualization</code>
A variant for hardware with no support for virtualization. May run any software, similar to popular Linux distributions, but cannot support guest virtual machines. May host any software deployed directly on a host.</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Variant Name</th><th>Headless</th><th>Graphics</th><th>VMs</th><th>Devices</th></tr></thead><tbody>
<tr><td><code>Default</code></td><td>No</td><td>GUI VM [^note]</td><td>Supported</td><td>Jetson, generic x86</td></tr>
<tr><td><code>Headless</code></td><td>Yes</td><td>No</td><td>Supported</td><td>Jetson, generic x86</td></tr>
<tr><td><code>Host Only</code></td><td>Yes</td><td>No</td><td>May be supported but not included</td><td>Jetson, generic x86</td></tr>
<tr><td><code>No Virtualization</code></td><td>Yes or no</td><td>Native on host</td><td>Not supported</td><td>Raspberry Pi, RISC-V</td></tr>
</tbody></table>
</div>
<p>[^note] As of early 2023, the graphics stack is deployed on a host to support application development. Work is ongoing to define the GUI VM and isolate graphics with GPU passthrough.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="architecture-decision-records"><a class="header" href="#architecture-decision-records">Architecture Decision Records</a></h1>
<p>Architecturally significant decisions are recorded as <a href="https://adr.github.io">architecture decision records (ADR)</a>.</p>
<p>The Ghaf platform decision log:</p>
<div class="table-wrapper"><table><thead><tr><th>Decision Record</th><th>Status</th></tr></thead><tbody>
<tr><td><a href="architecture/../architecture/adr/minimal-host.html">Minimal Host</a></td><td>Proposed.</td></tr>
<tr><td><a href="architecture/../architecture/adr/netvm.html">netvm‚ÄîNetworking Virtual Machine</a></td><td>Proposed, partially implemented for development and testing.</td></tr>
<tr><td><a href="architecture/../architecture/adr/platform-bus-passthrough-support.html">Platform Bus for RustVMM</a></td><td>Proposed, WIP.</td></tr>
</tbody></table>
</div>
<p>To create an architectural decision proposal, open <a href="https://github.com/tiiuae/ghaf/blob/main/CONTRIBUTING.md#contributing-documentation">a pull request</a> and use the <a href="https://github.com/tiiuae/ghaf/blob/main/docs/src/architecture/adr/template.md">decision record template</a>. Contributions to the Ghaf architecture decisions are welcome.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="minimal-host"><a class="header" href="#minimal-host">Minimal Host</a></h1>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<p>Proposed.</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>Ghaf uses the default NixOS configuration as a baseline to build the target image.</p>
<p>The default NixOS configuration is targeted for more general use with the inclusion of multiple packages that are not supporting the Ghaf design target of a minimal TCB to protect the host. Depending on the flexibility of the NixOS configuration, Ghaf minimal host may require new development to support the requirements.</p>
<p>This structure in the Ghaf host configuration imports the NixOS minimal profile which suits the minimal TCB better. Even better, the modular declarative profile enables the further optimization of the minimal TCB while supporting other profiles that suit the evaluation of other objectives such as feasibility studies of additional functionality,
security and performance.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>Following table describes the development requirements of minimal host. All requirements originate from TII SSRC unless otherwise noted. Scope further defines:</p>
<ul>
<li>target configuration: <code>R</code> for release, <code>D</code> for debug</li>
<li><a href="https://tiiuae.github.io/ghaf/architecture/variants.html">architectural variant</a>: <code>V</code> for
virtualization supporting variant, <code>A</code> for all, including <code>No Virtualization</code></li>
</ul>
<p>Compliance states the progress of requirement compliance as follows:</p>
<ul>
<li><code>D</code> for Designed, design requirement from TII SSRC for analysis and evaluation.</li>
<li><code>I</code> for Implemented, design requirement met with possible, limitations documented
under <a href="architecture/adr/minimal-host.html#consequences">Consequences</a>.</li>
<li><code>P</code> for Proposed, raised for discussion but not yet designed.</li>
<li><code>M</code> for Met, the requirement is reviewed and approved at <a href="https://en.wikipedia.org/wiki/Technology_readiness_level">technology readiness level 4</a>.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Requirement</th><th>Description</th><th>Scope</th><th>Compliance</th></tr></thead><tbody>
<tr><td>MH01</td><td>Defined in <code>nix</code></td><td>Host declaration in <code>nix</code></td><td><code>R&amp;D</code>,<code>A</code></td><td><code>I</code></td></tr>
<tr><td>MH02</td><td>Reduced profile</td><td>Remove unnecessary</td><td><code>R</code>, <code>V</code></td><td><code>I</code></td></tr>
<tr><td>MH03</td><td>No networking</td><td>Host has no networking</td><td><code>R</code>, <code>V</code></td><td><code>D</code></td></tr>
<tr><td>MH04</td><td>No graphics</td><td>Host has no GUI stack</td><td><code>R</code>, <code>V</code></td><td><code>D</code></td></tr>
<tr><td>MH05</td><td>No getty</td><td>Host has no terminal</td><td><code>R</code>, <code>V</code></td><td><code>P</code></td></tr>
<tr><td>MH06</td><td>No nix tooling</td><td>Only <code>/nix/store</code>, no nix</td><td><code>R</code>, <code>V</code></td><td><code>P</code></td></tr>
<tr><td>MH07</td><td>Minimal defconfig</td><td>Host kernel is minimized</td><td><code>R</code>, <code>V</code></td><td><code>D</code></td></tr>
<tr><td>MH08</td><td>Update via adminvm</td><td>A/B update outside host</td><td><code>R</code>, <code>V</code></td><td><code>P</code></td></tr>
<tr><td>MH09</td><td>Read-only filesystem</td><td>Mounted RO, integrity checked</td><td><code>R</code>, <code>V</code></td><td><code>P </code></td></tr>
</tbody></table>
</div>
<p>This list of requirements is not yet comprehensive and may be changed based on findings of further analysis as stated in the following section.</p>
<h2 id="decision"><a class="header" href="#decision">Decision</a></h2>
<p>This ADR adopts a custom developed minimal profile using nixpkgs. It reduces both image and root partition size by eliminating the host OS content per requirements and implements a minimal TCB.</p>
<p>The current implementation of NixOS overridden. For more information on a minimal host profile, see <a href="https://github.com/tiiuae/ghaf/blob/main/modules/host/minimal.nix">minimal.nix</a>.</p>
<p>With the progress of implementing the requirements, the minimal host customization will be illustrated.</p>
<h2 id="consequences"><a class="header" href="#consequences">Consequences</a></h2>
<h3 id="defined-in-nix-mh01"><a class="header" href="#defined-in-nix-mh01">Defined in <code>nix</code> (MH01)</a></h3>
<p>Ghaf minimal host module is implemented in <a href="https://github.com/tiiuae/ghaf/tree/main/modules/host"><code>nix</code> modules</a>.
Currently, host and VM declarations are implemented using <a href="https://github.com/tiiuae/ghaf/blob/main/modules/host/microvm.nix">microvm.nix</a> but this is not strict requirement for ghaf release mode declarations if the limitations or dependencies of microvm.nix do not comply with other requirements. This may require separate release mode custom nix declarations to support flexibility with microvm.nix in debug mode.</p>
<h3 id="reduced-profile-mh02"><a class="header" href="#reduced-profile-mh02">Reduced profile (MH02)</a></h3>
<p>Initial Ghaf minimal profile host size reduction <a href="https://github.com/tiiuae/ghaf/pull/95">is implemented</a> with metrics on host total size and break down of size of the largest dependencies. Based on the metrics, further analysis is needed on several key modules including, but not limited to, kernel, systemd and nixos.</p>
<h3 id="no-networking-mh03"><a class="header" href="#no-networking-mh03">No networking (MH03)</a></h3>
<p>Currently ghaf host profile for both release and debug target has networking. Requirement of no networking on release target requires declarative host configuration where:</p>
<ul>
<li>The release target host kernel is built without networking support. Networking must be enabled for debug target.</li>
<li>The release target host user space has no networking tools nor configurations. Access to tools on host must be enabled for debug target.</li>
</ul>
<p>To support development of configuration changes between release and debug target, the debug target must support networking. This also supports <code>No Virtualization</code>-variant development in which networking must be enabled.</p>
<p>The exception to no networking requirement is the virtual machine manager control socket from host to guest(s). The amount of required kernel configuration dependencies and impact to different VMMs must be further analyzed.</p>
<p>No networking has impact on how <a href="https://github.com/tiiuae/vmd/blob/main/doc/design.md"><code>vmd</code></a> adminvm to host communication is implemented. With no networking, shared memory is proposed.</p>
<p>No networking may have impact on how the guest-to-guest inter virtual machine communication configuration must implemented with VMMs. This must be further analyzed.</p>
<h3 id="no-graphics-mh04"><a class="header" href="#no-graphics-mh04">No graphics (MH04)</a></h3>
<p>Ghaf minimal host profile for release target has no graphics. Graphics will be compartmentalized to GUIVM.
All graphics and display output related components and dependencies, including kernel drivers, must be removed from kernel configuration. Those are to be passed through to GUIVM.</p>
<h3 id="no-getty-mh05"><a class="header" href="#no-getty-mh05">No getty (MH05)</a></h3>
<p>Ghaf host in release mode must have no terminals (TTYs) to interact with. In the current state of development, this cannot be enabled yet and has minimum requirement of system logging outside the host. Proposed design to approach this is requirement is to enable getty declaratively only in a debug serial terminal under <a href="https://github.com/tiiuae/ghaf/tree/main/modules/development"><code>modules/development</code></a>.</p>
<h3 id="no-nix-toolings-mh06"><a class="header" href="#no-nix-toolings-mh06">No <code>nix</code> toolings (MH06)</a></h3>
<p>Ghaf host in release mode has no nix tooling to work with the <code>/nix/store</code>. The <code>/nix/store</code> is only used to build the host system. In release mode, no modifications to nix store are possible. Changes are handled with update (MH08).</p>
<p>Ghaf host in debug mode must support nix tooling via read-writable host filesystem. This must be taken into account in build-time nix module declarations.</p>
<h3 id="minimal-defconfig-mh07"><a class="header" href="#minimal-defconfig-mh07">Minimal defconfig (MH07)</a></h3>
<p>Ghaf host release mode kernel configuration must be minimal and hardened in the limits of HW vendor BSP. Kernel configuration per device is to be further analyzed iteratively. Limitations are to be documented per target device kernel configurations and HW support for virtualization.</p>
<h3 id="update-via-adminvm-mh08"><a class="header" href="#update-via-adminvm-mh08">Update via adminvm (MH08)</a></h3>
<p>Ghaf host release mode filesystem updates are to be implemented using A/B update mechanism from adminvm. This will be designed and covered in a separate ADR.</p>
<h3 id="read-only-filesystem-mh09"><a class="header" href="#read-only-filesystem-mh09">Read-only filesystem (MH09)</a></h3>
<p>Ghaf minimal host in release mode must be implemented with read-only, integrity checked (<code>dm-verity</code>) filesystem.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="netvmnetworking-virtual-machine"><a class="header" href="#netvmnetworking-virtual-machine">netvm‚ÄîNetworking Virtual Machine</a></h1>
<h2 id="status-2"><a class="header" href="#status-2">Status</a></h2>
<p>Proposed, partially implemented for development and testing.</p>
<p><em>netvm</em> reference declaration is available at <a href="https://github.com/tiiuae/ghaf/blob/main/microvmConfigurations/netvm/default.nix">netvm/default.nix</a>.</p>
<h2 id="context-1"><a class="header" href="#context-1">Context</a></h2>
<p>Ghaf high-level design target is to secure a monolithic OS by modularizing the OS to networked VMs. The key security target is to not expose the trusted host directly to the Internet. This isolates the attack surface from the Internet to <em>netvm</em>.</p>
<p>The following context diagram illustrates development and secure scenarios:</p>
<p><img src="architecture/adr/../../img/netvm.drawio.png" alt="Scope!" title="netvm Context" /></p>
<p><strong>Left</strong>: An insecure development scenario. The host is directly connected to the Internet, and the network is bridged from the host to other parts of the system.</p>
<p><strong>Right</strong>: A secure scenario. The network is passed through to <em>netvm</em> and routed to other parts of the system.</p>
<h2 id="decision-1"><a class="header" href="#decision-1">Decision</a></h2>
<p>The development scenario simplifies the target system network access and configuration. This ADR proposes the development <em>netvm</em> configuration is maintained to support system development.</p>
<p>The secure scenario is proposed to be implemented with the use of passthrough to DMA and remap the host physical network interface card (PHY NIC) to <em>netvm</em>. This cannot be generalized for all hardware targets as it requires:</p>
<ul>
<li>Low-level device tree configuration for bootloader and host (at least on platform NIC).</li>
<li>VMM host user space NIC bus mapping from the host to <em>netvm</em>.</li>
<li>Native network interface driver (not virtual) in <em>netvm</em>. Native driver is bound the vendor BSP supported kernel version.</li>
</ul>
<p>These depend on the hardware setup. The proposed target setup is that the passthrough network device(s) are implemented as declarative nix-modules for easier user hardware-specific configuration. In practice, a user may configure the declaration of a PCI or USB network card that is available to the available hardware setup.</p>
<p><em>netvm</em> will provide:</p>
<ul>
<li>dynamic network configuration:
<ul>
<li>A DHCP server for <em>netvm</em> to provide IP addresses for the other parts of the system, both static and dynamic.</li>
<li>Routing from <em>netvm</em> to the Internet and/or inter VM.</li>
</ul>
</li>
</ul>
<p>For common reference hardware with platform NIC, the configured modules for network interface passthrough are provided. For more information, see <a href="https://tiiuae.github.io/ghaf/research/passthrough/ethernet.html">i.MX 8QM Ethernet Passthrough</a>.</p>
<p>Details of other network components, such as default firewall rules, DHCP (static and dynamic client addresses), routing, reverse proxies and security monitoring are to be described in their respective architecture decision records. In this context, these are illustrated in the context diagram on the right side of the <em>netvm</em> network interface driver.</p>
<h2 id="consequences-1"><a class="header" href="#consequences-1">Consequences</a></h2>
<p>Isolating the attack surface from the host to networking-specific guest VM makes it easier to protect the critical host system from compromise. The isolation also makes it easier to deploy further security, such as a zero trust policy engine or intrusion detection system (IDS).</p>
<p>Isolation makes configuration and comprehension of the system more difficult.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="rust-vmmbus-passthrough-support-for-rust-vmms"><a class="header" href="#rust-vmmbus-passthrough-support-for-rust-vmms">rust-vmm‚ÄîBus Passthrough Support for Rust VMMs</a></h1>
<h2 id="status-3"><a class="header" href="#status-3">Status</a></h2>
<p>Proposed, work in progress.</p>
<h2 id="context-2"><a class="header" href="#context-2">Context</a></h2>
<p>This ADR is a work-in-progress note for Ghaf bus passthrough implementation that will support rust-vmm-based hypervisors.</p>
<blockquote>
<p><em>rust-vmm</em> is an open-source project that empowers the community to build custom Virtual Machine Monitors (VMMs) and hypervisors. For more information, see <a href="https://github.com/rust-vmm/community">https://github.com/rust-vmm/community</a>.</p>
</blockquote>
<p>It is crucial to have bus devices passthrough support for ARM-based hardware as the bus is mainly used to connect the peripherals. Nowadays, the only hypervisor with some support for Platform bus is QEMU but the code is dated 2013 and not frequently used.</p>
<p>On the other hand, one of the target hardware devices for Ghaf is NVIDIA Orin with an ARM core. To achieve Ghaf's security and hardware isolation goals, devices should support passthrough mode. Production-ready rust-vmm-based hypervisors (<a href="https://github.com/google/crosvm">crosvm</a>, <a href="https://github.com/firecracker-microvm/firecracker">Firecracker</a>, <a href="https://www.cloudhypervisor.org/">Cloud Hypervisor</a>) do not have support for Platform bus.</p>
<h2 id="decision-2"><a class="header" href="#decision-2">Decision</a></h2>
<p>Implementation of Platform bus passthrough is a base framework for Rust VMM. This will make it possible to use this mode within production-ready rust-vmm-based hypervisors. The main candidate here is crosvm. The necessity to support Platform bus in other hypervisors is subject to discussion. Technically, the Platform bus is rather a simple bus: it manages memory mapping and interrupts. Information about devices is not dynamic but is read from the device tree during the boot stage.</p>
<p>The current status:</p>
<div class="table-wrapper"><table><thead><tr><th>Required Components</th><th>Status of Readiness</th></tr></thead><tbody>
<tr><td>Host kernel side:</td><td></td></tr>
<tr><td>VFIO drivers (to substitute real driver in host kernel)</td><td>-/+</td></tr>
<tr><td>Host support for device trees</td><td>+</td></tr>
<tr><td>Guest kernel side:</td><td></td></tr>
<tr><td>Device drivers for passthrough devices</td><td>+</td></tr>
<tr><td>Guest support for device trees</td><td>+</td></tr>
<tr><td>Rust VMM side:</td><td></td></tr>
<tr><td>Bus support</td><td>Needs to be developed.</td></tr>
<tr><td>VMM support for device trees</td><td>Rudimental, needs improvement.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="hardening"><a class="header" href="#hardening">Hardening</a></h1>
<p>This section describes how securing Ghaf by reducing its attack surface‚Äîhardening‚Äîis done.</p>
<h2 id="kernel"><a class="header" href="#kernel">Kernel</a></h2>
<p>Ghaf has two types of kernels: host and guest. Hardening of these kernels varies in terms of hardware support and functionality required by the guest kernel in question. Within this context, the kernel always refers to the Linux operating system kernel.</p>
<h3 id="kernel-hardening-process"><a class="header" href="#kernel-hardening-process">Kernel Hardening Process</a></h3>
<p>NixOS provides several mechanisms to customize the kernel. The main methods are:</p>
<ul>
<li>
<p><a href="https://nixos.wiki/wiki/Linux_kernel#Custom_kernel_commandline">Declaring kernel command line parameters</a>: <a href="https://github.com/search?q=repo%3Atiiuae%2Fghaf%20kernelparams&amp;type=code">usage in Ghaf</a>.</p>
</li>
<li>
<p><a href="https://nixos.org/manual/nixos/stable/#sec-linux-config-customizing">Declaring kernel custom configuration</a>: <a href="https://github.com/tiiuae/ghaf/blob/main/modules/host/kernel.nix">usage in Ghaf</a>.</p>
<p>Example of entering the kernel development shell to customize the <code>.config</code> and build it:</p>
<pre><code>~/ghaf $ nix develop .#devShells.x86_64-linux.kernel-x86
...
[ghaf-kernel-devshell:~/ghaf/linux-6.6.7]$ cp ../modules/common/hardware/x86_64-generic/kernel/configs/ghaf_host_hardened_baseline .config
[ghaf-kernel-devshell:~/ghaf/linux-6.6.7]$ make menuconfig
...
[ghaf-kernel-devshell:~/ghaf/linux-6.6.7]$ make -j$(nproc)
...
Kernel: arch/x86/boot/bzImage
</code></pre>
</li>
<li>
<p>Booting the built kernel with QEMU:</p>
<pre><code>[ghaf-kernel-devshell:~/ghaf/linux-6.6.7]$ qemu-system-x86_64 -kernel arch/x86/boot/bzImage
</code></pre>
</li>
<li>
<p><a href="https://github.com/a13xp0p0v/kernel-hardening-checker">Validating with kernel hardening checker</a>:</p>
<pre><code>[ghaf-kernel-devshell:~/ghaf/linux-6.6.7]$ cp ../modules/common/hardware/x86_64-generic/kernel/configs/ghaf_host_hardened_baseline .config
[ghaf-kernel-devshell:~/ghaf/linux-6.6.7]$ HS=../modules/common/hardware/x86_64-generic/kernel/host/configs GS=../modules/common/hardware/x86_64-generic/kernel/guest/configs
[ghaf-kernel-devshell:~/ghaf/linux-6.6.7]$ ./scripts/kconfig/merge_config.sh .config $HS/virtualization.config $HS/networking.config $HS/usb.config $HS/user-input-devices.config $HS/debug.config $GS/guest.config $GS/display-gpu.config
[ghaf-kernel-devshell:~/ghaf/linux-6.6.7]$ kernel-hardening-checker -c .config
[+] Kconfig file to check: .config
[+] Detected microarchitecture: X86_64
[+] Detected kernel version: 6.6
[+] Detected compiler: GCC 120300
...
[+] Config check is finished: 'OK' - 188 / 'FAIL' - 8
[ghaf-kernel-devshell:~/ghaf/linux-6.6.7]$ kernel-hardening-checker -c .config| grep 'FAIL: '
CONFIG_CFI_CLANG                        |kconfig|     y      |   kspp   | self_protection  | FAIL: is not found
CONFIG_CFI_PERMISSIVE                   |kconfig| is not set |   kspp   | self_protection  | FAIL: CONFIG_CFI_CLANG is not "y"
CONFIG_MODULES                          |kconfig| is not set |   kspp   |cut_attack_surface| FAIL: "y"
CONFIG_KCMP                             |kconfig| is not set |  grsec   |cut_attack_surface| FAIL: "y"
CONFIG_FB                               |kconfig| is not set |maintainer|cut_attack_surface| FAIL: "y"
CONFIG_VT                               |kconfig| is not set |maintainer|cut_attack_surface| FAIL: "y"
CONFIG_KSM                              |kconfig| is not set |  clipos  |cut_attack_surface| FAIL: "y"
CONFIG_TRIM_UNUSED_KSYMS                |kconfig|     y      |    my    |cut_attack_surface| FAIL: "is not set"
</code></pre>
</li>
</ul>
<h3 id="host-kernel"><a class="header" href="#host-kernel">Host Kernel</a></h3>
<p>The host kernel runs on bare metal. The kernel is provided either with Linux upstream (<code>x86_64</code>) or with vendor BSP. The default Ghaf host kernel on <code>x86_64</code> is maintained by Ghaf upstream package sources <code>nixpkgs</code> or Nix-packaged hardware-specific BSP (for example, NVIDIA Jetson-family of devices).</p>
<h4 id="x86-64-linux"><a class="header" href="#x86-64-linux"><code>x86-64-linux</code></a></h4>
<p>The host kernel hardening is based on Linux <code>make tinyconfig</code>. The
default <code>tinyconfig</code> fails to assertions on NixOS without
modifications. Assertions are fixed in the <code>ghaf_host_hardened_baseline</code> Linux configuration under Ghaf
<code>modules/common/hardware/x86_64-generic/kernel/configs</code>. Resulting baseline
kernel configuration is generic for x86_64 hardware architecture devices.</p>
<p>In addition, NixOS (Ghaf baseline dependency) requires several kernel modules that are added to the config or ignored with <code>allowMissing = true</code>. As of now, the kernel builds and early boots on Lenovo X1.</p>
<h3 id="virtualization-support"><a class="header" href="#virtualization-support">Virtualization Support</a></h3>
<p>The host Virtualization support will add the required kernel config dependency to the Ghaf baseline by which NixOS has virtualization enabled. It can be enabled with the following flag <code>ghaf.host.kernel_virtualization_hardening.enable</code> for Lenovo X1.</p>
<h3 id="networking-support"><a class="header" href="#networking-support">Networking Support</a></h3>
<p>The host Networking support will add the required kernel config dependency to the Ghaf baseline by which NixOS has networking enabled, It can be enabled with the following flag <code>ghaf.host.kernel_networking_hardening.enable</code> for Lenovo X1.</p>
<h3 id="usb-support"><a class="header" href="#usb-support">USB Support</a></h3>
<p>USB support on host is for the <code>-debug-profile</code> builds, not for hardened host -release-builds. As of now, USB support needs to be enabled when debug support to host via USB ethernet adapter (Lenovo X1) is needed or when the user want to boot Ghaf using an external SSD. It is optional in case Ghaf is used with internal NVME.</p>
<p>It can be enabled with the following flag <code>ghaf.host.kernel_usb_hardening.enable</code> for Lenovo X1.</p>
<h3 id="user-input-devices-support"><a class="header" href="#user-input-devices-support">User Input Devices Support</a></h3>
<p>The User Input Devices support will add the required kernel config dependency to the Ghaf baseline by which NixOS has user input devices enabled. It can be enabled with the following flag <code>ghaf.host.kernel_inputdevices_hardening.enable</code> for Lenovo X1.</p>
<p>To enable GUI, set Virtualization, Networking and User Input Devices support. As of now, the kernel builds and can boot on Lenovo X1.</p>
<h3 id="debug-support"><a class="header" href="#debug-support">Debug Support</a></h3>
<p>The Debug support on host is for the <code>-debug-profile</code> builds, not for hardened host -release-builds. It can be helpful when debugging¬†functionality is needed in a development¬†environment.</p>
<p>It can be enabled with the following flag <code>ghaf.host.kernel.debug_hardening.enable</code> for Lenovo X1.</p>
<h3 id="guest-support"><a class="header" href="#guest-support">Guest Support</a></h3>
<p>The Guest support will add the required kernel config dependency to the Ghaf baseline by which NixOS has guest enabled. The added functionality is vsock for host-to-guest and guest-to-guest communication.</p>
<p>It can be enabled with the following flag <code>guest.hardening.enable</code> for Lenovo X1.</p>
<h3 id="guest-graphics-support"><a class="header" href="#guest-graphics-support">Guest Graphics Support</a></h3>
<p>The Guest Graphics support will add the required kernel config dependency to the Ghaf baseline by which NixOS has guest graphics enabled. The added functionality is for guest with graphics support enabled.</p>
<p>It can be enabled with the following flag <code>guest.graphics_hardening.enable</code> for Lenovo X1.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="secure-boot"><a class="header" href="#secure-boot">Secure Boot</a></h1>
<p>This section describes Secure Boot and how to create secure keys.</p>
<p>The reader is expected to know the fundamentals of UEFI and have a basic understanding of Secure Boot <a href="https://uefi.org/specifications">UEFI specification</a>.</p>
<h2 id="enabling-secure-boot"><a class="header" href="#enabling-secure-boot">Enabling Secure Boot</a></h2>
<p>Secure Boot can be enabled on NixOS using <a href="https://github.com/nix-community/lanzaboote">Lanzaboote</a>. Secure Boot is a UEFI feature that only allows trusted operating systems to boot.
Lanzaboote has two components: lzbt and stub. lzbt signs and installs the boot files on the ESP. stub is a UEFI application that loads the kernel and initrd from the ESP.</p>
<h2 id="creating-secure-boot-keys"><a class="header" href="#creating-secure-boot-keys">Creating Secure Boot Keys</a></h2>
<p>Secure Boot keys can be created with <a href="https://github.com/Foxboron/sbctl">sbctl</a>, a Secure Boot Manager. sbctl is available in Nixpkgs as pkgs.sbctl.</p>
<p>After you installed sbctl or entered a Nix shell, use the following command to create your Secure Boot keys:</p>
<pre><code>$ sudo sbctl create-keys
</code></pre>
<p>Using "sudo sbctl create-keys" command user can create secure keys on the trusted system.</p>
<h2 id="current-implementation"><a class="header" href="#current-implementation">Current Implementation</a></h2>
<p>For demonstration purposes, we use pre-generated secure keys which are <strong>unsecure</strong> as whoever has keys can break into the system.
Currently, the Secure Boot feature is enabled in debug builds only, since secure key creation requires sudo rights.</p>
<h3 id="secure-boot-verification"><a class="header" href="#secure-boot-verification">Secure Boot Verification</a></h3>
<ul>
<li>
<p>For enabling secure boot instructions, see the <a href="https://github.com/nix-community/lanzaboote/blob/master/docs/QUICK_START.md#part-2-enabling-secure-boot">Part 2: Enabling Secure Boot</a> section of the NixOS Secure Boot Quick Start Guide.</p>
</li>
<li>
<p>Make sure your Secure Boot is enabled from the BIOS menu.</p>
</li>
<li>
<p>Once you boot your system with Secure Boot enabled, enroll keys with the following command:</p>
</li>
</ul>
<pre><code>$ sudo sbctl enroll-keys --microsoft
</code></pre>
<p>Reboot the system to activate Secure Boot in the user mode:</p>
<pre><code>$ bootctl status
System:
      Firmware: UEFI 2.70 (Lenovo 0.4720)
 Firmware Arch: x64
   Secure Boot: enabled (user)
  TPM2 Support: yes
  Boot into FW: supported
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="stack"><a class="header" href="#stack">Stack</a></h1>
<p>The Ghaf stack includes a host with VMs. The host consists of two layers‚ÄîOS kernel with hypervisor and OS user space‚Äîand provides virtualization for the guest VMs: system VMs, application or service VMs, or guest OSs.
The stack layers and top-level components are illustrated in the following diagram.</p>
<p><img src="architecture/../img/stack.drawio.png" alt="Stack!" title="Ghaf Stack" /></p>
<p>At the lowest levels of the stack lay hardware vendor-provided hardware, firmware, and board support package. The Ghaf project aims to use the vendor-provided components either as they are or configure them as supported by the vendor. Configuration may include, for example, host kernel hardening and including only selected components from the vendor BSP.</p>
<p>The Ghaf project provides the reference minimal host with user space as defined in the <a href="architecture/./adr/minimal-host.html">Minimal Host</a>.</p>
<h2 id="system-vms"><a class="header" href="#system-vms">System VMs</a></h2>
<p>Ghaf provides reference system VMs for networking, GUI and storage.</p>
<div class="table-wrapper"><table><thead><tr><th>System VM</th><th>Defined</th><th>Implementation Status</th></tr></thead><tbody>
<tr><td>Networking</td><td><a href="architecture/adr/netvm.html">Yes</a></td><td>Partial</td></tr>
<tr><td>GUI (optional)</td><td>No</td><td>Reference Wayland on host, to be isolated to VM</td></tr>
</tbody></table>
</div>
<p>GUI VM is considered optional as it may not be needed in some headless configurations.</p>
<h2 id="application-or-service-vm"><a class="header" href="#application-or-service-vm">Application or Service VM</a></h2>
<p>Ghaf should provide reference application VMs and service VMs that isolate respective software from the host. Depending on the use case requirements, these VMs will communicate with other parts of the system over networking and shared memory. As an example, application VMs (Wayland client) will communicate with the GUI VM (Wayland compositor) across the VM boundaries. This is called cross-domain Wayland. Another, already partially implemented area is networking VM that will securely provide Internet access to other VMs.</p>
<h2 id="guest-oss"><a class="header" href="#guest-oss">Guest OSs</a></h2>
<p>Ghaf aims to support users with guest OSs such as other Linux distributions (Ubuntu, Fedora, etc.), Windows, and Android. Some of these have been already prototyped.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="contribution-guidelines"><a class="header" href="#contribution-guidelines">Contribution Guidelines</a></h1>
<p>Improvements to code and documentation are welcome! We would love to get contributions from you. For more information, see <a href="https://github.com/tiiuae/ghaf/blob/main/CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
<p>Some things that will increase the chance that your pull request is accepted faster:</p>
<ul>
<li>Spelling tools usage.</li>
<li><a href="https://github.com/tiiuae/ghaf/blob/main/docs/style_guide.md">Following our Style Guide</a>.</li>
<li><a href="https://github.com/tiiuae/ghaf/blob/main/CONTRIBUTING.md#commit-message-guidelines">Writing a good commit message</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="reference-implementations"><a class="header" href="#reference-implementations">Reference Implementations</a></h1>
<p>Our hardened OS targets are build configurations based on NixOS. The canonical URL for the upstream Nix git repository is: <a href="https://github.com/NixOS">https://github.com/NixOS</a>.</p>
<p>Build configurations define our dependencies and configuration changes to packages and build mechanisms of NixOS. If you want to try Ghaf, see <a href="ref_impl/../ref_impl/build_and_run.html">Build and Run</a>.</p>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<p>A build configuration is a target to build the hardened OS for a particular hardware device. Most packages used in a build configuration come from <a href="https://github.com/NixOS/nixpkgs">nixpkgs‚ÄîNixOS Packages collection</a>.</p>
<p>The upstream first approach means we aim the fix issues by contributing to nixpkgs. At the same time, we get the maintenance support of NixOS community and the benefits of the Nix language on how to build packages and track the origins of packages in the software supply chain security. For more information, see <a href="ref_impl/../scs/scs.html">Supply Chain Security</a>.</p>
<p>NixOS, a Linux OS distribution packaged with Nix, provides us with:</p>
<ul>
<li>generic hardware architecture support (<code>x86-64</code> and <code>AArch64</code>)</li>
<li>declarative and modular mechanism to describe the system</li>
<li>Nix packaging language mechanisms:
<ul>
<li>to extend and change packages with <a href="https://nixos.wiki/wiki/Overlays">overlays</a></li>
<li>to <a href="https://nixos.org/guides/nix-pills/override-design-pattern.html">override</a> packages</li>
</ul>
</li>
</ul>
<p>Even when unmodified upstream is often preferred, even ideal, to ensure timely security updates from upstream‚Äîcustomizations are sometimes required.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>To support a reference board without a vendor board support package (BSP)‚Äîbootloader, kernel, device drivers‚Äîis often not feasible. With this approach, we can overlay the generic NixOS Linux kernel with the vendor kernel and add a vendor bootloader to build a target image.</p>
<p>Often the vendor BSPs are also open source but sometimes contain unfree binary blobs from the vendor's hardware. Those are handled by allowing <code>unfree</code> - if the user agrees with the end-user license agreement (EULA). If not, <code>unfree</code> support can be dropped along with that part of the BSP support.</p>
<p>The same goes with the architectural variants as headless devices or end-user devices differ in terms what kind of virtual machines (VM) they contain. The user needs graphics architecture and VM support for the user interface (UI) whereas a headless device is more like a small server without the UI.</p>
<h2 id="in-this-chapter-1"><a class="header" href="#in-this-chapter-1">In This Chapter</a></h2>
<ul>
<li><a href="ref_impl/./development.html">Development</a>
<ul>
<li><a href="ref_impl/./build_and_run.html">Build and Run</a></li>
<li><a href="ref_impl/./installer.html">Installer</a></li>
<li><a href="ref_impl/./cross_compilation.html">Cross-Compilation</a></li>
<li><a href="ref_impl/./creating_appvm.html">Creating Application VM</a></li>
</ul>
</li>
<li><a href="ref_impl/./ghaf-based-project.html">Ghaf as Library: Templates</a>
<ul>
<li><a href="ref_impl/./example_project.html">Example Project</a></li>
<li><a href="ref_impl/./modules_options.html">Modules Options</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="development-1"><a class="header" href="#development-1">Development</a></h1>
<p>Ghaf Framework is free software, currently under active development.</p>
<p>The scope of target support is updated with development progress:</p>
<ul>
<li><a href="ref_impl/./build_and_run.html">Build and Run</a></li>
<li><a href="ref_impl/./remote_build_setup.html">Running Remote Build on NixOS</a></li>
<li><a href="ref_impl/./installer.html">Installer</a></li>
<li><a href="ref_impl/./cross_compilation.html">Cross-Compilation</a></li>
<li><a href="ref_impl/./creating_appvm.html">Creating Application VM</a></li>
<li><a href="ref_impl/./labwc.html">labwc Desktop Environment</a></li>
</ul>
<p>Once you are up and running, you can participate in the collaborative development process by building a development build with additional options. For example, with the development username and password that are defined in <a href="https://github.com/tiiuae/ghaf/blob/main/modules/users/accounts.nix">accounts.nix</a>.</p>
<p>If you authorize your development SSH keys in the <a href="https://github.com/tiiuae/ghaf/blob/main/modules/development/ssh.nix#L10-L23">ssh.nix</a> module and rebuild Ghaf for your target device, you can use <code>nixos-rebuild switch</code> to quickly deploy your configuration changes to the target device over the network using SSH. For example:</p>
<pre><code>nixos-rebuild --flake .#nvidia-jetson-orin-agx-debug --target-host root@&lt;ip_address_of_ghaf-host&gt; --fast switch
...
nixos-rebuild --flake .#lenovo-x1-carbon-gen11-debug --target-host root@&lt;ip_address_of_ghaf-host&gt; --fast switch
...
</code></pre>
<blockquote>
<p>With the <code>-debug</code> targets, the debug ethernet is enabled on host. With Lenovo X1 Carbon, you can connect USB-Ethernet adapter for the debug and development access.</p>
</blockquote>
<p>Pull requests are the way for contributors to submit code to the Ghaf project. For more information, see <a href="ref_impl/../appendices/contributing_general.html">Contribution Guidelines</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="build-and-run"><a class="header" href="#build-and-run">Build and Run</a></h1>
<p>This tutorial assumes that you already have basic <a href="https://git-scm.com/">git</a> experience.</p>
<p>The canonical URL for the upstream Ghaf git repository is <a href="https://github.com/tiiuae/ghaf">https://github.com/tiiuae/ghaf</a>. To try Ghaf, you can build it from the source.</p>
<blockquote>
<p><a href="ref_impl/../ref_impl/cross_compilation.html">Cross-compilation</a> support is currently under development and not available for the building process.</p>
</blockquote>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>First, follow the basic device-independent steps:</p>
<ul>
<li>Clone the git repository <a href="https://github.com/tiiuae/ghaf">https://github.com/tiiuae/ghaf</a>.</li>
<li>Ghaf uses a Nix flake approach to build the framework targets, make sure to:
<ul>
<li>Install Nix or full NixOS if needed: <a href="https://nixos.org/download.html">https://nixos.org/download.html</a>.</li>
<li>Enable flakes: <a href="https://nixos.wiki/wiki/Flakes#Enable_flakes">https://nixos.wiki/wiki/Flakes#Enable_flakes</a>.
To see all Ghaf-supported outputs, type <code>nix flake show</code>.</li>
<li>Set up an AArch64 remote builder: <a href="https://nixos.org/manual/nix/stable/advanced-topics/distributed-builds.html">https://nixos.org/manual/nix/stable/advanced-topics/distributed-builds.html</a>.</li>
</ul>
</li>
</ul>
<p>Then you can use one of the following instructions for the supported targets:</p>
<div class="table-wrapper"><table><thead><tr><th>Device</th><th>Architecture</th><th>Instruction</th></tr></thead><tbody>
<tr><td>Virtual Machine</td><td>x86_64</td><td><a href="ref_impl/./build_and_run.html#running-ghaf-image-for-x86-vm-ghaf-host">Running Ghaf Image for x86 VM (ghaf-host)</a></td></tr>
<tr><td>Generic x86 –°omputer</td><td>x86_64</td><td><a href="ref_impl/./build_and_run.html#running-ghaf-image-for-x86-computer">Running Ghaf Image for x86 Computer</a></td></tr>
<tr><td>Lenovo X1 Carbon Gen 11</td><td>x86_64</td><td><a href="ref_impl/./build_and_run.html#running-ghaf-image-for-lenovo-x1">Running Ghaf Image for Lenovo X1</a></td></tr>
<tr><td>NVIDIA Jetson AGX Orin</td><td>AArch64</td><td><a href="ref_impl/./build_and_run.html#ghaf-image-for-nvidia-jetson-orin-agx">Ghaf Image for NVIDIA Jetson Orin AGX</a></td></tr>
<tr><td>NXP i.MX 8QM-MEK</td><td>AArch64</td><td><a href="ref_impl/./build_and_run.html#building-ghaf-image-for-nxp-imx-8qm-mek">Building Ghaf Image for NXP i.MX 8QM-MEK</a></td></tr>
<tr><td>MICROCHIP icicle-kit</td><td>RISCV64</td><td><a href="ref_impl/./build_and_run.html#building-ghaf-image-for-microchip-icicle-kit">Building Ghaf Image for Microchip Icicle Kit</a></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="running-ghaf-image-for-x86-vm-ghaf-host"><a class="header" href="#running-ghaf-image-for-x86-vm-ghaf-host">Running Ghaf Image for x86 VM (ghaf-host)</a></h2>
<p>Before you begin, check device-independent <a href="ref_impl/./build_and_run.html#prerequisites">prerequisites</a>.</p>
<p>From the <code>ghaf</code> source directory, run the <code>nix run .#packages.x86_64-linux.vm-debug</code> command.</p>
<p>This creates <code>ghaf-host.qcow2</code> copy-on-write overlay disk image in your current directory. If you do unclean shutdown for the QEMU VM, you might get weird errors the next time you boot. Simply removing <code>ghaf-host.qcow2</code> should be enough. To cleanly shut down the VM, from the menu bar of the QEMU Window, click Machine and then Power Down.</p>
<hr />
<h2 id="running-ghaf-image-for-x86-computer"><a class="header" href="#running-ghaf-image-for-x86-computer">Running Ghaf Image for x86 Computer</a></h2>
<p>Before you begin, check device-independent <a href="ref_impl/./build_and_run.html#prerequisites">prerequisites</a>.</p>
<p>Do the following:</p>
<ol>
<li>To build the target image, run the command:
<pre><code>nix build github:tiiuae/ghaf#generic-x86_64-debug
</code></pre>
</li>
<li>After the build is completed, prepare a USB boot media with the target image you built:
<pre><code>dd if=./result/nixos.img of=/dev/&lt;YOUR_USB_DRIVE&gt; bs=32M status=progress oflag=direct
</code></pre>
</li>
<li>Boot the computer from the USB media.</li>
</ol>
<hr />
<h2 id="running-ghaf-image-for-lenovo-x1"><a class="header" href="#running-ghaf-image-for-lenovo-x1">Running Ghaf Image for Lenovo X1</a></h2>
<p>Lenovo X1 is the reference x86_64 device for the Ghaf project.</p>
<p>Do the following:</p>
<ol>
<li>To build the target image, run the command:
<pre><code>nix build github:tiiuae/ghaf#lenovo-x1-carbon-gen11-debug
</code></pre>
</li>
<li>After the build is completed, prepare a USB boot media with the target image you built:
<pre><code>dd if=./result/nixos.img of=/dev/&lt;YOUR_USB_DRIVE&gt; bs=32M status=progress oflag=direct
</code></pre>
</li>
<li>Boot the computer from the USB media.</li>
</ol>
<hr />
<h2 id="ghaf-image-for-nvidia-jetson-orin-agx"><a class="header" href="#ghaf-image-for-nvidia-jetson-orin-agx">Ghaf Image for NVIDIA Jetson Orin AGX</a></h2>
<p>Before you begin:</p>
<ul>
<li>Check device-independent <a href="ref_impl/./build_and_run.html#prerequisites">prerequisites</a>.</li>
<li>If you use a new device, <a href="ref_impl/./build_and_run.html#flashing-nvidia-jetson-orin-agx">flash bootloader firmware</a> first. Then you can <a href="ref_impl/./build_and_run.html#building-and-running-ghaf-image-for-nvidia-jetson-orin-agx">build and run a Ghaf image</a>.</li>
</ul>
<h4 id="flashing-nvidia-jetson-orin-agx"><a class="header" href="#flashing-nvidia-jetson-orin-agx">Flashing NVIDIA Jetson Orin AGX</a></h4>
<ol>
<li>
<p>Run the command:</p>
<pre><code>nix build github:tiiuae/ghaf#nvidia-jetson-orin-agx-debug-flash-script
</code></pre>
<p>It will build the Ghaf image and bootloader firmware, and prepare the flashing script. Give "yes" answers to all script questions. The building process takes around 1,5 hours.</p>
</li>
<li>
<p>Set up the following connections:</p>
<ol>
<li>Connect the board to a power supply with a USB-C cable.</li>
<li>Connect a Linux laptop to the board with the USB-C cable.</li>
<li>Connect the Linux laptop to the board with a Micro-USB cable to use <a href="https://developer.ridgerun.com/wiki/index.php/NVIDIA_Jetson_Orin/In_Board/Getting_in_Board/Serial_Console">serial interface</a>.</li>
</ol>
<blockquote>
<p>For more information on the board's connections details, see the <a href="https://developer.nvidia.com/embedded/learn/jetson-agx-orin-devkit-user-guide/developer_kit_layout.html">Hardware Layout</a> section of the Jetson AGX Orin Developer Kit User Guide.</p>
</blockquote>
</li>
<li>
<p>After the build is completed, put the board in recovery mode. For more information, see the <a href="https://developer.nvidia.com/embedded/learn/jetson-agx-orin-devkit-user-guide/howto.html#force-recovery-mode">Force Recovery</a> Mode section in the Jetson AGX Orin Developer Kit User Guide.</p>
</li>
<li>
<p>Run the flashing script:</p>
<pre><code>sudo ~/result/bin/flash-ghaf-host
</code></pre>
<p>There is a time-out for this operation, so run the script within one minute after putting the device in recovery mode. If you got the error message "ERROR: might be timeout in USB write.":</p>
<ol>
<li>Reboot the device and put it in recovery mode again.</li>
<li>Check with the <code>lsusb</code> command if your computer can still recognize the board, and run the flash script again.</li>
</ol>
</li>
<li>
<p>Restart the device after flashing is done.</p>
</li>
</ol>
<h4 id="building-and-running-ghaf-image-for-nvidia-jetson-orin-agx"><a class="header" href="#building-and-running-ghaf-image-for-nvidia-jetson-orin-agx">Building and Running Ghaf Image for NVIDIA Jetson Orin AGX</a></h4>
<p>After the latest firmware is <a href="ref_impl/./build_and_run.html#flashing-nvidia-jetson-orin-agx">flashed</a>, it is possible to use a simplified process by building only the Ghaf disk image and running it from external media:</p>
<ol>
<li>To build the target image, run the command:
<pre><code>nix build github:tiiuae/ghaf#nvidia-jetson-orin-agx-debug
</code></pre>
</li>
<li>After the build is completed, prepare a USB boot media with the target image you built:
<pre><code>dd if=./result/nixos.img of=/dev/&lt;YOUR_USB_DRIVE&gt; bs=32M status=progress oflag=direct
</code></pre>
</li>
<li>Boot the hardware from the USB media.</li>
</ol>
<p>In the current state of Ghaf, it is a bit tricky to make NVIDIA Jetson Orin AGX boot Ghaf from a USB if the same thing has already been flashed on the boards's eMMC. To succeed, you can change partition labels on eMMC (or optionally wiping everything away by formatting):</p>
<ol>
<li>Log in as a root:
<pre><code>sudo su
</code></pre>
</li>
<li>Check the current labels:
<pre><code>lsblk -o name,path,fstype,mountpoint,label,size,uuid
</code></pre>
</li>
<li>Change the ext4 partition label:
<pre><code>e2label /dev/mmcblk0p1 nixos_emmc
</code></pre>
</li>
<li>Change the vfat partition label:
<pre><code>dosfslabel /dev/mmcblk0p2 ESP_EMMC
</code></pre>
</li>
<li>Verify the labels that were changed:
<pre><code>lsblk -o name,path,fstype,mountpoint,label,size,uuid
</code></pre>
</li>
<li>After these changes NVIDIA Jetson Orin AGX cannot boot from its internal eMMC. It will boot from the USB device with the correct partition labels.</li>
</ol>
<hr />
<h2 id="building-ghaf-image-for-nxp-imx-8qm-mek"><a class="header" href="#building-ghaf-image-for-nxp-imx-8qm-mek">Building Ghaf Image for NXP i.MX 8QM-MEK</a></h2>
<p>Before you begin, check device-independent <a href="ref_impl/./build_and_run.html#prerequisites">prerequisites</a>.</p>
<p>In the case of i.MX8, Ghaf deployment consists of creating a bootable SD card with a first-stage bootloader (Tow-Boot) and USB media with the Ghaf image:</p>
<ol>
<li>
<p>To build and flash <a href="https://github.com/tiiuae/Tow-Boot"><strong>Tow-Boot</strong></a> bootloader:</p>
<pre><code>$ git clone https://github.com/tiiuae/Tow-Boot.git &amp;&amp; cd Tow-Boot
$ nix-build -A imx8qm-mek
$ sudo dd if=result/ shared.disk-image.img of=/dev/&lt;SDCARD&gt;
</code></pre>
</li>
<li>
<p>To build and flash the Ghaf image:</p>
<ol>
<li>Run the <code>nix build .#packages.aarch64-linux.imx8qm-mek-release</code> command.</li>
<li>Prepare the USB boot media with the target HW image you built: <code>dd if=./result/nixos.img of=/dev/&lt;YOUR_USB_DRIVE&gt; bs=32M status=progress oflag=direct</code>.</li>
</ol>
</li>
<li>
<p>Insert an SD card and USB boot media into the board and switch the power on.</p>
</li>
</ol>
<hr />
<h2 id="building-ghaf-image-for-microchip-icicle-kit"><a class="header" href="#building-ghaf-image-for-microchip-icicle-kit">Building Ghaf Image for Microchip Icicle Kit</a></h2>
<p>Before you begin:</p>
<ul>
<li>Check device-independent <a href="ref_impl/./build_and_run.html#prerequisites">prerequisites</a>.</li>
<li>Make sure HSS version 0.99.35-v2023.02 is programmed in your board eNVM. The version can be seen in the pre-bootloader log. Check the video guide to build HSS and program the eNVM: <a href="https://www.youtube.com/watch?v=McAt2-6cwd4">How to build HSS and program the eNVM?</a></li>
</ul>
<p>In the case of the Icicle Kit, Ghaf deployment consists of creating an SD image with U-Boot and Linux kernel from Microchip, and Ghaf-based NixOS rootfs:</p>
<ol>
<li>
<p>Build a Ghaf SD image:</p>
<p>a. Run the nix build .#packages.riscv64-linux.microchip-icicle-kit-release command to release the image.
b. Run the nix build .#packages.riscv64-linux.microchip-icicle-kit-debug command to debug the image.</p>
</li>
<li>
<p>Flash the Ghaf SD image:</p>
<ul>
<li>
<p>If you want to use a SD card:</p>
<ul>
<li>Prepare the SD card with the target HW image you built: <code>dd if=./result/nixos.img of=/dev/&lt;YOUR_SD_DEVICE&gt; bs=32M status=progress oflag=direct</code>.</li>
<li>Insert an SD card into the board and switch the power on.</li>
</ul>
</li>
<li>
<p>If you want to use the onboard MMC:</p>
<ul>
<li>You can directly flash a NixOS image to onboard an MMC card: <code>dd if=./result/nixos.img of=/dev/&lt;YOUR_MMC_DEVICE&gt; bs=32M status=progress oflag=direct</code>.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>For more information on how to access the MMC card as a USB disk, see <a href="https://tinyurl.com/48wycdka">MPFS Icicle Kit User Guide</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="running-remote-build-on-nixos"><a class="header" href="#running-remote-build-on-nixos">Running Remote Build on NixOS</a></h1>
<p>To set up a remote build on NixOS:</p>
<ol>
<li>Identify required SSH keys for remote SSH connection.</li>
<li>Set up configurations.</li>
</ol>
<p>If you hit an issue, check <a href="ref_impl/./remote_build_setup.html#troubleshooting">Troubleshooting</a>.</p>
<h3 id="1-configuring-ssh-keys"><a class="header" href="#1-configuring-ssh-keys">1. Configuring SSH Keys</a></h3>
<blockquote>
<p>This step assumes that public SSH keys were generated and copied (<em>ssh-copy-id</em>) both for normal and root users. For more information, see <a href="https://www.ssh.com/academy/ssh/copy-id#setting-up-public-key-authentication">Setting up public key authentication</a>.</p>
</blockquote>
<p>Before you begin, make sure an SSH connection is established to the remote host for both normal and root users:</p>
<pre><code>ssh USER@IP_ADDRESS_OF_REMOTE_MACHINE
nix store ping --store ssh://USER@REMOTE_IP_ADDRESS
</code></pre>
<h4 id="11-local-machine-configuring-ssh-keys"><a class="header" href="#11-local-machine-configuring-ssh-keys">1.1. [Local Machine] Configuring SSH Keys</a></h4>
<p>Do the following on a local machine:</p>
<ol>
<li>
<p>Change directory to Home Directory with SSH:</p>
<pre><code>cd .ssh
</code></pre>
<p>The public keys of the remote machine are located in the <em>known_hosts</em> file. These keys are created and configured after the <em>ssh-copy-id</em> command. Make sure the keys are there. If they are not there:</p>
<ol>
<li>Access the remote machine.</li>
<li>Run <code>cd /etc/ssh</code>.</li>
<li>Retrieve and copy the public keys.</li>
<li>Go back to the local machine and paste them into <em>known_hosts</em>.</li>
</ol>
</li>
<li>
<p>Navigate to the <code>/etc/ssh/</code> directory:</p>
<pre><code>cd /etc/ssh
</code></pre>
<p>Make sure the <em>ssh_known_hosts</em> file contains the same public keys as the remote machine (same as <code>.ssh/knwon_hosts</code>). Otherwise, specify it in the <code>configuration.nix</code> file.</p>
</li>
<li>
<p>Use CMD as the root user:</p>
<pre><code>sudo -i
</code></pre>
</li>
<li>
<p>Make sure the root user‚Äôs keys are different from the user‚Äôs keys:</p>
<pre><code>cd .ssh
</code></pre>
<blockquote>
<p><strong>TIP</strong>:<code>.ssh</code> is a user-level access and <code>/etc/ssh</code> is system-wide.</p>
</blockquote>
</li>
</ol>
<h4 id="12-accessing-remote-machine-using-ssh"><a class="header" href="#12-accessing-remote-machine-using-ssh">1.2. Accessing Remote Machine Using SSH</a></h4>
<p>Do the following:</p>
<ol>
<li>
<p>Navigate the <em>authorized_keys</em> file:</p>
<pre><code>ssh USER@IP_ADDRESS_OF_REMOTE_MACHINE
cd .ssh
sudo nano authorized_keys
</code></pre>
</li>
<li>
<p>Make sure that both user and root public keys for the local machine are located there:</p>
<ul>
<li>The user‚Äôs public key can be obtained from <code>/home/username/.ssh/id_rsa.pub</code>.</li>
<li>The root user's public key can be obtained from <code>/root/.ssh/id_rsa.pub</code>.</li>
</ul>
</li>
</ol>
<h3 id="2-setting-up-configuration-files"><a class="header" href="#2-setting-up-configuration-files">2. Setting Up Configuration Files</a></h3>
<h4 id="21-local-machine-setting-up-configuration-files"><a class="header" href="#21-local-machine-setting-up-configuration-files">2.1. [Local Machine] Setting Up Configuration Files</a></h4>
<p>Do the following on a local machine:</p>
<ol>
<li>Set configuration variables in <code>configuration.nix</code> and <code>nix.conf</code>:
<ol>
<li>Use the following commands:
<pre><code>cd /etc/nixos
sudo nano configuration.nix 
</code></pre>
</li>
<li>Add lib in the header like so: <code>{ config, pkgs, lib, ... }:</code>.</li>
<li>Edit the <code>nix.conf</code> file:
<pre><code>environment.etc."nix/nix.conf".text = lib.mkForce ''
    # Your custom nix.conf content here
    builders = @/etc/nix/machines
    require-sigs = false
    max-jobs = 0 # to use remote build by default not local
    substituters = https://cache.nixos.org/
    trusted-public-keys = cache.nixos.org-1:6pb16ZPMQpcDShjY= cache.farah:STwtDRDeIDa...
    build-users-group = nixbld
    trusted-users = root farahayyad
    experimental-features = nix-command flakes
'';
</code></pre>
For more information, see the <a href="https://nixos.org/manual/nix/stable/command-ref/conf-file">nix.conf</a> section of the Nix Reference Manual.</li>
<li>Rebuild NixOS by running:
<pre><code>sudo nixos-rebuild switch
</code></pre>
</li>
</ol>
</li>
<li>Create or set the machines file:
<ol>
<li>
<p>Use the following commands:</p>
<pre><code>cd /etc/nixos
sudo nano machines 
</code></pre>
</li>
<li>
<p>Specify the SSH settings:</p>
<pre><code>[ssh://]USER@HOST target-spec [SSH identity file] [max-jobs] [speed factor]
[supported-features] [mandatory-features] [ssh-public-key-encoded]
</code></pre>
<ul>
<li>Parameters inside ‚Äò[ ]‚Äô are optional.</li>
<li>The ssh-public-key-encoded is the base-64 encoded public key of the remote machine. Get the encoding using:
<pre><code>echo -n "your_public_key_here" | base64
</code></pre>
</li>
<li>If omitted, SSH will use its regular known_hosts file.</li>
</ul>
<p>For more information, see the <a href="https://nixos.org/manual/nix/stable/advanced-topics/distributed-builds.html">Remote Builds</a> section of the Nix Reference Manual.</p>
</li>
</ol>
</li>
</ol>
<h4 id="22-remote-machine-setting-up-configuration-files"><a class="header" href="#22-remote-machine-setting-up-configuration-files">2.2. [Remote Machine] Setting Up Configuration Files</a></h4>
<p>Do the following on a remote machine:</p>
<ol>
<li>Specify the sshd_config settings:
<ol>
<li>Use the following commands:
<pre><code>cd /etc/ssh
sudo nano sshd_config
</code></pre>
</li>
<li>Make sure <em>PubkeyAuthentication</em> is set as <em>yes</em>.</li>
</ol>
</li>
<li>Specify the <code>/etc/nix/nix.conf</code> settings:
<ol>
<li>Use the following commands:
<pre><code>cd /etc/nix
sudo nano nix.conf
</code></pre>
</li>
<li>Edit the <code>nix.conf</code> file:
<pre><code>trusted-public-keys = cache.nixos.org-1:61o0gWypbMrAURk...
build-users-group = nixbld
require-sigs = false
trusted-users = root farahayyad jk
binary-caches = https://cache.nixos.org/
substituters = https://cache.nixos.org/
system-features = nixos-test benchmark big-parallel kvm
binary-cache-public-keys = cache.nixos.org-1:6NCHD59X43...
experimental-features = nix-command flakes
</code></pre>
</li>
<li>Run the following command to restart daemon and update all the preceding changes:
<pre><code>systemctl restart nix-daemon.service
</code></pre>
</li>
</ol>
</li>
</ol>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<ul>
<li><a href="ref_impl/./remote_build_setup.html#single-user-nix-installation-issues">Single-User Nix Installation Issues</a></li>
<li><a href="ref_impl/./remote_build_setup.html#vpn-setup-for-remote-access">VPN Setup for Remote Access</a></li>
<li><a href="ref_impl/./remote_build_setup.html#private-key-on-local-machine-not-matching-public-key-on-remote-machine">Private Key on Local Machine Not Matching Public Key on Remote Machine</a></li>
</ul>
<h3 id="single-user-nix-installation-issues"><a class="header" href="#single-user-nix-installation-issues">Single-User Nix Installation Issues</a></h3>
<p>This issue typically arises when Nix is installed in a single-user mode on the remote machine, which can create permission issues during multi-user operations.</p>
<p>If an operation fails with the following error message:</p>
<pre><code>could not set permissions on '/nix/var/nix/profiles/per-user' to 755: Operation not permitted
</code></pre>
<p>reinstall Nix in a multi-user setup:</p>
<ul>
<li>
<p>Uninstall Nix using a single-user mode:</p>
<pre><code>rm -rf /nix
</code></pre>
</li>
<li>
<p>Install Nix in a multi-user mode:</p>
<pre><code>sh &lt;(curl -L https://nixos.org/nix/install) --daemon
</code></pre>
</li>
</ul>
<p>For more information about Nix security modes, see the <a href="https://nixos.org/manual/nix/stable/installation/nix-security">Security</a> section of the Nix Reference Manual.</p>
<h3 id="vpn-setup-for-remote-access"><a class="header" href="#vpn-setup-for-remote-access">VPN Setup for Remote Access</a></h3>
<p>A VPN is needed, if the local machine is not on the same local network as your remote build machine.</p>
<p>To set up a VPN using <a href="https://www.infradead.org/openconnect/">OpenConnect</a>, do the following:</p>
<ul>
<li>Install OpenConnect:</li>
</ul>
<pre><code>nix-env -iA nixos.openconnect
</code></pre>
<ul>
<li>Establish a VPN connection:</li>
</ul>
<pre><code>sudo openconnect --protocol=gp -b access.tii.ae
</code></pre>
<ul>
<li>Once authenticated, you establish a secure connection to your network. Use <code>ssh USER@IP_ADDRESS_OF_REMOTE_MACHINE</code> to check if it is possible to connect to the remote machine.</li>
</ul>
<h3 id="private-key-on-local-machine-not-matching-public-key-on-remote-machine"><a class="header" href="#private-key-on-local-machine-not-matching-public-key-on-remote-machine">Private Key on Local Machine Not Matching Public Key on Remote Machine</a></h3>
<p>Using mismatched key pairs could result in the Permission denied error.</p>
<p>Ensure and double-check that you are using the right key pairs.</p>
<p>If you choose to use/present your local‚Äôs RSA private key, make sure that it is the corresponding RSA public key that is in the remote‚Äôs authorized_file, not the ED25519 or ECDSA public keys.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="installer"><a class="header" href="#installer">Installer</a></h1>
<h2 id="configuring-and-building-installer-for-ghaf"><a class="header" href="#configuring-and-building-installer-for-ghaf">Configuring and Building Installer for Ghaf</a></h2>
<p>You can obtain the installation image for your Ghaf configuration.</p>
<p>In addition to the live USB image that Ghaf provides it is also possible
to install Ghaf. This can either be achieved by downloading the desired image
or by building it as described below.</p>
<p>Currently only x86_64-linux systems are supported by the standalone installer. So to build e.g. the debug image
for the Lenovo x1 follow the following steps</p>
<pre><code class="language-sh">nix build .#lenovo-x1-carbon-gen11-debug-installer
</code></pre>
<h2 id="flashing-the-installer"><a class="header" href="#flashing-the-installer">Flashing the installer</a></h2>
<p>Once built you must transfer it to the desired installation media. It requires at least a 4GB SSD, at the time of writing.</p>
<pre><code class="language-nix">sudo dd if=./result/iso/ghaf-&lt;version&gt;-x86_64-linux.iso of=/dev/&lt;SSD_NAME&gt; bs=32M status=progress; sync
</code></pre>
<h2 id="installing-the-image"><a class="header" href="#installing-the-image">Installing the image</a></h2>
<p><strong>Warning this is a destructive operation and will overwrite your system</strong></p>
<p>Insert the SSD into the laptop, boot, and select the option to install.</p>
<p>When presented with the terminal run:</p>
<pre><code class="language-nix">sudo ghaf-install.sh
</code></pre>
<p>Check the available options shown in the prompt for the install target
remember that the <code>/dev/sdX</code> is likely the install medium.</p>
<p>Once entered, remembering to include <code>/dev</code>, press ENTER to complete the process.</p>
<pre><code class="language-nix">sudo reboot
</code></pre>
<p>And remember to remove the installer drive</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h1>
<blockquote>
<p>Cross-compilation is currently under development and cannot be used properly on all the supported device configurations.</p>
</blockquote>
<p>Ghaf is targeted at a range of devices and form factors that support different instruction set architectures (ISA). Many small form-factor edge devices are not powerful enough to compile the needed applications or OSs that run on them. As the most common ISA used in desktops and servers is <code>x_86</code>, this will generally require that the code is cross-compiled for target ISA e.g. <code>AArch64</code> or <code>RISC-V</code>.</p>
<p>NixOS and Nixpkgs have good support for cross-compilation, however, there are still some that can not be compiled in this way.</p>
<h2 id="cross-compilation-for-microchip-icicle-kit-riscv64"><a class="header" href="#cross-compilation-for-microchip-icicle-kit-riscv64">Cross-Compilation for Microchip Icicle Kit (RISCV64)</a></h2>
<p>An SD image for the Microchip Icicle Kit can be cross-compiled from an x86 machine. To generate the release or debug an SD image run the following command:</p>
<pre><code> $&gt; nix build .#packages.riscv64-linux.microchip-icicle-kit-&lt;release/debug&gt;
</code></pre>
<h2 id="future-cross-compilation-support"><a class="header" href="#future-cross-compilation-support">Future Cross-Compilation Support</a></h2>
<p>This will involve working with upstream package maintainers to ensure that the packages are cross-compilation aware. This will be addressed on a package-by-package basis.</p>
<h2 id="binfmt-emulated-build"><a class="header" href="#binfmt-emulated-build">binfmt Emulated Build</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Binfmt_misc">binfmt</a> allows running different ISA on a development machine. This is achieved by running the target binary in an emulator such as <code>QEMU</code> or in a VM. So while not cross-compiled it can enable development for some embedded device configurations.</p>
<p>To enable <code>binfmt</code>, we recommend to set the following in your host systems <code>configuration.nix</code>:</p>
<pre><code>boot.binfmt.emulatedSystems = [
  "riscv64-linux"
  "aarch64-linux"
];
</code></pre>
<p>In addition, it is recommended to enable KVM support with either</p>
<pre><code>boot.kernelModules = [ "kvm-amd" ];
</code></pre>
<p>or</p>
<pre><code>boot.kernelModules = [ "kvm-intel" ];
</code></pre>
<p>depending on whether your development host is running AMD or Intel processor.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="creating-application-vm"><a class="header" href="#creating-application-vm">Creating Application VM</a></h1>
<p>Application VM (AppVM) is a VM that improves trust in system components by isolating applications from the host OS and other applications. Virtualization with hardware-backed mechanisms provides better resource protection than traditional OS. This lets users use applications of different trust levels within the same system without compromising system security. While the VMs have overhead, it is acceptable as a result of improved security and usability that makes the application seem like it is running inside an ordinary OS.</p>
<p>As a result, both highly trusted applications and untrusted applications can be hosted in the same secure system when the concerns are separated in their own AppVMs.</p>
<p>To create an AppVM:</p>
<ol>
<li>Add AppVM description.</li>
<li>Add an app launcher in GUI VM.</li>
</ol>
<h2 id="adding-appvm-description"><a class="header" href="#adding-appvm-description">Adding AppVM Description</a></h2>
<p>Add the VM description in the target configuration.</p>
<p><a href="https://github.com/tiiuae/ghaf/blob/main/targets/lenovo-x1-carbon.nix">lenovo-x1-carbon.nix</a> already has AppVMs inside for Chromium, Gala, and Zathura applications.</p>
<h4 id="appvms-example"><a class="header" href="#appvms-example">AppVMs Example</a></h4>
<pre><code>vms = with pkgs; [
  {
    name = "chromium";
    packages = [chromium];
    macAddress = "02:00:00:03:03:05";
    ramMb = 3072;
    cores = 4;
  }
  {
    name = "gala";
    packages = [(pkgs.callPackage ../packages/gala {})];
    macAddress = "02:00:00:03:03:06";
    ramMb = 1536;
    cores = 2;
  }
  {
    name = "zathura";
    packages = [zathura];
    macAddress = "02:00:00:03:03:07";
    ramMb = 512;
    cores = 1;
  }
];
</code></pre>
<p>Each VM has the following properties:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Property</strong></th><th><strong>Type</strong></th><th><strong>Unique</strong></th><th><strong>Description</strong></th><th><strong>Example</strong></th></tr></thead><tbody>
<tr><td>name</td><td>str</td><td>yes</td><td>This name is postfixed with <code>-vm</code> and will be shown in microvm list. The name - e.g. <code>chromium-vm</code> will be also the VM hostname. The lenght of the name must be 8 characters or less.</td><td>‚Äúchromium‚Äù</td></tr>
<tr><td>packages</td><td>list of types.package</td><td>no</td><td>Packages to include in a VM. It is possible to make it empty or add several packages.</td><td>[chromium top]</td></tr>
<tr><td>macAddress</td><td>str</td><td>yes</td><td>Needed for network configuration.</td><td>"02:00:00:03:03:05"</td></tr>
<tr><td>ramMb</td><td>int, [1, ‚Ä¶, host memory]</td><td>no</td><td>Memory in MB.</td><td>3072</td></tr>
<tr><td>cores</td><td>int,  [1, ‚Ä¶, host cores]</td><td>no</td><td>Virtual CPU cores.</td><td>4</td></tr>
</tbody></table>
</div>
<h2 id="adding-application-launcher-in-gui-vm"><a class="header" href="#adding-application-launcher-in-gui-vm">Adding Application Launcher in GUI VM</a></h2>
<p>To add an application launcher, add an element in the <a href="https://github.com/tiiuae/ghaf/blob/main/modules/virtualization/microvm/guivm.nix">guivm.nix</a> file to the <strong>graphics.weston.launchers</strong> list.</p>
<p>A launcher element has two properties:</p>
<ul>
<li><strong>path</strong>‚Äìpath to the executable you want to run, like a graphical application;</li>
<li><strong>icon</strong>‚Äìpath to an icon to show.</li>
</ul>
<p>Check the example launchers at <a href="https://github.com/tiiuae/ghaf/blob/main/modules/virtualization/microvm/guivm.nix">guivm.nix</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="labwc-desktop-environment"><a class="header" href="#labwc-desktop-environment">labwc Desktop Environment</a></h1>
<p><a href="https://labwc.github.io/">labwc</a> is a configurable and lightweight wlroots-based Wayland-compatible desktop environment.</p>
<p>To use labwc as your default desktop environment, add it as a module to Ghaf:</p>
<ul>
<li>change the configuration option <code>profiles.graphics.compositor = "labwc"</code>
or</li>
<li>uncomment the corresponding line in the <a href="https://github.com/tiiuae/ghaf/blob/main/modules/virtualization/microvm/guivm.nix">guivm.nix</a> file.</li>
</ul>
<p>The basis of the labwc configuration is the set of following files: <code>rc.xml</code>, <code>menu.xml</code>, <code>autostart</code>, and <code>environment</code>. These files can be edited by substituting in the labwc overlay <code>overlays/custom-packages/labwc/default.nix</code>.</p>
<h2 id="window-border-coloring"><a class="header" href="#window-border-coloring">Window Border Coloring</a></h2>
<p>The border color concept illustrates the application trustworthiness in a user-friendly manner. The color shows the application's security level and allows avoiding user's mistakes. The same approach can be found in other projects, for example, <a href="https://www.qubes-os.org/doc/getting-started/#color--security">QubeOS</a>.</p>
<p>Ghaf uses patched labwc which makes it possible to change the border color for the chosen application. The implementation is based on window rules by substituting the server decoration colors (<code>serverDecoration</code> = <code>yes</code>). The <code>borderColor</code> property is responsible for the frame color.</p>
<blockquote>
<p><strong>TIP:</strong> According to the labwc specification, the <strong>identifier</strong> parameter is case-sensitive and relates to app_id for native Wayland windows and WM_CLASS for XWayland clients.</p>
</blockquote>
<p>For example, the foot terminal with Aqua colored frame:</p>
<pre><code>&lt;windowRules&gt;
  &lt;windowRule identifier="Foot" borderColor="#00FFFF" serverDecoration="yes" skipTaskbar="yes"  /&gt;
  &lt;windowRule identifier="firefox" borderColor="#FF0000" serverDecoration="yes" skipTaskbar="yes"  /&gt;
&lt;/windowRules&gt;
</code></pre>
<p><img src="ref_impl/../img/colored_foot_frame.png" alt="Foot Terminal with Aqua Colored Frame" /></p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="ghaf-as-library-templates"><a class="header" href="#ghaf-as-library-templates">Ghaf as Library: Templates</a></h1>
<p>Ghaf is a framework for creating virtualized edge devices, it is therefore expected that projects wishing to use Ghaf should import it to create a derived work for the specific use case.</p>
<p>In practice, projects should import Ghaf and its dependencies into an external version control (git) repository. Ghaf provides templates for the reference hardware to ease this process. In this section:</p>
<ul>
<li>overview of Ghaf usage and upstream dependencies</li>
<li>required steps to create a Ghaf-based project</li>
<li>updating the project to get the latest changes</li>
<li>customization of the project using Ghaf-modules and Nix-supported mechanisms</li>
</ul>
<p>The possible Ghaf usage in your project is illustrated in the following diagram:</p>
<p><img src="ref_impl/../img/usage_overview.drawio.png" alt="Ghaf Usage Overview" title="Your project and example inputs from Ghaf and other repositories" /></p>
<p>The Ghaf Platform repository provides declarative modules and reference implementations to help with declaring your customized secure system.</p>
<p>External repositories help make various HW options, system image generators, and reference board-support packages available.</p>
<h2 id="using-ghaf-templates"><a class="header" href="#using-ghaf-templates">Using Ghaf Templates</a></h2>
<ol>
<li>
<p>Check the available target templates:</p>
<pre><code>nix flake show github:tiiuae/ghaf
</code></pre>
</li>
<li>
<p>Select the appropriate template based on reference implementation, for example, <code>target-aarch64-nvidia-orin-agx</code>:</p>
<pre><code>nix flake new --template github:tiiuae/ghaf#target-aarch64-nvidia-orin-agx ~/ghaf-example
wrote: ~/ghaf-example/flake.nix
</code></pre>
</li>
<li>
<p>See your project template outputs:</p>
<pre><code>cd ~/ghaf-example/
nix flake show
git+file://~/ghaf-example
‚îú‚îÄ‚îÄ‚îÄformatter
‚îÇ   ‚îú‚îÄ‚îÄ‚îÄaarch64-linux: package 'alejandra-3.0.0'
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄx86_64-linux: package 'alejandra-3.0.0'
‚îú‚îÄ‚îÄ‚îÄnixosConfigurations
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄPROJ_NAME-ghaf-debug: NixOS configuration
‚îî‚îÄ‚îÄ‚îÄpackages
‚îú‚îÄ‚îÄ‚îÄaarch64-linux
‚îÇ   ‚îî‚îÄ‚îÄ‚îÄPROJ_NAME-ghaf-debug: package 'nixos-disk-image'
‚îî‚îÄ‚îÄ‚îÄx86_64-linux
‚îî‚îÄ‚îÄ‚îÄPROJ_NAME-ghaf-debug-flash-script: package 'flash-ghaf'
</code></pre>
</li>
<li>
<p>Change the placeholder <code>&lt;PROJ NAME&gt;</code> to the name of your project <code>your_project</code>:</p>
<pre><code>sed -i 's/PROJ_NAME/your_project/g' flake.nix
</code></pre>
</li>
</ol>
<h2 id="updating-ghaf-revision"><a class="header" href="#updating-ghaf-revision">Updating Ghaf Revision</a></h2>
<p>To update your project, run <code>nix flake update</code>. This checks the inputs for updates and based on the availability of the updates, and then generates an updated <code>flake.lock</code> which locks the specific versions to support the reproducible builds without side effects.</p>
<p>In practice, a Nix flake does not allow floating inputs but all the inputs and declared packages must be mapped to specific hashes to get exact revisions of your inputs. This mechanism also supports the supply-chain security: if someone changes the upstream project, for example, by overwriting a part of the input so that the hash changes, you will notice.</p>
<p>After updating, reviewing, and testing: commit the updated <code>flake.lock</code> to your version history to share reproducible builds within your project.</p>
<h2 id="customizing-ghaf-modules"><a class="header" href="#customizing-ghaf-modules">Customizing Ghaf Modules</a></h2>
<p>To use the Ghaf declarative module system, check what you need in your system and choose the <a href="ref_impl/./modules_options.html">modules options</a> you need. For example, import the ghaf <code>graphics</code>-module and declare that you will need the reference Wayland compositor Weston and the demo applications:</p>
<pre><code>          {
            ghaf.graphics.weston = {
              enable = false;
              enableDemoApplications = false;
            };
          }
</code></pre>
<p>After the change, rebuild the system and switch it into use in your target device and it will run with the GUI and apps removed. After testing, you can commit the changes and share them with your colleagues to build the same system (even a system image) as needed in your project.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="example-project"><a class="header" href="#example-project">Example Project</a></h1>
<p>The compartmentalization could be applied to many specific x86_64 computers and laptops with some customization applied to the Ghaf.</p>
<p>The best way to do the Ghaf customization is by using Ghaf templates:</p>
<ol>
<li>Create a template project as described in the <a href="ref_impl/../ref_impl/ghaf-based-project.html">Ghaf as Library</a> section.</li>
<li>Adjust your system configuration in accordance with your HW specification. Determine all VIDs and PIDs of the devices that are passed to the VMs.</li>
<li>Add GUIVM configuration, NetworkVM configuration, and optionally some AppVMs.</li>
<li>Set up Weston panel shortcuts.</li>
</ol>
<p>You can refer to the existing <a href="https://github.com/unbel13ver/ghaf-lib">project example for Lenovo T14 and Lenovo X1 laptops</a>.</p>
<p>Creating the structure that includes all necessary data for the device passthrough:</p>
<pre><code># File 'my-hardware/lenovo-t14.nix':
# Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
# SPDX-License-Identifier: Apache-2.0
#
# Generic x86_64 computer -target
{
  deviceName = "lenovo-t14";
  networkPciAddr = "0000:00:14.3";
  networkPciVid = "8086";
  networkPciPid = "02f0";
  gpuPciAddr = "0000:00:02.0";
  gpuPciVid = "8086";
  gpuPciPid = "9b41";
  usbInputVid = "046d";
  usbInputPid = "c52b";
}
</code></pre>
<p>The fields of that structure are self-explanatory. Use the <code>lspci -nnk</code> command to get this data from any Linux OS running on the device.</p>
<h2 id="troubleshooting-for-lenovo-x1-laptop"><a class="header" href="#troubleshooting-for-lenovo-x1-laptop">Troubleshooting for Lenovo X1 Laptop</a></h2>
<p>If after booting you see a black screen, try the following to detect the issue:</p>
<ol>
<li>Add a Wi-Fi network name and password to the <em>lenovo-x1-carbon.nix</em> file instead of <code>#networks."ssid".psk = "psk"</code>.</li>
<li>Build and run the image. For more information, see <a href="ref_impl/./build_and_run.html#running-ghaf-image-for-lenovo-x1">Running Ghaf Image for Lenovo X1</a>.</li>
<li>Identify an IP address by a MAC address with the <code>arp</code> command. If a MAC address is unknown, you can boot into the NixOS image or any other OS to find it, or try the latest addresses that <code>arp</code> returns.</li>
<li>Connect using SSH (login/password ghaf/ghaf). Then connect from netvm to the host using <code>ssh 192.168.101.2</code> (login/password ghaf/ghaf).</li>
<li>Check running VMs with <code>microvm -l</code>.</li>
<li>Check a GUIVM log using <code>journalctl -u microvm@guivm</code>.</li>
<li>If GUIVM does not start, you can try to start it manually with <code>/var/lib/microvms/guivm/current/bin/microvm-run</code>.</li>
</ol>
<p>In case when GUIVM did not start with the error message that the device /dev/mouse or /dev/touchpad was not found, it means that the model of the touchpad in the laptop is different since it was bought in another country and has a different SKU (stock keeping unit). To add support for a new touchpad, do the following:</p>
<ol>
<li>
<p>On the ghaf host, check the devices in <code>/dev/input/by-path</code> that contain ‚Äú-event-‚Äù in the name. Use the command like <code>udevadm info -q all -a /dev/input/by-path/pci-0000:00:15.0-platform-i2c_designware.0-event-mouse | grep name</code> for the name of each of these devices.</p>
<blockquote>
<p>By name you can understand which devices belong to the touchpad. For example, on laptops in Finland they look like ‚ÄúSYNA8016:00 06CB:CEB3 Mouse‚Äù and ‚ÄúSYNA8016:00 06CB:CEB3 Touchpad‚Äù, and in the UAE they are ‚ÄúELAN067C:00 04F3:31F9 Mouse‚Äù and ‚ÄúELAN067C:00 04F3:31F9 Touchpad.‚Äù</p>
</blockquote>
</li>
<li>
<p>If there are no such devices in <code>/dev/input/by-path</code>, then you can check the devices /dev/input/event* with a similar command.</p>
</li>
<li>
<p>When the necessary device names are found, add them to <code>services.udev.extraRules</code> in the <em>lenovo-x1-carbon.nix</em> file, rebuild the image and test the changes.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<!--
    If you want to change this file, check https://github.com/tiiuae/ghaf/pull/183.
-->
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="technologies"><a class="header" href="#technologies">Technologies</a></h1>
<p>Embedded virtualization builds on technologies from cloud security. Cloud services provide scalable but isolated computation ‚Äî your business case is isolated from someone else's business case.</p>
<p>At the hardware level. Similarly, hardware support in modern personal devices has enabled the isolation of device resources with virtualization. This provides the baseline for secure system design for use case protection.</p>
<p>In practice, the user can use the same device with a trusted application and with an untrusted application. Both applications are isolated from each other to protect valuable user data and privacy.</p>
<p>Our systems are built using <a href="https://github.com/NixOS/nixpkgs">Nixpkgs</a> and various <a href="https://nixos.org/guides/nix-language.html">Nix</a>-based tools and configurations. For more information on Nix ecosystem, see <a href="https://nix.dev/">nix.dev</a>.</p>
<h2 id="hardware-requirements-for-virtualization"><a class="header" href="#hardware-requirements-for-virtualization">Hardware Requirements for Virtualization</a></h2>
<p>Protected computation resources include CPU, memory, storage, and other IO devices. Allocation of these resources is managed with the hypervisor.</p>
<p>In our reference implementation, we use KVM (Kernel Virtual Machine) from Linux to virtualize hardware access. From hardware, this requires MMU (memory management unit) for CPU physical to virtual address mapping and IOMMU for direct memory access (DMA) capable device virtual addresses to physical addresses of the main memory. Many 64-bit CPUs support virtualization via hypervisor extensions already. Our reference implementation supports x86-64 and Aarch64, and we follow RISC-V hypervisor extensions development.</p>
<h2 id="virtual-machine-manager-vmm"><a class="header" href="#virtual-machine-manager-vmm">Virtual Machine Manager (VMM)</a></h2>
<p>On top of OS kernel hypervisor support with KVM. We allocate virtual resources for use cases with user-space virtual machine manager (VMM) using <a href="https://github.com/rust-vmm">rust-vmm</a> based projects such as <a href="https://github.com/cloud-hypervisor/cloud-hypervisor">cloud-hypervisor</a> and <a href="https://github.com/google/crosvm">crosvm</a>. <a href="https://www.qemu.org/">QEMU</a> is enabled for certain development use cases.</p>
<p>In addition, we have also experimental, Aarch64 demonstrated support for a KVM variant‚Äî<a href="https://github.com/jkrh/kvms">KVMS</a>‚Äîwhich adds security features to standard KVM.</p>
<h2 id="in-this-chapter-2"><a class="header" href="#in-this-chapter-2">In This Chapter</a></h2>
<ul>
<li><a href="technologies/./compartment.html">Compartmentalization</a></li>
<li><a href="technologies/./passthrough.html">Passthrough</a>
<ul>
<li><a href="technologies/./vfio.html">Binding Device to VFIO Driver</a></li>
<li><a href="technologies/./nvidia_agx_pt_uart.html">NVIDIA Jetson AGX Orin: UART Passthrough</a></li>
<li><a href="technologies/./nvidia_agx_pt_pcie.html">NVIDIA Jetson AGX Orin: PCIe Passthrough</a></li>
<li><a href="technologies/./x86_pcie_crosvm.html">Generic x86: PCIe Passthrough on crosvm</a></li>
</ul>
</li>
<li><a href="technologies/./nvidia_virtualization_bpmp.html">NVIDIA Jetson AGX Orin: Boot and Power Management Processor Virtualization</a></li>
<li><a href="technologies/./hypervisor_options.html">Hypervisor Options</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="compartmentalization"><a class="header" href="#compartmentalization">Compartmentalization</a></h1>
<p>Compartmentalization is the technique of separating parts of a system to decrease attack surface and prevent malfunctions from cascading in the system. In Ghaf architecture, there is a separate VM for every vital function of the system.</p>
<p>Current implementation supports GUI VM, <a href="technologies/../architecture/adr/netvm.html">Networking VM</a> and a couple of Application VMs, such as the Chromium web browser and the Zathura document viewer.</p>
<p>The GUI VM owns a computer's GPU and performs desktop environment and application windows rendering. Wayland protocol for applications in this case is proxified by <code>waypipe</code> over SSH. This approach is used temporarily before moving to more sophisticated solutions.</p>
<p>A VM compartmentalization requires all necessary devices passthrough in place. More specifically, you need to know the PCI VID and PID of a device and also its number on the PCI bus. In the case of a USB device passthrough, it is enough to know the device's VID and PID.</p>
<p>For more information on actual implementation, see <a href="technologies/../ref_impl/ghaf-based-project.html">Ghaf as Library</a> and <a href="technologies/../ref_impl/creating_appvm.html">Creating Application VM</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="devices-passthrough"><a class="header" href="#devices-passthrough">Devices Passthrough</a></h1>
<p>Devices passthrough to virtual machines (VM) allows us to isolate the device drivers
and their memory access in one or several VMs. This reduces the Trusted Code Base (TCB) in the host, due to the passed-through device drivers can be removed completely from the host kernel.</p>
<p>Whether the device platform is x86 or ARM, the passthrough device needs to be bound to the VFIO device driver by the host system before it can be passed through to the guest environment. For more information, see <a href="technologies/vfio.html">Binding Device to VFIO Driver</a>.</p>
<p>Our current supported passthrough devices implementations:</p>
<ul>
<li><a href="technologies/nvidia_agx_pt_uart.html">NVIDIA Jetson AGX Orin: UART Passthrough</a></li>
<li><a href="technologies/nvidia_agx_pt_pcie.html">NVIDIA Jetson AGX Orin: PCIe Passthrough</a></li>
<li><a href="technologies/x86_pcie_crosvm.html">Generic x86: PCIe Passthrough on crosvm</a></li>
<li><a href="technologies/nvidia_uarti_net_vm.html">NVIDIA Jetson: UARTI Passthrough to netvm</a></li>
<li><a href="technologies/device_tree_overlays_pt.html">Device Tree Overlays for Passthrough</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="binding-devices-to-vfio-driver-to-allow-passthrough"><a class="header" href="#binding-devices-to-vfio-driver-to-allow-passthrough">Binding Devices to VFIO Driver to Allow Passthrough</a></h1>
<p>An example of binding a PCI device to the VFIO driver manually:</p>
<pre><code>export DEVICE="0001:01:00.0"
export VENDOR_ID=$(cat /sys/bus/pci/devices/$DEVICE/vendor)
export DEVICE_ID=$(cat /sys/bus/pci/devices/$DEVICE/device)

echo "$DEVICE" &gt; /sys/bus/pci/devices/$DEVICE/driver/unbind

echo "$VENDOR_ID $DEVICE_ID" &gt; /sys/bus/pci/drivers/vfio-pci/new_id
</code></pre>
<p>Similar approach also works for platform devices. The device path for platform
devices is <code>/sys/bus/platform/devices/$DEVICE/</code>.</p>
<pre><code>export DEVICE="31d0000.serial"
echo vfio-platform &gt; /sys/bus/platform/devices/$DEVICE/driver_override
echo "$DEVICE" &gt; /sys/bus/platform/drivers/vfio-platform/bind
</code></pre>
<h2 id="using-driverctl-package"><a class="header" href="#using-driverctl-package">Using driverctl Package</a></h2>
<p><a href="https://gitlab.com/driverctl/driverctl">driverctl</a> is an open-source device
driver control utility for Linux systems. With <code>driverctl</code> it is easier to set
up VFIO or change the driver for a device:</p>
<pre><code>export DEVICE="0001:01:00.0"
driverctl --nosave set-override ${DEVICE} vfio-pci
</code></pre>
<p>or for platform bus device passthrough</p>
<pre><code>export DEVICE="31d0000.serial"
driverctl --nosave --bus platform set-override ${DEVICE} vfio-platform
</code></pre>
<p>It is important to note that by default <code>driverctl</code> stores the set driver
overrides and reactivates the override after a device reboot. With VFIO this
can cause issues since some hardware devices may be required while the device
starts up. This behavior can be effected by using the <code>--nosave</code> option as in
the example above so that the override is reset back to default at reboot.</p>
<p>The <code>driverctl</code> tool also features a way to list devices based on their bus type
with the <code>list-devices</code> command.</p>
<pre><code># Default usage of the tool is for pci bus
driverctl list-devices

# Using command line option --bus platform sets the usage for platform bus
driverctl --bus platform list-devices
</code></pre>
<p>driverctl can also reset the default driver by using the <code>unset-override</code>
command.</p>
<pre><code>export DEVICE="0001:01:00.0"
driverctl unset-override ${DEVICE}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="nvidia-jetson-agx-orin-uart-passthrough"><a class="header" href="#nvidia-jetson-agx-orin-uart-passthrough">NVIDIA Jetson AGX Orin: UART Passthrough</a></h1>
<p>This document describes the UART passthrough implementations on the NVIDIA Jetson AGX Orin board. The goal of this document is to guide more complex devices passthrough implementations.</p>
<h2 id="uart-connections"><a class="header" href="#uart-connections">UART Connections</a></h2>
<p>There are eight UART units in the System on Chip (SoC) and two Server Base System Architecture (SBSA) UART units:</p>
<ul>
<li>The SoC UART units are named with an alphabetical suffix:
<ul>
<li>UARTA, UARTB, UARTC, UARTD, UARTE, UARTF, UARTG, UARTH (which may be referred to as UART1, UART2, UART3, UART4, UART5, UART6, UART7, and UART8).</li>
</ul>
</li>
<li>The SBRA UART units are named UARTI and UARTJ. These units are pin-muxed with the UARTE and UARTC respectively.</li>
</ul>
<p>The following table describes the UART units mapping and connections:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Device tree def.</strong></th><th style="text-align: center"><strong>CPU pin</strong></th><th style="text-align: center"><strong>SoC pin</strong></th><th><strong>Connected to</strong></th></tr></thead><tbody>
<tr><td>uarta: serial@3100000</td><td style="text-align: center">UART1</td><td style="text-align: center">UART1</td><td>40 pin header 3v3</td></tr>
<tr><td>uartb: serial@3110000</td><td style="text-align: center">UART2</td><td style="text-align: center">UART5</td><td>M.2 key E (WiFi card)</td></tr>
<tr><td>uartc: serial@c280000</td><td style="text-align: center">UART3</td><td style="text-align: center">UART3</td><td>USB Debug ttyACM0</td></tr>
<tr><td>uartd: serial@3130000</td><td style="text-align: center">UART4</td><td style="text-align: center">UART4</td><td>Camera connector</td></tr>
<tr><td>uarte: serial@3140000</td><td style="text-align: center">Not mapped</td><td style="text-align: center"></td><td></td></tr>
<tr><td>uartf: serial@3150000</td><td style="text-align: center">Not mapped</td><td style="text-align: center"></td><td></td></tr>
<tr><td>uartg: not on dtb</td><td style="text-align: center">UART7</td><td style="text-align: center">UART7</td><td>Optional, USB Debug ttyACM1</td></tr>
<tr><td>uarth: serial@3170000</td><td style="text-align: center">Not mapped</td><td style="text-align: center"></td><td></td></tr>
<tr><td>uarti: serial@31d0000</td><td style="text-align: center">UART5</td><td style="text-align: center">UART2</td><td>USB Debug ttyACM1</td></tr>
<tr><td>uartj: serial@c270000</td><td style="text-align: center">Not mapped</td><td style="text-align: center"></td><td></td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ul>
<li>The first column shows how the UART units are defined in the UART device tree file <em>tegra234-soc-uart.dtsi</em> <sup class="footnote-reference"><a href="#note1">1</a></sup>.</li>
<li>The second and third columns show the CPU and SoC pin connections. Note that for UART2 and UART5 these are swapped. The pin mapping configuration is described in the file <em>tegra234-mb1-bct-pinmux-p3701-0000.dtsi</em> <sup class="footnote-reference"><a href="#note2">2</a></sup>. This device tree file is automatically generated by the macro Excel file <em>Jetson_AGX_Orin_Series_Pinmux_Config_Template_1.5.xlsm</em> which is available at the official Jetson Download Center as the <em>Jetson AGX Orin Series Pinmux</em>.</li>
<li>The last column describes where the UART units are connected to the exterior.</li>
</ul>
<blockquote>
<p>Only two UART units are connected to the micro USB debug interface. The UART7 is not connected by default but it can be connected to the debug interface ttyACM1 by swapping the fuse resistors (see Debug MCU page 7 on P3737_A04_Concept_schematics.pdf <sup class="footnote-reference"><a href="#note3">3</a></sup>).</p>
</blockquote>
<h2 id="uarti-selected-for-passthrough"><a class="header" href="#uarti-selected-for-passthrough">UARTI Selected for Passthrough</a></h2>
<p>The UARTI unit was selected to do the first "Hello world" passthrough implementation as it does not show any dependencies on its device tree:</p>
<pre><code class="language-cpp">	uarti: serial@31d0000 {
		compatible = "arm,sbsa-uart";
		reg = &lt;0x0 0x31d0000 0x0 0x10000&gt;;
		interrupts = &lt;0x0 TEGRA234_IRQ_UARTI 0x04&gt;;
		current-speed = &lt;115200&gt;;
		status = "disabled";
	};
</code></pre>
<h2 id="host-device-tree"><a class="header" href="#host-device-tree">Host Device Tree</a></h2>
<p>To prepare the UARTI on the host for the passthrough:</p>
<ol>
<li>
<p>Modify the UARTI node in the <em>tegra234-soc-uart.dtsi</em> device tree file <sup class="footnote-reference"><a href="#note1">1</a></sup>:</p>
<ul>
<li><strong>compatible:</strong> put a dummy driver associated to this node so that the kernel will not bind any driver to this UART unit.</li>
<li><strong>iommus:</strong> add the iommus field with the test stream ID <em>TEGRA_SID_NISO1_SMMU_TEST</em> which by default is not used by any other device.</li>
</ul>
<pre><code class="language-cpp">	uarti: serial@31d0000 {
		compatible = "arm,dummy";
		iommus = &lt;&amp;smmu_niso0 TEGRA_SID_NISO1_SMMU_TEST&gt;;
		reg = &lt;0x0 0x31d0000 0x0 0x10000&gt;;
		interrupts = &lt;0x0 TEGRA234_IRQ_UARTI 0x04&gt;;
		current-speed = &lt;115200&gt;;
		status = "disabled";
	};
</code></pre>
</li>
<li>
<p>Include the modifications, compile the kernel to update the output DTB, and then flash it to the internal eMMC device tree A and B partitions with the following command:</p>
<pre><code>dd if=./arch/arm64/boot/dts/nvidia/tegra234-p3701-0000-p3737-0000.dtb of=/dev/mmcblk0p3
dd if=./arch/arm64/boot/dts/nvidia/tegra234-p3701-0000-p3737-0000.dtb of=/dev/mmcblk0p6
</code></pre>
</li>
</ol>
<h2 id="guest-device-tree"><a class="header" href="#guest-device-tree">Guest Device Tree</a></h2>
<p>The guest device tree is based on the device tree extracted from QEMU VM.</p>
<p>To get the base QEMU device tree, run the following command:</p>
<pre><code>qemu-system-aarch64 -machine virt,accel=kvm,dumpdtb=virt.dtb -cpu host
</code></pre>
<p>Add the passthrough devices inside the platform node to this device tree:</p>
<pre><code class="language-cpp">	platform@c000000 {
		interrupt-parent = &lt;0x8001&gt;;
		ranges = &lt;0xc000000 0x00 0xc000000 0x2000000&gt;;
		#address-cells = &lt;0x01&gt;;
		#size-cells = &lt;0x01&gt;;
		compatible = "qemu,platform\0simple-bus";

		uarti: serial@c000000 {
		    compatible = "arm,sbsa-uart";
		    current-speed = &lt;0x1c200&gt;;
		    interrupts = &lt;0x00 0x70 0x04&gt;;
		    reg = &lt;0x0c000000 0x10000&gt;;
		    status = "okay";
        	};
	};
</code></pre>
<blockquote>
<p>In this example, the <em>uarti</em> node was added to the platform node. For this node the interrupt number was replaced to 0x70 and reg address to the one that was obtained from the QEMU monitor command: <em>info mtree -f</em>.</p>
</blockquote>
<h2 id="starting-guest-vm"><a class="header" href="#starting-guest-vm">Starting Guest VM</a></h2>
<p>To start the guest VM:</p>
<ol>
<li>
<p>Bind the UARTI to the VFIO driver:</p>
<pre><code>echo vfio-platform &gt; /sys/bus/platform/devices/31d0000.serial/driver_override
echo 31d0000.serial &gt; /sys/bus/platform/drivers/vfio-platform/bind
</code></pre>
<p>The VFIO gives the user-level an access to the devices, in this case, QEMU.</p>
</li>
<li>
<p>Connect the NVIDIA Jetson AGX Orin Debug USB to your PC and open the serial port ttyACM1 at 115200 bps. You can use picocom with the next command:</p>
<pre><code>picocom -b 115200 /dev/ttyACM1
</code></pre>
</li>
<li>
<p>Run the guest VM with the following QEMU command:</p>
<pre><code>qemu-system-aarch64 \
    -nographic \
    -machine virt,accel=kvm \
    -cpu host \
    -m 1024 \
    -no-reboot \
    -kernel Image \
    -drive file=focal-server-cloudimg-arm64.raw,if=virtio,format=raw \
    -device vfio-platform,host=31d0000.serial\
    -dtb uart.dtb \
    -append "rootwait root=/dev/vda1 console=ttyAMA0"
</code></pre>
</li>
</ol>
<p>When the guest VM is launched you can see the VM Linux command line in the opened ttyACM1 terminal.</p>
<div class="footnote-definition" id="note1"><sup class="footnote-definition-label">1</sup>
<p>kernel_src/hardware/nvidia/soc/t23x/kernel-dts/tegra234-soc/tegra234-soc-uart.dtsi</p>
</div>
<div class="footnote-definition" id="note2"><sup class="footnote-definition-label">2</sup>
<p>bootloader/t186ref/BCT/tegra234-mb1-bct-pinmux-p3701-0000.dtsi available in the BSP sources on: https://developer.nvidia.com/embedded/jetson-linux-r3521</p>
</div>
<div class="footnote-definition" id="note3"><sup class="footnote-definition-label">3</sup>
<p>Jetson_AGX_Orin_DevKit_Carrier_Board_Design_Files_A04_20221003/P3737_A04_Concept_schematics.pdf available in https://developer.nvidia.com/jetson-agx-orin-developer-kit-carrier-board-design-files-a04</p>
</div>
<div style="break-before: page; page-break-before: always;"></div> <!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="nvidia-jetson-agx-orin-pcie-passthrough"><a class="header" href="#nvidia-jetson-agx-orin-pcie-passthrough">NVIDIA Jetson AGX Orin: PCIe passthrough</a></h1>
<p>This document describes the PCIe passthrough implementations on the NVIDIA Jetson AGX Orin board. The goal of this document is to give an overview of passing through different PCIe devices and the limitations of PCIe in the board.</p>
<h2 id="pcie-slots-in-nvidia-jetson-agx-orin"><a class="header" href="#pcie-slots-in-nvidia-jetson-agx-orin">PCIe Slots in NVIDIA Jetson AGX Orin</a></h2>
<p>There are two (or actually three) PCIe slots in the Jetson AGX Orin board:</p>
<ul>
<li>One of the connectors is a <a href="technologies/nvidia_agx_pt_pcie.html#full-size-pcie-slot">full-size PCIe 8x slot</a> located under a black plastic cover above the micro USB serial debug port on the side of the board.</li>
<li>The other slot is a <a href="technologies/nvidia_agx_pt_pcie.html#pcie-m2-slot">smaller M.2 slot</a> that is located at the bottom of the board. By default, the slot is in use of the included Wi-Fi and Bluetooth module.</li>
<li>The third slot is actually an <a href="technologies/nvidia_agx_pt_pcie.html#pcie-m2-nvme-2247-for-ssd">NVMe slot</a> which can be used to add an NVMe SSD to the board.</li>
</ul>
<blockquote>
<p>For more information on the board's connections details, see the <a href="https://developer.nvidia.com/embedded/learn/jetson-agx-orin-devkit-user-guide/developer_kit_layout.html">Hardware Layout</a> section of the Jetson AGX Orin Developer Kit User Guide.</p>
</blockquote>
<p>When using one of the slots:</p>
<ul>
<li>First and foremost, always turn off and disconnect any power sources from the board and its peripherals when connecting or disconnecting devices to any of the PCIe buses connect.</li>
<li>When adding or removing devices to the board, there is always a risk of setting off an electrical discharge in one of the components which may damage the connected device or the board itself.</li>
</ul>
<h4 id="full-size-pcie-slot"><a class="header" href="#full-size-pcie-slot">Full-Size PCIe Slot</a></h4>
<p>The full-size PCIe connector is under the black plastic cover on one of the sides of the device. The cover is held in place with a fairly strong magnet. There is a small connector ribbon and a few delicate wires going from the board internals to a Wi-Fi antenna on the cover.</p>
<blockquote>
<p><strong>TIP:</strong> Make sure to remove the cover carefully for not ripping the whole cover off along with the antenna cables.</p>
</blockquote>
<p>The PCIe slot is simular to one inside a desktop computer. One key difference: the Jetson AGX Orin board has limited 12V power output capabilities and can only output a maximum of 40W power to its PCIe slot. Regular desktop PCIe slot can output 75W at 12V so some more power-hungry PCIe cards <sup class="footnote-reference"><a href="#note1">1</a></sup> may not work with the Jetson AGX Orin board. There may also be a risk of damaging the board if a card tries to pull too much power from the PCIe socket.</p>
<blockquote>
<p><strong>TIP:</strong> We recommend to check carefully the power requirements of a device before turning the device on.</p>
</blockquote>
<p>A good rule of thumb might be if the device has a cooler to actively cool it down then some care should be taken before starting to use the card. Some trials have been done with GPU devices that use at maximum 30-34W power. The devices seem to work well in Jetson AGX Orin, but it is difficult to say how much power the card actually pulls from the slot at any given time. No real performance or stress tests have been done but under usual GUI and simple 3d application usage the cards (NVIDIA Quadro P1000 and NVIDIA Quadro T600) seem to work fine.</p>
<h4 id="pcie-m2-slot"><a class="header" href="#pcie-m2-slot">PCIe M.2 Slot</a></h4>
<p>The PCIe M.2 slot with key type A+E is at the bottom of the board. By default, this slot is in use of the internal Wi-Fi and Bluetooth card. There are different types of M.2 slots all of which are not compatible with one another. The slot in Jetson AGX Orin is type A+E, and it supports PCIe 2x and USB transport buses.</p>
<h4 id="pcie-m2-nvme-for-ssd"><a class="header" href="#pcie-m2-nvme-for-ssd">PCIe M.2 NVMe for SSD</a></h4>
<p>The third slot is M.2 NVMe 2280 (22 mm width and 80 mm length) and can be used for NVMe SSD. Passing through this interface has not been tested as the SSD is in most cases used by the host.</p>
<h2 id="enabling-pcie-devices-for-vfio"><a class="header" href="#enabling-pcie-devices-for-vfio">Enabling PCIe Devices for VFIO</a></h2>
<p>As in the <a href="technologies/nvidia_agx_pt_uart.html">UART Passthrough</a>, the default device tree requires some modifications.</p>
<p>With the default configuration, the PCI devices are set to the same VFIO group as the PCI bus itself. The trouble here is that the PCI bus is a platform bus device which is a bit tricky to pass through to the guest. It is possible to pass through only the individual PCI devices and not the whole bus.</p>
<p>To pass through individual PCI devices one by one, set the devices in their individual VFIO groups or remove the PCI bus from the same VFIO group:</p>
<pre><code class="language-cpp">/*
 * Modify the 'pcie_c1_rp' pci-e bus by removing its
 * iommu group definition.
 * This is to remove the pci bus from vfio group which
 * leaves the m2 pci device alone in the group.
 * This change is for the m2 pci-e "wifi" slot.
  */
&amp;pcie_c1_rp {
    /delete-property/ iommus;
};

/*
 * Modify the 'pci_c5_rp' pci bus by removing its
 * iommu group definition.
 * This is to remove the pci bus from vfio group which
 * leaves the pci device alone in the group.
 * This change is for the full size pci-e slot.
 */
&amp;pcie_c5_rp {
    /delete-property/ iommus;
};
</code></pre>
<h3 id="binding-device-for-vfio"><a class="header" href="#binding-device-for-vfio">Binding Device for VFIO</a></h3>
<p>To set up the device for VFIO, unload the device driver and then replac it with the <code>vfio-pci</code> driver.</p>
<p>The example below can be used for a device in the PCI bus <code>0001</code>.<br />
The device <code>0001:01:00.0</code> in the first bus is the Jetson AGX Orin board with the M.2 Wi-Fi card. The full size PCI bus id is <code>0005</code>. It is possible that a single PCI card contains multiple devices. In that case, all the devices need to be passed through together as they are in the same VFIO group. Usually the graphics card also contains some sound output device as a separate device.</p>
<pre><code>export DEVICE="0001:01:00.0"
export VENDOR_ID=$(cat /sys/bus/pci/devices/$DEVICE/vendor)
export DEVICE_ID=$(cat /sys/bus/pci/devices/$DEVICE/device)

echo "$DEVICE" &gt; /sys/bus/pci/devices/$DEVICE/driver/unbind

echo "$VENDOR_ID $DEVICE_ID" &gt; /sys/bus/pci/drivers/vfio-pci/new_id
</code></pre>
<p>In case of success, this device is bound to VFIO. The VFIO nodes are usually owned by the root and in some cases may be group accessible by the VFIO group. To use the VFIO devices, the user who starts QEMU needs access to the VFIO device node:</p>
<pre><code># List of vfio device &lt;id&gt; nodes
ls /dev/vfio/

# List of devices within each iommu group
ls /sys/kernel/iommu_groups/&lt;id&gt;/devices/
</code></pre>
<p>You can also check the kernel logs to know which device belongs to which VFIO IOMMU group.</p>
<h2 id="starting-guest-vm-1"><a class="header" href="#starting-guest-vm-1">Starting Guest VM</a></h2>
<p>After binding a device to VFIO, you can access the device in a VM. To do so, use a command line argument (as in the example) for the PCI device to pass through to QEMU.</p>
<blockquote>
<p>It does not matter which VFIO node ID was assigned to the device earlier, as long as all the devices with the same VFIO node are passed through, and none of the devices in the same group is left behind.</p>
</blockquote>
<p>The QEMU command line argument for passthrough uses the PCIe device ID as identifier for the devices. Each
device which is passed through needs its own QEMU <code>-device</code> argument as below:</p>
<pre><code>-device vfio-pci,host="0001:01:00.0"
</code></pre>
<h3 id="arm64-pci-device-interrupts"><a class="header" href="#arm64-pci-device-interrupts">ARM64 PCI Device Interrupts</a></h3>
<p>Modern PCI devices use the Message Signaled Interrupts (MSI) method to limit the need for physical hardware interrupt pins. As passing through PCI or any other devices is fairly new to QEMU, it seems MSI in ARM64 is not supported by QEMU <sup class="footnote-reference"><a href="#note2">2</a></sup>.</p>
<p>To get interrupts to work in the guest, we need to signal the kernel to disable MSI for our passthrough device. There are two ways of doing it:</p>
<ol>
<li>To modify the host device tree by disabling MSI completely from the whole PCI bus.</li>
<li>To disable MSI only from the guest by using the <code>pci=nomsi</code> kernel argument with QEMU. Disabling MSI is not required for the x86 QEMU guest as it has MSI support.</li>
</ol>
<p>The command below is provided only as a test example for passing through a PCI device for AArch64 <sup class="footnote-reference"><a href="#note3">3</a></sup>:</p>
<pre><code>qemu-system-aarch64 \
    -nographic \
    -machine virt,accel=kvm \
    -cpu host \
    -m 1024 \
    -no-reboot \
    -kernel Image \
    -drive file=focal-server-cloudimg-arm64.raw,if=virtio,format=raw \
    -device vfio-pci,host=0001:01:00.0\
    -append "rootwait root=/dev/vda1 console=ttyAMA0 pci=nomsi"
</code></pre>
<h3 id="more-work-for-arm64"><a class="header" href="#more-work-for-arm64">More Work for ARM64</a></h3>
<p>The information above is enough for x86 and also for ARM64 processor architecture when using some simple or a bit older PCIe devices. A bit more complex PCIe device which has a larger internal RAM pool needs some modifications with QEMU sources.</p>
<p>The problem with passing through such devices is that the memory address range reserved for PCIe devices is not large enough to map the internal memory of the PCI device. Some graphics cards have several gigabytes of internal RAM which needs to be accessible for the VM guest.</p>
<p>You can extend the VIRT_PCIE_ECAM memory address range in the QEMU source code to allow mapping the whole PCIe device memory range. In most cases a few gigabytes is sufficient:</p>
<pre><code>diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index ac626b3bef..d6fb597aee 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -161,9 +161,10 @@ static const MemMapEntry base_memmap[] = {
     [VIRT_SECURE_MEM] =         { 0x0e000000, 0x01000000 },
     [VIRT_PCIE_MMIO] =          { 0x10000000, 0x2eff0000 },
     [VIRT_PCIE_PIO] =           { 0x3eff0000, 0x00010000 },
-    [VIRT_PCIE_ECAM] =          { 0x3f000000, 0x01000000 },
+    /* ..Reserved 11Gb range for pcie = 11*1024*1024*1024b */
+    [VIRT_PCIE_ECAM] =          { 0x40000000, 0x2C0000000 },
     /* Actual RAM size depends on initial RAM and device memory settings */
-    [VIRT_MEM] =                { GiB, LEGACY_RAMLIMIT_BYTES },
+    [VIRT_MEM] =                { 0x300000000, LEGACY_RAMLIMIT_BYTES },
 };

</code></pre>
<p>After these changes, compile QEMU and install it on the host system.</p>
<div class="footnote-definition" id="note1"><sup class="footnote-definition-label">1</sup>
<p>An example of a power-hungry card is a graphics accelerator card.</p>
</div>
<div class="footnote-definition" id="note2"><sup class="footnote-definition-label">2</sup>
<p>Our approach of using ARM as a VM host with passthroughs fairly new so it is hard to search for help or references online, but this bug <a href="https://bugs.launchpad.net/ubuntu/+source/libvirt/+bug/1832394">qemu-system-aarch64 error</a> seems to be close enough. The main hint of MSI not being fully supported yet by QEMU on ARM64 comes from the case when the device starts working only with MSI disabled from the guest kernel argument.</p>
</div>
<div class="footnote-definition" id="note3"><sup class="footnote-definition-label">3</sup>
<p>It may require some changes for real usage.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="x86-pcie-device-passthrough-with-crosvm"><a class="header" href="#x86-pcie-device-passthrough-with-crosvm">x86 PCIe Device Passthrough with crosvm</a></h1>
<h2 id="enabling-pcie-devices-for-vfio-with-driverctl"><a class="header" href="#enabling-pcie-devices-for-vfio-with-driverctl">Enabling PCIe Devices for VFIO with driverctl</a></h2>
<p>As with other passthroughs, first, we need to set the target device to use VFIO
driver. This can be done manually or by using the <a href="https://gitlab.com/driverctl/driverctl">driverctl</a> tool as below.</p>
<blockquote>
<p>Running driverctl requires root permissions.</p>
</blockquote>
<pre><code>export BUS="0000:01:00.0"
driverctl --nosave set-override ${BUS} vfio-pci
</code></pre>
<p>Let's consider the example of starting crosvm.</p>
<p>In some cases, crosvm may need privileged permissions to work properly. This
applies specially for passthrough hardware devices as vfio devices are
generally owned by the root user or the vfio group. For simplicity, it may be
easier to run crosvm as the root user but it is be possible to set up correct
permissions so that running as root is not needed.</p>
<p>Crosvm expects the device's system path as its <code>--vfio</code> argument.
The device identifier is different when comparing how passthrough devices are
refrenced in QEMU. Using the <code>guest-address</code> option is not strictly required
by the source documentation but it gives a bit more control for handling the
passthrough device on the guest side.</p>
<pre><code>export BUS="0000:01:00.0"
export GUESTBUS="00:08.0"
./target/debug/crosvm run \
        --mem=8192 \
        --block ./ubuntu-22.10.img \
        -i /boot/initrd.img-5.19.0-31-generic /boot/vmlinuz-5.19.0-31-generic \
        -p "root=/dev/vda2 loglevel=8 earlycon earlyprintk debug" \
        --vfio /sys/bus/pci/devices/${BUS},guest-address=${GUESTBUS},iommu=viommu
</code></pre>
<h2 id="reseting-driver-to-original-state-afterwards"><a class="header" href="#reseting-driver-to-original-state-afterwards">Reseting Driver to Original State Afterwards</a></h2>
<p>The driverctl tool can reset the original device driver afterward:</p>
<pre><code>export BUS="0000:01:00.0"
driverctl unset-override ${BUS}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="nvidia-jetson-orin-agx-uarti-passthrough-to-netvm"><a class="header" href="#nvidia-jetson-orin-agx-uarti-passthrough-to-netvm">NVIDIA Jetson Orin AGX: UARTI Passthrough to netvm</a></h1>
<p>This document describes the UARTI (UART port I) passthrough to the netvm in Ghaf.</p>
<p><strong>NOTE</strong>: This implementation works only with NVIDIA Jetson AGX Orin, as it is the only  NVIDIA
Jetson Orin with the UARTI port available.</p>
<h2 id="uarti-connection"><a class="header" href="#uarti-connection">UARTI Connection</a></h2>
<p>The UARTI is mapped as <em>serial@31d0000</em> in the device tree information. This UARTI is connected to
the NVIDIA Jetson AGX Orin Micro-USB debugging port (ttyACM1) with a default speed of 115200 bps.</p>
<p>For more information on the UART ports connections in NVIDIA Jetson AGX Orin,
see: <a href="technologies/nvidia_agx_pt_uart.html">NVIDIA Jetson AGX Orin: UART Passthrough</a></p>
<h2 id="uarti-passthrough-configuration"><a class="header" href="#uarti-passthrough-configuration">UARTI Passthrough Configuration</a></h2>
<p>This section describes how the UARTI passthrough is configured in Ghaf for microvm.
We recommend to read <a href="technologies/nvidia_agx_pt_uart.html">NVIDIA Jetson AGX Orin: UART Passthrough</a> before continuing.</p>
<p>The UARTI passthrough configuration declaration
<a href="technologies/../../../modules/jetpack/nvidia-jetson-orin/virtualization/passthrough/uarti-net-vm/default.nix">UARTI to netvm</a>
includes:</p>
<ul>
<li>The microvm QEMU extra argument to add the 31d0000.serial to the netvm.</li>
<li>The microvm QEMU extra argument to specify a custom device tree (dtb) for the
netvm that includes the 31d0000.serial as a platform device.</li>
<li>The microvm disable default serial console, to add virtual PCI serial console.</li>
<li>A binding service (bindSerial31d0000) for the 31d0000.serial in order to
bind this device to the VFIO driver to make it available to microvm.</li>
<li>A kernel patch to add a custom device tree (dtb) source code for the
netvm.</li>
<li>A device tree overlay to host device tree to assign an IOMMU to the 31d0000.serial
device, and also a dummy driver</li>
</ul>
<p>Note: Due to the Linux kernel being unable to use the console in two UART ports
of the same kind, a virtual PCI Serial console was used as QEMU console output.</p>
<p>Also, a new udev rule is defined to group all KVM devices that bind to VFIO in
the IOMMU group 59.</p>
<pre><code>services.udev.extraRules = ''
          # Make group kvm all devices that bind to vfio in iommu group 59
          SUBSYSTEM=="vfio",KERNEL=="59",GROUP="kvm"
        '';
</code></pre>
<p>The <em>passthroughs.uarti_net_vm.enable</em> flag enables the UARTI passthrough to the netvm.
Make sure to enable the flag as it allows access to netvm through the debugging USB port
when the SSH connection does not work.</p>
<pre><code>hardware.nvidia = {
	virtualization.enable = true;
	virtualization.host.bpmp.enable = false;
	passthroughs.host.uarta.enable = false;
	passthroughs.uarti_net_vm.enable = true;
};
</code></pre>
<p>Enable the <em>virtualization.enable</em> flag as well, as it is a pre-requirement
for <em>passthroughs.uarti_net_vm.enable</em>.</p>
<h2 id="testing-the-uarti-on-netvm"><a class="header" href="#testing-the-uarti-on-netvm">Testing the UARTI on netvm</a></h2>
<p>Connect the NVIDIA Jetson AGX Orin debug Micro-USB to your computer and open
the serial port on ttyACM1 at 115200 bps. Use Picocom with the next command:</p>
<pre><code>picocom -b 115200 /dev/ttyACM1
</code></pre>
<p>After the netvm boots, you will see the message:</p>
<pre><code>&lt;&lt;&lt; Welcome to NixOS 23.11pre-git (aarch64) - ttyAMA0 &gt;&gt;&gt;

Run 'nixos-help' for the NixOS manual.

net-vm login: 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="device-tree-overlays-for-passthrough"><a class="header" href="#device-tree-overlays-for-passthrough">Device Tree Overlays for Passthrough</a></h1>
<p>The device tree blob (DTB) is a data structure that describes the hardware
components of a particular system so that the operating system can use and manage
those components. For passthrough, the hardware description in the host needs
some modifications, which include:</p>
<ul>
<li>Removing the device's driver to passthrough by assigning a dummy string
to the <em>compatible</em> property.</li>
<li>Adding the <em>iommus</em> property to the device to passthrough.</li>
<li>Removing or adding other properties that cause conflicts during the passthrough.</li>
</ul>
<p>Modifying the host device tree could be done by applying patches
to DTS files. Nevertheless, this option is not
scalable if we need to apply different patches to the same .dts from
different configurations.</p>
<p>A better and more scalable approach for modifying a device tree is using device
tree overlays. The device tree overlay contains information about the nodes
to modify (in nodes called <em>fragment@0 ...</em>) and the overlay of the
properties that we want to affect. For more information on the overlays,
see <a href="https://www.kernel.org/doc/Documentation/devicetree/overlay-notes.txt">Overlay notes</a>.</p>
<h2 id="nix-hardwaredevicetree-module"><a class="header" href="#nix-hardwaredevicetree-module">Nix hardware.deviceTree Module</a></h2>
<p>The Nix hardware.deviceTree module helps to work with the device trees and
their overlays:</p>
<ul>
<li>To define the device tree overlay file to use.</li>
<li>To use a filter to apply the overlay only to specific files.</li>
<li>To define included paths to build the device tree overlay.</li>
</ul>
<h2 id="device-tree-overlay-example"><a class="header" href="#device-tree-overlay-example">Device Tree Overlay Example</a></h2>
<p>In this section, you can find an example of an overlay for the UARTI passthrough.
Suppose that we want to passthrough the UARTI to a VM. To do this, we need
to modify and add these properties:</p>
<ul>
<li><strong>compatible:</strong> put a dummy driver associated with this node so that
the kernel will not bind any driver to this UART unit.</li>
<li><strong>iommus:</strong> add the iommus field with the test stream ID
<em>TEGRA_SID_NISO1_SMMU_TEST</em> which by default is not used by any other device</li>
</ul>
<p>The original properties of the UARTI in Nvidia Jetson Orin AGX are defined in
<em>hardware/nvidia/soc/t23x/kernel-dts/tegra234-soc/tegra234-soc-uart.dtsi</em>
as follows:</p>
<pre><code class="language-cpp">    uarti: serial@31d0000 {
        compatible = "arm,dummy";
        iommus = &lt;&amp;smmu_niso0 TEGRA_SID_NISO1_SMMU_TEST&gt;;
        reg = &lt;0x0 0x31d0000 0x0 0x10000&gt;;
        interrupts = &lt;0x0 TEGRA234_IRQ_UARTI 0x04&gt;;
        current-speed = &lt;115200&gt;;
        status = "disabled";
    };
</code></pre>
<p>We have defined an overlay as follows for the passthrough:</p>
<pre><code class="language-cpp">/*
 * Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
 * SPDX-License-Identifier: CC-BY-SA-4.0
 */

/dts-v1/;
/plugin/;

#include &lt;dt-bindings/memory/tegra234-smmu-streamid.h&gt;

/{
    overlay-name = "UARTI passthrough on host";
    compatible = "nvidia,p3737-0000+p3701-0000";
    
    fragment@0 {
        target = &lt;&amp;uarti&gt;;
        __overlay__ {
            compatible = "arm,dummy";
            iommus = &lt;&amp;smmu_niso0 TEGRA_SID_NISO1_SMMU_TEST&gt;;
            status = "okay";
        };
    };
};
</code></pre>
<p>We will describe here all the components:</p>
<ul>
<li>
<p><strong>#include &lt;dt-bindings/memory/tegra234-smmu-streamid.h&gt;:</strong> the
included headers files for the macro definitions used in the device
tree overlay.</p>
</li>
<li>
<p><strong>overlay-name:</strong> briefly describes the purpose of the device tree</p>
</li>
<li>
<p><strong>compatible:</strong> this must be at least one of the root (/) compatibles of
the source device tree that we want to overlay, because the
<em>hardware.deviceTree</em> module will apply only to each .dtb file matching
"compatible" of the overlay.</p>
</li>
<li>
<p><strong>fragment@0:</strong> node with the information of the source node to
modify.</p>
</li>
<li>
<p><strong>fragment@0/target:</strong> label to the node to modify.
For this case we can use the label <em>uarti</em>, but also we can use
the path with path: <em>target-path="/serial@31d0000"</em></p>
</li>
<li>
<p><strong><strong>overlay</strong>:</strong> contains the properties that we want to add or modify from
the source node.</p>
</li>
</ul>
<p>In Nix you can enable the hardware.deviceTree module and define the device
tree path as follows:</p>
<pre><code class="language-nix"># Enable hardware.deviceTree for handle host dtb overlays
hardware.deviceTree.enable = true;

# Apply the device tree overlay only to tegra234-p3701-host-passthrough.dtb
hardware.deviceTree.overlays = [
    {
    name = "uarti_pt_host_overlay";
    dtsFile = ./uarti_pt_host_overlay.dts;

    # Apply overlay only to host passthrough device tree
    filter = "tegra234-p3701-host-passthrough.dtb";
    }
];
</code></pre>
<p>Also, in <a href="technologies/../../../modules/jetpack/nvidia-jetson-orin/jetson-orin.nix">jetson-orin.nix</a> the
<em>dtboBuildExtraIncludePaths</em> is defined with the path needed to include
the <em>tegra234-smmu-streamid.h</em> header file.</p>
<pre><code class="language-nix">hardware.deviceTree =
{
    enable = lib.mkDefault true;
    # Add the include paths to build the dtb overlays
    dtboBuildExtraIncludePaths = [
    "${lib.getDev config.hardware.deviceTree.kernelPackage}/lib/modules/${config.hardware.deviceTree.kernelPackage.modDirVersion}/source/nvidia/soc/t23x/kernel-include"
    ];
}
</code></pre>
<p>You can find this full implementation in the Nix module:
<a href="technologies/../../../modules/jetpack/nvidia-jetson-orin/virtualization/passthrough/uarti-net-vm">uarti-net-vm</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="nvidia-jetson-agx-orin-boot-and-power-management-processor-virtualization"><a class="header" href="#nvidia-jetson-agx-orin-boot-and-power-management-processor-virtualization">NVIDIA Jetson AGX Orin: Boot and Power Management Processor Virtualization</a></h1>
<p>Boot and Power Management Processor (BPMP) is the NVIDIA processor, which is designed for booting process handling and offloading the power management, clock management, and reset control tasks from the CPU.</p>
<p>The BPMP virtualization on the NVIDIA Jetson AGX Orin involves enabling VMs to access specific BPMP resources. This capability is crucial for passing through platform devices where control over resets and clocks configurations is required.</p>
<h2 id="architectural-overview"><a class="header" href="#architectural-overview">Architectural Overview</a></h2>
<ul>
<li><strong>Resource Access</strong>: The BPMP virtualization allows VMs to access and manage resources such as device clocks and resets.</li>
<li><strong>Foundation for Device Virtualization</strong>: This setup lays the groundwork for future virtualization of more complex devices like GPUs.</li>
<li><strong>Module Introduction</strong>: A new <code>virtualization</code> module is introduced, divided into <code>common</code> and <code>host</code> modules with a plan to add a <code>guest</code> module for NixOS-based guests.</li>
<li><strong>Device Tree Configurations</strong>: Modifications are made with patching to support virtualization features.</li>
<li><strong>Compatibility</strong>: The current implementation supports a Ghaf host with an Ubuntu guest.</li>
</ul>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<p>The current implementation includes a host configuration for the UARTA passthrough as a test case demonstrating the practical application of the BPMP virtualization. At the same time, the current implementation still requires manually built Ubuntu guest. Work continues to integrate <code>microvm.nix</code> declared guest that supports NVIDIA BPMP virtualization with the UARTA passthrough demo. This work is generally important for future NVIDIA Jetson platform bus GPU passthrough. With this feature it is possible to virtualize the NVIDIA-Jetson-integrated GPU connected to the platform bus.</p>
<h2 id="using-bpmp-virtualization-options-on-nvidia-jetson-agx-orin"><a class="header" href="#using-bpmp-virtualization-options-on-nvidia-jetson-agx-orin">Using BPMP Virtualization Options on NVIDIA Jetson AGX Orin</a></h2>
<ol>
<li>Enable NVIDIA BPMP virtualization on a Ghaf host for an NVIDIA Jetson-target using the following configuration options:</li>
</ol>
<pre><code class="language-nix">  hardware.nvidia = {
    virtualization.enable = true;
    passthroughs.uarta.enable = true;
};
</code></pre>
<blockquote>
<p><strong>IMPORTANT:</strong> These options are integrated to <a href="https://github.com/tiiuae/ghaf/blob/main/targets/nvidia-jetson-orin/default.nix">NVIDIA Jetson Orin targets</a> but disabled by default until the implementation is finished.</p>
</blockquote>
<ol start="2">
<li>Build the target and boot the image. You can write the image to an SSD for testing with a recent NVIDIA UEFI FW.</li>
</ol>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<h3 id="host-testing"><a class="header" href="#host-testing">Host Testing</a></h3>
<ol>
<li>Check the <code>bpmp-host</code> device:</li>
</ol>
<pre><code>[ghaf@ghaf-host:~]$ ls /dev | grep bpmp-host
bpmp-host
</code></pre>
<ol start="2">
<li>Check that <code>vfio-platform</code> binding is successful:</li>
</ol>
<pre><code>ghaf@ghaf-host:~]$ ls -l /sys/bus/platform/drivers/vfio-platform/3100000.serial
lrwxrwxrwx 1 root root 0 Dec  8 08:26 /sys/bus/platform/drivers/vfio-platform/3100000.serial -&gt; ../../../../devices/platform/3100000.serial
</code></pre>
<h3 id="guest-for-uarta-testing"><a class="header" href="#guest-for-uarta-testing">Guest for UARTA Testing</a></h3>
<blockquote>
<p>UARTA is an UART unit with a port A connection. For more information, see <a href="technologies/nvidia_agx_pt_uart.html#uart-connections">UART Connections</a>.</p>
</blockquote>
<ol>
<li>Build a guest kernel according to <a href="https://github.com/jpruiz84/bpmp-virt">UARTA passthrough instructions</a>[^note] and use the following script to start the VM:</li>
</ol>
<blockquote>
<p><strong>TIP:</strong> IMG is the kernel image and FS the rootfs.</p>
</blockquote>
<pre><code>IMG=$1
FS=$2

qemu-system-aarch64 \
    -nographic \
    -machine virt,accel=kvm \
    -cpu host \
    -m 1G \
    -no-reboot \
    -kernel $IMG \
    -drive file=$FS,if=virtio,format=qcow2 \
    -net user,hostfwd=tcp::2222-:22 -net nic \
    -device vfio-platform,host=3100000.serial \
    -dtb virt.dtb \
    -append "rootwait root=/dev/vda console=ttyAMA0"
</code></pre>
<ol start="2">
<li>With UARTA connected start Minicom on the working machine:</li>
</ol>
<pre><code>minicom -b 9600 -D /dev/ttyUSB0
</code></pre>
<ol start="3">
<li>Test UARTA by echoing a string to the correct <code>tty</code> in the VM:</li>
</ol>
<pre><code>echo 123 &gt; /dev/ttyTHS0
</code></pre>
<h2 id="related-topics"><a class="header" href="#related-topics">Related Topics</a></h2>
<p><a href="technologies/./nvidia_agx_pt_uart.html#nvidia-jetson-agx-orin-uart-passthrough">NVIDIA Jetson AGX Orin: UART Passthrough</a></p>
<p>[^note] That documentation is in the <a href="https://github.com/jpruiz84/bpmp-virt">bpmp-virt</a> side repository, as that approach does not use microvm.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<!--
    Update this section after the pull request https://github.com/tiiuae/ghaf/pull/94 is accepted >_<
-->
<h1 id="ghaf-specific-microvm-hypervisor-options"><a class="header" href="#ghaf-specific-microvm-hypervisor-options">Ghaf-Specific microvm Hypervisor Options</a></h1>
<p><strong>microvm</strong> is the component defining a VM's launch services generated for systemd. It inputs a set of options mapped to the hypervisor command line call.</p>
<p>Nevertheless, it may happen that some hypervisor options are not supported by microvm. For example, adding specific devices. This document considers such cases.</p>
<h3 id="options-definitions"><a class="header" href="#options-definitions">Options Definitions</a></h3>
<p>A VM is defined under Ghaf‚Äôs subdirectory <code>microvmConfigurations/VM_NAME/default.nix</code>, for example:</p>
<pre><code>modules/virtualization/microvm/netvm.nix
https://github.com/tiiuae/ghaf/blob/main/modules/virtualization/microvm/netvm.nix
</code></pre>
<p>This file contains hypervisor‚Äôs options for running the VM. For each hypervisor there is a bunch of microvm‚Äôs defined options:
<a href="https://astro.github.io/microvm.nix/options.html">https://astro.github.io/microvm.nix/options.html</a></p>
<p>The way they are processed can be found in corresponding <code>.nix</code> files (runners) in the astro/microvm.nix repository:</p>
<ul>
<li><a href="https://github.com/astro/microvm.nix/blob/main/lib/runners/crosvm.nix">crosvm.nix</a></li>
<li><a href="https://github.com/astro/microvm.nix/blob/main/lib/runners/qemu.nix">qemu.nix</a></li>
</ul>
<p>The formula for setting hypervisor option is <code>microvm.option = value;</code>. For example:</p>
<pre><code>microvm.mem = 512;
microvm.vcpu = 2;
</code></pre>
<h3 id="generated-hypervisor-start-commands"><a class="header" href="#generated-hypervisor-start-commands">Generated Hypervisor Start Commands</a></h3>
<p>As a result of building the Ghaf tree, command lines for starting the VMs are generated. They reflect all parameters specified above‚Äîboth those specified explicitly and defaults. They are located under the Ghaf‚Äôs <code>/var/lib/microvms/ directory</code>.</p>
<pre><code>ls /var/lib/microvms/memsharevm-vm-debug/current/bin
</code></pre>
<pre><code>microvm-balloon
microvm-console
microvm-run
microvm-shutdown
</code></pre>
<p>The command which starts the hypervisor is the microvm-run bash script. Here is a sample generated:</p>
<pre><code> #! /nix/store/96ky1zdkpq871h2dlk198fz0zvklr1dr-bash-5.1-p16/bin/bash -e
exec '/nix/store/zsf59dn5sak8pbq4l3g5kqp7adyv3fph-qemu-host-cpu-only-7.1.0/bin/qemu-system-x86_64' '-
name' 'memshare' '-M' 'microvm,accel=kvm:tcg,x-option-roms=off,isa-serial=off,pit=off,pic=off,rtc=off,
mem-merge=on' '-m' '2512' '-cpu' 'host' '-smp' '17' '-machine' 'virt,accel=kvm' '-nodefaults' '-no-
user-config' '-nographic' '-no-reboot' '-serial' 'null' '-device' 'virtio-serial-device' '-chardev'
'pty,id=con0' '-device' 'virtconsole,chardev=con0' '-chardev' 'stdio,mux=on,id=con1,signal=off' '-
device' 'virtconsole,chardev=con1' '-device' 'virtio-rng-device' '-drive' 'id=root,format=raw,
media=cdrom,file=/nix/store/xnnqb3sb1l4kbx7s0ijazph5r0c0xhx5-rootfs.squashfs,if=none,aio=io_uring' '-
device' 'virtio-blk-device,drive=root' '-kernel' '/nix/store/ds5cmyby0p4ikw91afmrzihkz351kls7-linux-
6.2/bzImage' '-append' 'console=hvc1 console=hvc0 reboot=t panic=-1 root=/dev/vda ro init=/init
devtmpfs.mount=0 stage2init=/nix/store/0mbhpna8hplbsaz1il3n99f0zincr4vs-nixos-system-memshare-
22.11.20230310.824f886/init boot.panic_on_fail loglevel=4 regInfo=/nix/store
/j8id92qsd58qjnzq4xz6v5l38rlpq6is-closure-info/registration' '-sandbox' 'on' '-qmp' 'unix:memshare.
sock,server,nowait' '-device' 'virtio-balloon' '--option 1 --option 2'
</code></pre>
<p>for the input parameters:</p>
<pre><code>microvm.hypervisor = "qemu";
</code></pre>
<p>Note that microvm sets several others.</p>
<pre><code>microvm.mem = 2000;
microvm.balloonMem = 512;
microvm.vcpu = 17;
microvm.qemu.extraArgs = [ "--option 1 --option 2" ];
</code></pre>
<h3 id="adding-option-to-hypervisor-command-line"><a class="header" href="#adding-option-to-hypervisor-command-line">Adding Option to Hypervisor Command Line</a></h3>
<p>microvm may not supply parameters for all possible options as adding specific devices. Processing of all microvm configuration options is done in the mentioned above hypervisor‚Äôs runner .nix file.</p>
<p>The runners support the <code>extraArgs</code> parameter. It allows setting any option in QEMU command line invocation. Its value is a list of strings. In this example the following <code>extraArgs</code> definition:</p>
<pre><code>microvm.qemu.extraArgs = [
"-object memory-backend-file,id=mem1,mem-path=/dev/shm/virtio_pmem.img"
"-device virtio-pmem-pci,memdev=mem1,id=nv1"
];
</code></pre>
<p>results in the generated command line parameters:</p>
<pre><code>'-object memory-backend-file,id=mem1,mem-path=/dev/shm/virtio_pmem.img' '-device v
irtio-pmem-pci,memdev=mem1,id=nv1'
</code></pre>
<blockquote>
<p>Support for the crosvm‚Äôs <code>extraArgs</code> parameter was added on April 7, 2023. Make sure to verify that your <code>flakes.lock</code> file refers to the proper version.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="continuous-integration-and-distribution"><a class="header" href="#continuous-integration-and-distribution">Continuous Integration and Distribution</a></h1>
<p>Ghaf Framework uses a CI/CD (Continuous Integration and Continuous Delivery) approach that aims to automate the process of building, testing, and deploying software.</p>
<p>Our goal is to have the ability to deploy code quickly and safely: once a build is deployed, the next build undergoes testing, while the latest build is being coded.</p>
<blockquote>
<p>Currently, Continuous Deployment is not set up.</p>
</blockquote>
<h2 id="general-process"><a class="header" href="#general-process">General Process</a></h2>
<p><img src="scs/../img/CICD_general.drawio.png" alt="CI/CD Architecture" title="Ghaf CI/CD Architecture" /></p>
<p>The software delivery pipeline consists of several stages:</p>
<ol>
<li>
<p>Contributors make changes in the code and create a pull/merge request to merge changes from one personal fork or branch into the upstream repository/branch.</p>
</li>
<li>
<p>Builder Controller checks source code repositories for changes and fetches them.</p>
</li>
<li>
<p>Builder Controller arranges builds on Remote Builders to make disk images and other release artifacts.</p>
</li>
<li>
<p>After the building is done, Remote Builder sends disk images to Builder Controller to create provenance files and sign disk images and provenance files.</p>
</li>
<li>
<p>On build failure, Builder Controller sends failure notifications to Message Service.</p>
</li>
<li>
<p>Builder Controller uploads all build artifacts to Binary Cache and disk images to Web Server.</p>
</li>
<li>
<p>Test Automation fetches disk images from Binary Cache and runs the hardware test on them.</p>
</li>
<li>
<p>Test Automation uploads test reports to Web Server.</p>
</li>
<li>
<p>Users can download images from Web Server:</p>
<ul>
<li>release images <a href="https://vedenemo.dev/files/releases/">https://vedenemo.dev/files/releases/</a></li>
<li>images for testing <a href="https://vedenemo.dev/files/build_reports/">https://vedenemo.dev/files/build_reports/</a>.</li>
</ul>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="supply-chain-security"><a class="header" href="#supply-chain-security">Supply Chain Security</a></h1>
<p>To be aware of what is exactly in our software supply chain, it is reviewed for security issues and known vulnerabilities.</p>
<p><img src="scs/../img/threat_processing.drawio.png" alt="Supply Chain Attacks Diagram" title="Supply Chain Attacks" /></p>
<p>We implement a <em>supply chain security (SCS)</em> ‚Äî process of securing the machinery of the development, building, and release environment. That means that every component that a software artifact might be touching on its way from the developer to the consumer will be secured.</p>
<p>The software artifact should be encrypted on each possible transition phase and its integrity should be verified at each destination. Each build should be accompanied by means of <a href="scs/../appendices/glossary.html#sbom"><em>software bill of materials (SBOM)</em></a>, identifying all the components that the software package consists of.</p>
<p>SBOM containing reference to each dependency, its source and version together with provenance, containing build information are collected at the build time, signed, and used for vulnerability analysis during the next steps.</p>
<p>The software artifact, SBOM, and provenance are signed by the build machinery at the build time, and the signature is verifiable at every destination of the package. The certificates that are used for signing and verification are provided by the <em>public key infrastructure (PKI)</em> system and are signed by the same root <em>certificate authority (CA)</em>. That allows you to confirm the author of the signature (build machinery) and guarantees that the package has not been tampered with since the build time.</p>
<h2 id="in-this-chapter-3"><a class="header" href="#in-this-chapter-3">In This Chapter</a></h2>
<ul>
<li><a href="scs/../scs/slsa-framework.html">SLSA Framework</a></li>
<li><a href="scs/../scs/basics.html">Basic Security Measures</a></li>
<li><a href="scs/../scs/sbom.html">SBOM</a></li>
<li><a href="scs/../scs/pki.html">Public Key Infrastructure</a></li>
<li><a href="scs/../scs/ghaf-security-fix-automation.html">Security Fix Automation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="slsa-framework"><a class="header" href="#slsa-framework">SLSA Framework</a></h1>
<p>Supply chain Levels for Software Artifacts (SLSA) is a security framework for tampering prevention, integrity improvement, and securing packages and infrastructure of a project. For more information about the SLSA framework, see the offical website <a href="https://slsa.dev">https://slsa.dev</a>.</p>
<h2 id="slsa-terminology"><a class="header" href="#slsa-terminology">SLSA Terminology</a></h2>
<p><strong>Immutable reference:</strong> An identifier, guaranteed to always point to the same, immutable artifact.</p>
<p><strong>Provenance:</strong> Metadata about how an artifact was produced.</p>
<p><strong>Revision:</strong> An immutable, coherent state of a source.</p>
<h2 id="levels-of-assurance"><a class="header" href="#levels-of-assurance">Levels of Assurance</a></h2>
<p>One of the requirements for the solution is to reach SLSA Level 4 and even go beyond that. This requires a lot of process changes as well as technical work.</p>
<p>The SLSA model consists of 4 levels, offering an incremental level of anti-tampering protection. Levels 1-3 represent milestones with certain integrity guarantees, whereas level 4 is an ideal end state.</p>
<p><strong>Level 0</strong> means no SLSA compliance and no guarantees are given.</p>
<p><strong>Level 1</strong> demands a fully scripted / automated build process and provenance generation. It offers basic confidence in the origin of the software but doesn‚Äôt provide any tamper resistance.</p>
<p><strong>Level 2</strong> Introduces authenticated provenance generated by a hosted build at the same time demanding version control system usage. Provenance prevents tampering and offers trust in the build service.</p>
<p><strong>Level 3</strong> offers auditability of the source and the integrity of the provenance. Much stronger tampering protection is provided by preventing specific classes of threats such as cross-build contamination.</p>
<p><strong>Level 4</strong> requires two-peer source code review and a hermetic, reproducible build process. Overall Level 4 offers a high degree of confidence in the anti-tampering protection of the software.</p>
<p>SLSA level is not transitive, thus level of the artifact is not dependent on the level of dependencies, which are expected to have their own SLSA levels. This makes it possible to build a Level 4 artifact from Level 0 dependencies.</p>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Requirements</th><th>Level 1</th><th>Level 2</th><th>Level 3</th><th>Level 4</th></tr></thead><tbody>
<tr><td>Source ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#version-controlled">Version controlled</a></td><td></td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Source ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#verified-history">Verified history</a></td><td></td><td></td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Source ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#retained-indefinitely">Retained indefinitely</a></td><td></td><td></td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Source ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#two-person-reviewed">Two-person reviewed</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#scripted-build">Scripted build</a></td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#build-service">Build service</a></td><td></td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#build-as-code">Build as code</a></td><td></td><td></td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#ephemeral-environment">Ephemeral environment</a></td><td></td><td></td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#isolated">Isolated</a></td><td></td><td></td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#parameterless">Parameterless</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#hermetic">Hermetic</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#reproducible">Reproducible</a></td><td></td><td></td><td></td><td>‚óã</td></tr>
<tr><td>Provenance ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#available">Available</a></td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Provenance ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#authenticated">Authenticated</a></td><td></td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Provenance ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#service-generated">Service generated</a></td><td></td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Provenance ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#non-falsifiable">Non-falsifiable</a></td><td></td><td></td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Provenance ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#dependencies-complete">Dependencies complete</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
<tr><td>Common ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#security">Security</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
<tr><td>Common ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#access">Access</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
<tr><td>Common ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#superusers">Superusers</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
</tbody></table>
</div>
<p>‚úì ‚Äî required</p>
<p>‚óã ‚Äî required unless justified otherwise</p>
<p>empty cell ‚Äî not required</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="basic-security-measures"><a class="header" href="#basic-security-measures">Basic Security Measures</a></h1>
<h2 id="source-code--version-control-security"><a class="header" href="#source-code--version-control-security">Source Code / Version Control Security</a></h2>
<p>The source code security is based on the fact that the source code is two-person reviewed, version controlled, and the history is verified and retained indefinitely.</p>
<h3 id="commit-signing"><a class="header" href="#commit-signing">Commit Signing</a></h3>
<p>All the commits to repositories must be GPG-signed. This can be achieved by enabling GPG commit signatures in the config:</p>
<p><code>git config --global commit.gpgsign true</code></p>
<p>For more detailed information, see the <a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits" title="Signing Commits on GitHub">Signing commits</a> article of the GitHub Docs.</p>
<h3 id="branch-protection"><a class="header" href="#branch-protection">Branch Protection</a></h3>
<p>In the case of GitHub the following settings should be considered:</p>
<ul>
<li>Require pull request reviews before merging (req: two-person reviewed source).</li>
<li>Require status checks before merging.</li>
<li>Require conversation resolution before merging.</li>
<li>Require signed commits.</li>
<li>Deletions should be forbidden (req: immutable history).</li>
</ul>
<h2 id="software-signing"><a class="header" href="#software-signing">Software Signing</a></h2>
<p>Software signing is an important measure to validate the author and ensure that the code has not been altered on the way from the developer to the customer. Nix tooling is offering means to sign the derivations using libsodium with EdDSA, however, as the modular system is assumed, scripts need to be developed to support signing mechanisms in an absence of Nix tooling.</p>
<p>By default, the software image is signed only at the binary cache per request. Which leaves the path from Hydra to the binary cache unsecured. The problem can be resolved in two ways:</p>
<ul>
<li>Enabling the image signing on Hydra</li>
<li>Shared Nix Store</li>
</ul>
<h3 id="enabling-image-signing-on-hydra"><a class="header" href="#enabling-image-signing-on-hydra">Enabling Image Signing on Hydra</a></h3>
<p>Enabling the image signing on Hydra requires some extra work due to the lack of well-documented support of image signing at Hydra at the time of writing this document. As already mentioned, NixOS is using libsodium-based EdDSA solution for image signing. So similar scripts can be implemented. For example, in Python by using existing libsodium bindings, such as PyNaCl.</p>
<p><img src="scs/../img/threat_processing_2serv.drawio.png" alt="Enabling Image Signing on Hydra" title="Enabling The Image Signing On Hydra" /></p>
<h3 id="shared-nix-store"><a class="header" href="#shared-nix-store">Shared Nix Store</a></h3>
<p>The shared NixStore option is rather straightforward if Hydra is combined with the binary cache. This kind of setup is lacking the extra transition path. Thus the packages signed by the binary cache will be served straight from the Hydra NixStore.</p>
<p><img src="scs/../img/threat_processing_1serv.drawio.png" alt="Shared NixStore Solution" title="Shared NixStore" /></p>
<h2 id="data-encryption-in-transit"><a class="header" href="#data-encryption-in-transit">Data Encryption in Transit</a></h2>
<p>All the data should be transported over secure encrypted channels. Since all the transportation is done over TCP/IP protocol stack, it is possible to use native solutions like TLS to secure the traffic between the nodes. Version 1.2 is a minimum requirement.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="software-bill-of-materials-sbom"><a class="header" href="#software-bill-of-materials-sbom">Software Bill of Materials (SBOM)</a></h1>
<p>Software bill of materials (SBOM) is a formal, machine-readable document that provides a list of software components that make up the target software and all its dependencies.</p>
<h2 id="sbom-formats-and-specifications"><a class="header" href="#sbom-formats-and-specifications">SBOM Formats and Specifications</a></h2>
<p>There are three main delivery formats and specifications for SBOM: CycloneDX, SPDX, and SWID.</p>
<p><a href="https://cyclonedx.org/specification/overview/">CycloneDX</a> is an open-source standard with origins in the <a href="https://en.wikipedia.org/wiki/OWASP">OWASP</a> community. The specification's original focus is on security. There's a large growing community and open source tooling that support CycloneDX format.</p>
<p><a href="https://spdx.dev/specifications/">SPDX</a> is also a product of an open-source community, with the original focus on licensing. SPDX is run and maintained by <a href="https://en.wikipedia.org/wiki/Linux_Foundation">Linux Foundation</a>. Similarly to CycloneDX, many open-source tools support the SPDX format.</p>
<p><a href="https://nvd.nist.gov/products/swid">SWID</a> is a <a href="https://www.iso.org/standard/65666.html">standard</a> that originates from <a href="https://www.nist.gov/">NIST</a>. SWID tags aim to help organizations create accurate software inventories. While SWID can serve as an SBOM too, it is not as widely used SBOM format in open source as the two other specifications.</p>
<h2 id="sbom-usage-in-ghaf"><a class="header" href="#sbom-usage-in-ghaf">SBOM Usage in Ghaf</a></h2>
<p>Ghaf framework will use SBOMs for:</p>
<ul>
<li>Vulnerability identification: automatic correlation of SBOM against known vulnerabilities.</li>
<li>Vulnerability remediation: automatic process to suggest fixes for identified vulnerabilities.</li>
<li>Dependency analysis: categorization of open-source and closed source software dependencies.</li>
<li>Dependency analysis: creation of a directed acyclic graph</li>
<li>License compliance: know and comply with the license obligations.</li>
<li>Market signal: publish SBOM together with other release artifacts.</li>
</ul>
<h2 id="sbom-tooling-in-ghaf"><a class="header" href="#sbom-tooling-in-ghaf">SBOM Tooling in Ghaf</a></h2>
<p>Ghaf is based on Nix, therefore, the selected SBOM tooling needs to support creating SBOMs for nix artifacts. As part of the Ghaf project, we have created the sbomnix tool to support SBOM generation for Ghaf and, more generally, for any Nix-based targets. For more details on the SBOM tooling in Ghaf, see <a href="https://github.com/tiiuae/sbomnix#sbomnix">sbomnix</a> and <a href="https://github.com/tiiuae/sbomnix/blob/main/doc/nixgraph.md#nixgraph">nixgraph</a>. sbomnix supports <a href="https://cyclonedx.org/specification/overview/">CycloneDX</a> as well as <a href="https://spdx.dev/specifications/">SPDX</a> SBOM specification.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://ntia.gov/page/software-bill-materials">https://ntia.gov/page/software-bill-materials</a></li>
<li><a href="https://slsa.dev/blog/2022/05/slsa-sbom">https://slsa.dev/blog/2022/05/slsa-sbom</a></li>
<li><a href="https://fossa.com/blog/software-bill-of-materials-formats-use-cases-tools">https://fossa.com/blog/software-bill-of-materials-formats-use-cases-tools</a></li>
<li><a href="https://www.legitsecurity.com/blog/what-is-an-sbom-sbom-explained-in-5-minutes">https://www.legitsecurity.com/blog/what-is-an-sbom-sbom-explained-in-5-minutes</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="public-key-infrastructure"><a class="header" href="#public-key-infrastructure">Public Key Infrastructure</a></h1>
<p>In the SCS context, a public key infrastructure (PKI) term refers to a system for the creation, storage, and distribution of digital certificates which are used to verify that a particular key belongs to a certain entity. PKI creates and manages a hierarchical set of digital certificates which map public keys to certain entities. Storage and revocation methodologies are to be defined.</p>
<p>The PKI of SCS should consist of:</p>
<ul>
<li>Certificate authority (CA) for storing, issuing, and signing the digital certificates.</li>
<li>Registration authority (RA) for requesting entity identity verification.</li>
<li>Central directory for the secure storage of the keys.</li>
<li>Certificate Management System (CMS) for managing access to stored certificates.</li>
</ul>
<h2 id="private-certificate-authority-pca"><a class="header" href="#private-certificate-authority-pca">Private Certificate Authority (PCA)</a></h2>
<p>PCA enables the creation of private certificate authority hierarchies, consisting of Root and Subordinate CAs. It issues end-entity X.509 certificates, that are used for:</p>
<ul>
<li>Encrypted TLS communication channels (data encryption in transit)</li>
<li>Code and image signing</li>
</ul>
<p>PCA can be established in the cloud or on-premises. Initially, the OpenSSL-based solution deployed on-premises is assumed, however, some of the target projects might consider using commercial cloud solutions.</p>
<h2 id="hardware-security-module"><a class="header" href="#hardware-security-module">Hardware Security Module</a></h2>
<p>On-premises solution can be further improved by adding a Hardware Security Module (HSM). It is a physical device for managing cryptographic material such as digital keys.</p>
<p>HSM can be also used to perform cryptographic operations such as digital signing, encryption, and decryption. The HSM contains one or more Secure Cryptoprocessors that are dedicated microprocessors optimized for carrying out cryptographic operations.</p>
<p>One example of affordable HSM solutions is YubiHSM developed by Yubico.</p>
<h3 id="hsm-variants-for-consideration"><a class="header" href="#hsm-variants-for-consideration">HSM Variants for Consideration</a></h3>
<p>The following HSM solutions are considered for the Ghaf project:</p>
<ul>
<li><a href="https://www.yubico.com/fi/product/yubihsm-2/" title="YubiHSM2">YubiHSM2</a></li>
<li><a href="https://shop.nitrokey.com/shop/product/nkhs2-nitrokey-hsm-2-7" title="NitrokeyHSM2">NitrokeyHSM2</a></li>
<li><a href="https://github.com/opendnssec/SoftHSMv2" title="SoftHSMv2">SoftHSMv2</a></li>
<li>BreadboardHSM</li>
</ul>
<p>The following table provides feature comparison of the proposed solutions:</p>
<blockquote>
<p>Since the feature list is quite extensive, the table is limited to the features that are either planned to be used in Ghaf or might benefit the project in the future.</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>YubiHSM 2</th><th>NitrokeyHSM2</th><th>SoftHSMv2</th><th>BreadboardHSM</th></tr></thead><tbody>
<tr><td>Secure key storage</td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>ECC</td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>EdDSA (ed25519)</td><td>‚úì</td><td></td><td>?</td><td></td></tr>
<tr><td>ECDSA</td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>RSA</td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td></td></tr>
<tr><td>PKCS#11 interface</td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Network shareable</td><td>‚úì</td><td></td><td>‚úì</td><td></td></tr>
<tr><td>M of N wrap rule</td><td>‚úì</td><td>‚úì</td><td></td><td></td></tr>
<tr><td>Tamper evident audit logging</td><td>‚úì</td><td></td><td></td><td></td></tr>
<tr><td>Storage capacity</td><td>128KB, 255xAny ECC</td><td>76KB, 35xECC-512</td><td></td><td>9.7Kb, 16 slots</td></tr>
<tr><td>Price</td><td>650EUR (VAT 0%)</td><td>99 EUR</td><td>FOSS</td><td>HW Costs</td></tr>
</tbody></table>
</div>
<p>YubiHSM2 is the leading solution considering its cryptographic capabilities. However, taking into account quite modest needs of SCS, NitrokeyHSM2 represents an adequate option.</p>
<p>The main benefit of YubiHSM2 from SCS perspective is its native support of EdDSA-curve25519, which is the one that NixOS is using for package signing. Thus YubiHSM2 could be used directly with NixOS. However, as the package doesn't change in transit from the Build System to the Consumer, usage of inbuilt tooling is not always necessary.</p>
<p>BreadboardHSM solution is based on Microchip ATECC608B (TrustFLEX + cryptoauthlib + gtutls), though development work is still ongoing at the time of writing this document. The SoftHSMv2 and BreadboardHSM are taken for comparison showing what can be achieved using FOSS variants.</p>
<h2 id="ca-hierarchy-options"><a class="header" href="#ca-hierarchy-options">CA Hierarchy Options</a></h2>
<p>CA usually consists of:</p>
<ul>
<li>Root CA - the root of trust of the entire PKI, for issuing and signing the certificates used by other CAs.</li>
<li>Subordinate CA for issuing end-entity certificates.</li>
</ul>
<p>There are three types of hierarchies: one-tier, two-tier, and three-tier. The hierarchy can be chosen based on the target project's needs and complexity. A one-tier hierarchy is not considered for any production usage due to the low security, as the compromise of a single CA leads to a compromise of the entire PKI.</p>
<p>In a two-tier hierarchy, the Root CA and issuing (Subordinate) CAs are separated for increasing the security level. This is the simplest production level hierarchy allowing to keep Root CA at the most secure and restrictive levels, yet making subordinate CA access slightly more permissive. This hierarchy is most likely sufficient for most of the target projects.</p>
<p>In a three-tier CA, an intermediate CA is placed between the Root CA and the Subordinate (issuing) CA. This is done to separate the Root CA from low-level CA operations. The middle layer (intermediate CA) is only used to sign Subordinate CAs that issue the end-entity certificates.</p>
<h2 id="proposed-ca-hierarchy"><a class="header" href="#proposed-ca-hierarchy">Proposed CA Hierarchy</a></h2>
<p>The following diagram describes the proposed CA for the SCS. The three-tier CA is chosen based on the high-security level and the potential need to scale it to several projects, later on, keeping the main control under the same Root CA.</p>
<p><img src="scs/../img/ca_implementation.drawio.png" alt="Proposed CA" title="CA Implementation Proposal" /></p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="security-fix-automation"><a class="header" href="#security-fix-automation">Security Fix Automation</a></h1>
<p>The Nix community is able to identify and fix security issues relatively quickly. At the same time, the community process to ensure critical security fixes are included in nixpkgs is unclear or unspecified.</p>
<p>Indeed, Ghaf should not solely rely on the community to provide security fixes but take action to understand the vulnerabilities that impact Ghaf and take an active role in fixing such issues.</p>
<h2 id="semi-automated-upstream-first-process"><a class="header" href="#semi-automated-upstream-first-process">Semi-Automated Upstream-First Process</a></h2>
<p>The following image captures the high-level process we propose to identify and remediate the security vulnerabilities that impact Ghaf:</p>
<p><img src="scs/../img/ghaf-security-fix-automation.drawio.svg" alt="Security Fix Automation" title="Ghaf Security Fix Automation" /></p>
<p>The process consists of two parts - <strong>automated</strong> and <strong>manual</strong>:</p>
<ul>
<li>
<p><strong>Automated vulnerability analysis</strong> is a scripted job triggered on a daily basis in Ghaf CI/CD. It consists of the following actions:</p>
<p><strong>(1)</strong> Locally (temporarily) update the Ghaf flake lock file. Temporary lock file update is needed so the Ghaf dependencies are up-to-date with the nixpkgs input Ghaf is pinned to. Otherwise, the automated analysis results would also include vulnerabilities that have been fixed in nixpkgs upstream since the last Ghaf flake lock update.</p>
<p><strong>(2)</strong> Run automated vulnerability analysis tooling for each relevant Ghaf build target. For Ghaf, being Nix-based, we propose to use <a href="https://github.com/tiiuae/sbomnix/tree/main/scripts/nixupdate#nix_secupdates">nix_secupdates</a> for automated vulnerability analysis. As a result of this step, the tooling generates an auto-triaged vulnerability report, which will be the main input for the manual analysis.</p>
</li>
<li>
<p><strong>Manual vulnerability analysis</strong> is a manual process, which is also executed on daily basis.</p>
<p><strong>(3)</strong> Using the auto-triaged vulnerability report from the previous step, manually analyze the automation results comparing the new results to earlier day's results from the relevant build.</p>
<p><strong>(4)</strong> If there are any fixed issues compared to the last analyzed report, initiate the Ghaf flake lock file update for relevant inputs to include the vulnerability fixes from the nixpkgs upstream to relevant Ghaf branches.</p>
<p><strong>(5)</strong> If there are any new vulnerabilities compared to the last analyzed report, manually analyze each vulnerability in detail. If the issue requires a fix, create a pull request to push the changes to relevant nixpkgs branches.</p>
</li>
</ul>
<p>The process described above is an upstream-first, with the main benefit of eliminating the need to maintain our own vulnerability fix patches on top of nixpgks in Ghaf. This process will also benefit the nixpkgs community, contributing to the overall security improvement for the packages Ghaf depends on.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="ghaf-release-notes"><a class="header" href="#ghaf-release-notes">Ghaf Release Notes</a></h1>
<p>Ghaf is released 4 times per year at the end of each quarter. Additional releases may be made as per request.</p>
<p>Release numbering scheme: <em>ghaf-yy.mm</em>.</p>
<h2 id="in-this-chapter-4"><a class="header" href="#in-this-chapter-4">In This Chapter</a></h2>
<ul>
<li><a href="release_notes/../release_notes/ghaf-24.03.html">Release ghaf-24.03</a></li>
<li><a href="release_notes/../release_notes/ghaf-23.12.html">Release ghaf-23.12</a></li>
<li><a href="release_notes/../release_notes/ghaf-23.09.html">Release ghaf-23.09</a></li>
<li><a href="release_notes/../release_notes/ghaf-23.06.html">Release ghaf-23.06</a></li>
<li><a href="release_notes/../release_notes/ghaf-23.05.html">Release ghaf-23.05</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="release-ghaf-2403"><a class="header" href="#release-ghaf-2403">Release ghaf-24.03</a></h1>
<h2 id="release-branch"><a class="header" href="#release-branch">Release Branch</a></h2>
<p><a href="https://github.com/tiiuae/ghaf/tree/ghaf-24.03">https://github.com/tiiuae/ghaf/tree/ghaf-24.03</a></p>
<h2 id="supported-hardware"><a class="header" href="#supported-hardware">Supported Hardware</a></h2>
<p>The following target hardware is supported by this release:</p>
<ul>
<li>NVIDIA Jetson AGX Orin</li>
<li>NVIDIA Jetson Orin NX</li>
<li>Generic x86 (PC)</li>
<li>Polarfire Icicle Kit</li>
<li>Lenovo ThinkPad X1 Carbon Gen 11</li>
<li>Lenovo ThinkPad X1 Carbon Gen 10</li>
</ul>
<h2 id="what-is-new-in-ghaf-2403"><a class="header" href="#what-is-new-in-ghaf-2403">What is New in ghaf-24.03</a></h2>
<ul>
<li>Added support for Lenovo ThinkPad X1 Carbon Gen 10.</li>
<li>Lenovo X1 Carbon Gen 10/11:
<ul>
<li>labwc is used as a main window-stacking compositor. Weston is no longer supported.</li>
<li><a href="https://tiiuae.github.io/ghaf/ref_impl/installer.html">Standalone installer</a>.</li>
<li>Hardened host and guest kernel configurations, disabled by default.</li>
<li>Power control (Power Off and Reboot).</li>
<li>Configurable border colors for application windows.</li>
<li>Initial <a href="https://layers.openembedded.org/layerindex/recipe/333608/">tpm2-pkcs11</a> support.</li>
<li>Screen lock, disabled by default.</li>
<li>Minimized systemd.</li>
</ul>
</li>
<li>NVIDIA Jetson Orin:
<ul>
<li>Boot and Power Management virtualization, built as a separate target.</li>
<li>Jetpack baseline software updates and fixes.</li>
</ul>
</li>
<li>Further modularization of the Ghaf framework: <a href="release_notes/../ref_impl/ghaf-based-project.html">Ghaf as Library: Templates</a>.</li>
<li>Development, testing, and performance tooling improvements.</li>
</ul>
<h2 id="bug-fixes"><a class="header" href="#bug-fixes">Bug Fixes</a></h2>
<p>Fixed bugs that were in the ghaf-23.12 release:</p>
<ul>
<li>The GALA application does not work.</li>
<li>Copying text from the browser address bar to another application does not work.</li>
<li>The taskbar disappears after the external display is disconnected from Lenovo X1.</li>
</ul>
<h2 id="known-issues-and-limitations"><a class="header" href="#known-issues-and-limitations">Known Issues and Limitations</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Issue</th><th>Status</th><th>Comments</th></tr></thead><tbody>
<tr><td>Cannot log in to the Element chat with a Google account</td><td>In Progress</td><td>Workaround for x86: create a user specifically for Element.</td></tr>
<tr><td>Windows launcher application does not work on AGX</td><td>In Progress</td><td>Workaround: launch a Windows VM from the command line.</td></tr>
<tr><td>Time synchronization between host and VMs does not work in all scenarios</td><td>In Progress</td><td>Under investigation.</td></tr>
<tr><td>Closing and re-opening a deck lid of a X1 laptop with running Ghaf causes instability</td><td>In Progress</td><td>Workaround: keep a deck lid of a laptop open while working with Ghaf.</td></tr>
<tr><td>Applications do not open from icons when netvm is restarted</td><td>In Progress</td><td>Workaround: restart AppVMs.</td></tr>
<tr><td>Cannot connect to a hidden Wi-Fi network from GUI</td><td>In Progress</td><td>Workaround:  connect with SSH to netvm and run the command <code>nmcli dev wifi connect SSID password PASSWORD hidden yes</code>.</td></tr>
</tbody></table>
</div>
<h2 id="environment-requirements"><a class="header" href="#environment-requirements">Environment Requirements</a></h2>
<p>There are no specific requirements for the environment with this release.</p>
<h2 id="installation-instructions"><a class="header" href="#installation-instructions">Installation Instructions</a></h2>
<p>Released images are available at <a href="https://vedenemo.dev/files/releases/ghaf_24.03/">vedenemo.dev/files/releases/ghaf_24.03/</a>.</p>
<p>Download the required image and use the following instructions:</p>
<div class="table-wrapper"><table><thead><tr><th>Release Image</th><th>Build and Run</th></tr></thead><tbody>
<tr><td>ghaf-24.03_Generic_x86.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#running-ghaf-image-for-x86-computer">Running Ghaf Image for x86 Computer</a></td></tr>
<tr><td>ghaf-24.03_Lenovo_X1_Carbon_Gen11.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#running-ghaf-image-for-lenovo-x1">Running Ghaf Image for Lenovo X1</a></td></tr>
<tr><td>ghaf-24.03_Nvidia_Orin_AGX_cross-compiled-no-demoapps.tar.xz[^note], ghaf-24.03_Nvidia_Orin_AGX_cross-compiled.tar.xz, ghaf-24.03_Nvidia_Orin_AGX_native-build.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#ghaf-image-for-nvidia-jetson-orin-agx">Ghaf Image for NVIDIA Jetson Orin AGX</a></td></tr>
<tr><td>ghaf-24.03_Nvidia_Orin_NX_cross-compiled-no-demoapps[^note].tar.xz, ghaf-24.03_Nvidia_Orin_NX_cross-compiled.tar.xz, ghaf-24.03_Nvidia_Orin_NX_native-build.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#ghaf-image-for-nvidia-jetson-orin-agx">Ghaf Image for NVIDIA Jetson Orin AGX</a></td></tr>
<tr><td>ghaf-24.03_PolarFire_RISC-V.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#building-ghaf-image-for-microchip-icicle-kit">Building Ghaf Image for Microchip Icicle Kit</a></td></tr>
</tbody></table>
</div>
<p>[^note] no-demoapps images do not include Chromium, Zathura, and GALA applications.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="release-ghaf-2312"><a class="header" href="#release-ghaf-2312">Release ghaf-23.12</a></h1>
<h2 id="release-branch-1"><a class="header" href="#release-branch-1">Release Branch</a></h2>
<p><a href="https://github.com/tiiuae/ghaf/tree/ghaf-23.12">https://github.com/tiiuae/ghaf/tree/ghaf-23.12</a></p>
<h2 id="supported-hardware-1"><a class="header" href="#supported-hardware-1">Supported Hardware</a></h2>
<p>The following target hardware is supported by this release:</p>
<ul>
<li>NVIDIA Jetson AGX Orin</li>
<li>NVIDIA Jetson Orin NX</li>
<li>Generic x86 (PC)</li>
<li>Polarfire Icicle Kit</li>
<li>Lenovo ThinkPad X1 Carbon Gen 11</li>
</ul>
<h2 id="what-is-new-in-ghaf-2312"><a class="header" href="#what-is-new-in-ghaf-2312">What is New in ghaf-23.12</a></h2>
<ul>
<li>NixOS update to 23.11: <a href="https://discourse.nixos.org/t/nixos-23-11-released/36210">NixOS 23.11 released!</a></li>
<li>Further modularization of the Ghaf framework: <a href="release_notes/../ref_impl/ghaf-based-project.html">Ghaf as Library: Templates</a>.</li>
<li>CLI-based installer.</li>
<li>Lenovo X1 Carbon Gen 11:
<ul>
<li>Configurable PCI and USB devices passthrough.</li>
<li>Network Manager: support from GUIVM to NETVM.</li>
<li>Windows VM support.</li>
<li>Added Ghaf icons and the background image.</li>
<li>Secure Boot is disabled by default.</li>
<li>The hardened host kernel baseline is disabled by default.</li>
<li>Initial hardened hypervisor integration is disabled by default.</li>
</ul>
</li>
<li>NVIDIA Jetson Orin:
<ul>
<li>Configurable PCI passthrough.</li>
<li>Jetpack baseline software updates and fixes.</li>
<li>Initial OP-TEE and TEE Proxy support.</li>
</ul>
</li>
<li>Cross-compilation of the ARM targets (NVIDIA) on the x86 server.</li>
<li>SLSA v1.0 level 2 compatible build.</li>
<li>Development, testing, and performance tooling improvements.</li>
</ul>
<h2 id="bug-fixes-1"><a class="header" href="#bug-fixes-1">Bug Fixes</a></h2>
<p>Fixed bugs that were in the ghaf-23.09 release:</p>
<ul>
<li>Chromium AppVM does not boot up on X1.</li>
<li>Shutdown or reboot of Lenovo X1 takes a lot of time (7 minutes).</li>
<li>Copy and paste text from or to Chromium AppVM does not work. Copy text from the address bar does not work as well.</li>
<li>Personal security keys cannot be created.</li>
<li>Cannot move the Element window by dragging with the mouse.</li>
</ul>
<h2 id="known-issues-and-limitations-1"><a class="header" href="#known-issues-and-limitations-1">Known Issues and Limitations</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Issue</th><th>Status</th><th>Comments</th></tr></thead><tbody>
<tr><td>The GALA application does not work</td><td>In Progress</td><td>Will be fixed in the next release.</td></tr>
<tr><td>Cannot log in to the Element chat with a Google account</td><td>In Progress</td><td>Workaround for x86: create a user specifically for Element.</td></tr>
<tr><td>Copying text from the browser address bar to another application does not work</td><td>In Progress</td><td>Under investigation.</td></tr>
<tr><td>Windows launcher application does not work on NUC and AGX</td><td>In Progress</td><td>Workaround: launch a Windows VM from the command line.</td></tr>
<tr><td>Time synchronization between host and VMs does not work in all scenarios</td><td>In Progress</td><td>Under investigation.</td></tr>
<tr><td>The taskbar disappears after the external display is disconnected from Lenovo X1</td><td>In Progress</td><td>Under investigation.</td></tr>
<tr><td>Closing and re-opening a deck lid of a X1 laptop with running Ghaf causes instability</td><td>In Progress</td><td>Workaround: keep a deck lid of a laptop open while working with Ghaf.</td></tr>
<tr><td>Applications do not open from icons when netvm is restarted</td><td>In Progress</td><td>Workaround: Restart AppVMs.</td></tr>
</tbody></table>
</div>
<h2 id="environment-requirements-1"><a class="header" href="#environment-requirements-1">Environment Requirements</a></h2>
<p>There are no specific requirements for the environment with this release.</p>
<h2 id="installation-instructions-1"><a class="header" href="#installation-instructions-1">Installation Instructions</a></h2>
<p>Released images are available at <a href="https://vedenemo.dev/files/releases/ghaf_23.12/">vedenemo.dev/files/releases/ghaf_23.12/</a>.</p>
<p>Download the required image and use the following instructions:</p>
<div class="table-wrapper"><table><thead><tr><th>Release Image</th><th>Build and Run</th></tr></thead><tbody>
<tr><td>ghaf-23.12_Generic_x86.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#running-ghaf-image-for-x86-computer">Running Ghaf Image for x86 Computer</a></td></tr>
<tr><td>ghaf-23.12_Lenovo_X1_Carbon_Gen11.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#running-ghaf-image-for-lenovo-x1">Running Ghaf Image for Lenovo X1</a></td></tr>
<tr><td>ghaf-23.12_Nvidia_Orin_AGX_cross-compiled-no-demoapps.tar.xz[^note], ghaf-23.12_Nvidia_Orin_AGX_cross-compiled.tar.xz, ghaf-23.12_Nvidia_Orin_AGX_native-build.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#ghaf-image-for-nvidia-jetson-orin-agx">Ghaf Image for NVIDIA Jetson Orin AGX</a></td></tr>
<tr><td>ghaf-23.12_Nvidia_Orin_NX_cross-compiled-no-demoapps[^note].tar.xz, ghaf-23.12_Nvidia_Orin_NX_cross-compiled.tar.xz, ghaf-23.12_Nvidia_Orin_NX_native-build.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#ghaf-image-for-nvidia-jetson-orin-agx">Ghaf Image for NVIDIA Jetson Orin AGX</a></td></tr>
<tr><td>ghaf-23.12_PolarFire_RISC-V.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#building-ghaf-image-for-microchip-icicle-kit">Building Ghaf Image for Microchip Icicle Kit</a></td></tr>
</tbody></table>
</div>
<p>[^note] no-demoapps images do not include Chromium, Zathura, and GALA applications.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="release-ghaf-2309"><a class="header" href="#release-ghaf-2309">Release ghaf-23.09</a></h1>
<h2 id="release-branch-2"><a class="header" href="#release-branch-2">Release Branch</a></h2>
<p><a href="https://github.com/tiiuae/ghaf/tree/ghaf-23.09">https://github.com/tiiuae/ghaf/tree/ghaf-23.09</a></p>
<h2 id="supported-hardware-2"><a class="header" href="#supported-hardware-2">Supported Hardware</a></h2>
<p>The following target hardware is supported by this release:</p>
<ul>
<li>NVIDIA Jetson AGX Orin</li>
<li>NVIDIA Jetson Orin NX</li>
<li>Generic x86 (PC)</li>
<li>Polarfire Icicle Kit</li>
<li>Lenovo ThinkPad X1 Carbon Gen 11</li>
</ul>
<h2 id="what-is-new-in-ghaf-2309"><a class="header" href="#what-is-new-in-ghaf-2309">What is New in ghaf-23.09</a></h2>
<ul>
<li>New supported target hardware:
<ul>
<li>NVIDIA Jetson Orin NX</li>
<li>Polarfire Icicle Kit</li>
<li>Lenovo ThinkPad X1 Carbon Gen 11</li>
</ul>
</li>
<li>Modularization of the Ghaf framework: <a href="release_notes/../ref_impl/ghaf-based-project.html">Ghaf as Library: Templates</a>.</li>
<li>NVIDIA Jetson Orin NX Ethernet passthrough.</li>
<li>Lenovo X1 Carbon Gen 11:
<ul>
<li>Graphics passthrough to GUIVM.</li>
<li>Launching Application VMs through GUIVM (Chromium, Gala, and Zathura).</li>
<li>Paravirtualized audio.</li>
<li>Webcam passthrough.</li>
<li>Touchpad passthrough.</li>
</ul>
</li>
<li>Cross-compilation of the ARM targets (NVIDIA) on the x86 server (with demo applications excluded).</li>
</ul>
<h2 id="bug-fixes-2"><a class="header" href="#bug-fixes-2">Bug Fixes</a></h2>
<p>Fixed bugs that were in the ghaf-23.06 release:</p>
<ul>
<li>NVIDIA Jetson AGX Orin:
<ul>
<li>Cannot open Windows launcher via shortcut or command line.</li>
</ul>
</li>
<li>No Windows launcher in x86 build.</li>
</ul>
<h2 id="known-issues-and-limitations-2"><a class="header" href="#known-issues-and-limitations-2">Known Issues and Limitations</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Issue</th><th>Status</th><th>Comments</th></tr></thead><tbody>
<tr><td>Chromium AppVM does not boot up on X1</td><td>In Progress</td><td>Intermittent timing issue, under investigation.</td></tr>
<tr><td>The GALA app does not work</td><td>In Progress</td><td>Will be fixed in the next release.</td></tr>
<tr><td>Shutdown or reboot of Lenovo X1 takes a lot of time (7 minutes)</td><td>In Progress</td><td>Advice: be patient or, if in hurry, press power key for 15 sec.</td></tr>
<tr><td>Copy and paste text from or to Chromium AppVM does not work</td><td>In Progress</td><td></td></tr>
<tr><td>Element cannot be opened on NVIDIA AGX Orin HW on the host</td><td>Will not Fix</td><td>Applications on the host will not be supported in the longer term.</td></tr>
<tr><td>Cannot move the GALA/Element window by dragging with the mouse</td><td>In Progress</td><td>Workaround: press Windows key when moving the mouse.</td></tr>
<tr><td>Personal security keys cannot be created</td><td>In Progress</td><td>Workaround: use another device to create security keys.</td></tr>
<tr><td>No audio in a USB headset when running the application on the host</td><td>Will not Fix</td><td>Audio on a host is not supported.</td></tr>
<tr><td>Cannot log in to the Element chat with a Google account</td><td>In Progress</td><td>Workaround for x86: create a user specifically for Element.</td></tr>
<tr><td>Windows launcher application does not work</td><td>In Progress</td><td>Workaround: launch Windows VM from the command line.</td></tr>
</tbody></table>
</div>
<h2 id="environment-requirements-2"><a class="header" href="#environment-requirements-2">Environment Requirements</a></h2>
<p>There are no specific requirements for the environment with this release.</p>
<h2 id="installation-instructions-2"><a class="header" href="#installation-instructions-2">Installation Instructions</a></h2>
<p>Released images are available at <a href="https://vedenemo.dev/files/releases/ghaf_23.09/">vedenemo.dev/files/releases/ghaf_23.09/</a>.</p>
<p>Download the required image and use the following instructions:</p>
<div class="table-wrapper"><table><thead><tr><th>Release Image</th><th>Build and Run</th></tr></thead><tbody>
<tr><td>ghaf-23.09_Generic_x86.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#running-ghaf-image-for-x86-computer">Running Ghaf Image for x86 Computer</a></td></tr>
<tr><td>ghaf-23.09_Lenovo_X1_Gen11.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#running-ghaf-image-for-lenovo-x1">Running Ghaf Image for Lenovo X1</a></td></tr>
<tr><td>ghaf-23.09_Nvidia_Orin_AGX.tar.xz, ghaf-23.09_Nvidia_Orin_NX.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#ghaf-image-for-nvidia-jetson-orin-agx">Ghaf Image for NVIDIA Jetson Orin AGX</a></td></tr>
<tr><td>ghaf-23.09_PolarFire_RISC-V.tar.xz</td><td><a href="release_notes/../ref_impl/build_and_run.html#building-ghaf-image-for-microchip-icicle-kit">Building Ghaf Image for Microchip Icicle Kit</a></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="release-ghaf-2306"><a class="header" href="#release-ghaf-2306">Release ghaf-23.06</a></h1>
<h2 id="release-branch-3"><a class="header" href="#release-branch-3">Release Branch</a></h2>
<p><a href="https://github.com/tiiuae/ghaf/tree/ghaf-23.06">https://github.com/tiiuae/ghaf/tree/ghaf-23.06</a></p>
<h2 id="supported-hardware-3"><a class="header" href="#supported-hardware-3">Supported Hardware</a></h2>
<p>The following target hardware is supported by this release:</p>
<ul>
<li>NXP i.MX 8QM-MEK</li>
<li>NVIDIA Jetson AGX Orin</li>
<li>Generic x86 (PC)</li>
</ul>
<h2 id="what-is-new-in-ghaf-2306"><a class="header" href="#what-is-new-in-ghaf-2306">What is New in ghaf-23.06</a></h2>
<ul>
<li>Ghaf Modularization (partially done):
<ul>
<li>general description and context on how to use: <a href="release_notes/../ref_impl/ghaf-based-project.html">Ghaf as Library: Templates</a></li>
<li>the development status: <a href="https://github.com/tiiuae/ghaf/tree/ghaf-23.06/modules">https://github.com/tiiuae/ghaf/tree/ghaf-23.06/modules</a>.</li>
</ul>
</li>
<li>SLSA v1.0 level provenance file included.</li>
<li>Ghaf version information (query).</li>
<li>NixOS is updated to 23.05: <a href="https://discourse.nixos.org/t/nixos-23-05-released/28649">NixOS 23.05 released!</a></li>
</ul>
<h2 id="bug-fixes-3"><a class="header" href="#bug-fixes-3">Bug Fixes</a></h2>
<p>Build time is used as the current time on NVIDIA Jetson AGX Orin.</p>
<h2 id="known-issues-and-limitations-3"><a class="header" href="#known-issues-and-limitations-3">Known Issues and Limitations</a></h2>
<ul>
<li>Known since ghaf-23.05:
<ul>
<li>Personal security keys cannot be created.</li>
<li>NVIDIA Jetson AGX Orin: —Åannot open windows-launcher using a shortcut or a command line.</li>
<li>No audio in a USB headset.</li>
<li>Cannot log in to the Element chat with a Google account
<ul>
<li>Workaround for x86: create a separate user account for Element.</li>
</ul>
</li>
</ul>
</li>
<li>Element cannot be opened on NVIDIA Jetson AGX Orin.</li>
<li>Cannot move the GALA/Element window by dragging with the mouse.</li>
<li>No windows-launcher in the x86 build.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="release-ghaf-2305"><a class="header" href="#release-ghaf-2305">Release ghaf-23.05</a></h1>
<h2 id="release-branch-4"><a class="header" href="#release-branch-4">Release Branch</a></h2>
<p><a href="https://github.com/tiiuae/ghaf/tree/ghaf-23.05">https://github.com/tiiuae/ghaf/tree/ghaf-23.05</a></p>
<h2 id="supported-hardware-4"><a class="header" href="#supported-hardware-4">Supported Hardware</a></h2>
<p>The following target hardware is supported by this release:</p>
<ul>
<li>NXP i.MX 8QM-MEK</li>
<li>NVIDIA Jetson AGX Orin</li>
<li>Generic x86 (PC)</li>
</ul>
<h2 id="what-is-new-in-ghaf-2305"><a class="header" href="#what-is-new-in-ghaf-2305">What is New in ghaf-23.05</a></h2>
<p>This is the first release of Ghaf including support for:</p>
<ul>
<li>the Wayland display server protocol (on the host)</li>
<li>the graphical interface with Weston Window Manager (on the host)</li>
<li>the Chromium browser (on the host)</li>
<li>Element, a Matrix-based chat client (on the host)</li>
<li>the Google Android look-alike (GALA) application</li>
</ul>
<blockquote>
<p>Ghaf Framework is under active development, some of the features may not be stable.</p>
</blockquote>
<h2 id="known-issues-and-limitations-4"><a class="header" href="#known-issues-and-limitations-4">Known Issues and Limitations</a></h2>
<ul>
<li>Build time is used as the current time on NVIDIA Jetson AGX Orin.
<ul>
<li>Prevents logging into GALA and Element applications.</li>
</ul>
</li>
<li>Personal security keys cannot be created:
<ul>
<li>Prevents running Android in the Cloud.</li>
<li>Workaround: use another device to create security keys.</li>
</ul>
</li>
<li>NVIDIA Jetson AGX Orin: —Åannot open windows-launcher using a shortcut or a command line.</li>
<li>No audio in a USB headset.</li>
<li>Cannot log in to the Element chat with a Google account.
<ul>
<li>Workaround: create a separate user account for Element.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="showcases"><a class="header" href="#showcases">Showcases</a></h1>
<p>The Ghaf Platform can be used in various different environments, configurations, and hardware to serve several purposes. Ghaf is not a fully-fledged product but a module that can serve as a centerpiece to enable secure edge systems.</p>
<h3 id="secure-laptop"><a class="header" href="#secure-laptop">Secure Laptop</a></h3>
<p>Secure Laptop demonstrates how our open-source Ghaf Platform can increase the security offering for laptops through hardware-backed isolation by means of virtualization. We use Lenovo ThinkPad X1 Carbon Gen 11 as a target device.</p>
<p>In this showcase, the following applications are running in isolated VMs:</p>
<ul>
<li><a href="scenarios/./run_win_vm.html">Windows VM</a></li>
<li>Browser VM that can be used as an application launcher. For example, MS Office suite running in the Browser environment. All data is stored in the enterprise cloud.</li>
<li>PDF Viewer VM. No data can be extracted or shared locally.</li>
<li><a href="scenarios/./run_cuttlefish.html">Cloud Android VM</a> for secure communication.</li>
</ul>
<p>Each VM operates independently and securely within its own isolated environment, without interference from other VMs running on the same physical hardware. Additionally beneath the surface Ghaf contains two hidden system VMS:</p>
<ul>
<li><a href="scenarios/../architecture/adr/netvm.html">Networking VM</a></li>
<li><a href="scenarios/../architecture/stack.html#system-vms">GUI VM</a></li>
</ul>
<p><img src="scenarios/../img/secure_laptop.drawio.png" alt="Ghaf Secure Laptop" title="Secure laptop with custom OS framework Ghaf" /></p>
<h2 id="in-this-chapter-5"><a class="header" href="#in-this-chapter-5">In This Chapter</a></h2>
<ul>
<li><a href="scenarios/./run_win_vm.html">Running Windows VM on Ghaf</a></li>
<li><a href="scenarios/./run_cuttlefish.html">Running Cuttlefish on Ghaf</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="running-windows-11-in-vm-on-ghaf"><a class="header" href="#running-windows-11-in-vm-on-ghaf">Running Windows 11 in VM on Ghaf</a></h1>
<p>You can run Windows 11 in a VM on Ghaf with NVIDIA Jetson Orin AGX (ARM64) or Generic x86 device. This method uses <a href="https://www.qemu.org/">QEMU</a> as VMM. For information on how to build and run a Ghaf image, see <a href="scenarios/../ref_impl/build_and_run.html">Build and Run</a>.</p>
<p><img src="scenarios/../img/windows_in_vm.png" alt="Windows 11 in VM" /></p>
<h2 id="getting-windows-11-image"><a class="header" href="#getting-windows-11-image">Getting Windows 11 Image</a></h2>
<ol>
<li>
<p>Depending on the device:</p>
<ul>
<li>For Generic x86, download Windows 11 ISO (<a href="https://www.microsoft.com/software-download/windows11">Win11_22H2_English_x64v2.iso</a>) from the Microsoft website.</li>
<li>For NVIDIA Jetson Orin AGX (ARM64), use your Microsoft account to join the <a href="https://insider.windows.com/en-us/register">Windows Insider Program</a>. On the Windows 11 on Arm Insider Preview page, select the <code>Windows 11 Client Arm64 Insider Preview (Canary) - Build 25324</code> build and the language to download a VHDX image file.</li>
</ul>
</li>
<li>
<p>Copy the image to an external USB drive. Connect the USB drive to the device with the latest version of Ghaf installed, and mount it to some folder.</p>
<pre><code>sudo mkdir /mnt
sudo mount /dev/sda /mnt
</code></pre>
<blockquote>
<p><strong>WARNING:</strong> [For NVIDIA Jetson Orin AGX] Make sure to use a fresh VHDX image file that was not booted in another environment before.</p>
</blockquote>
</li>
</ol>
<h2 id="running-windows-11-in-vm"><a class="header" href="#running-windows-11-in-vm">Running Windows 11 in VM</a></h2>
<h4 id="running-windows-11-in-vm-on-arm64-device-nvidia-jetson-orin-agx"><a class="header" href="#running-windows-11-in-vm-on-arm64-device-nvidia-jetson-orin-agx">Running Windows 11 in VM on ARM64 Device (NVIDIA Jetson Orin AGX)</a></h4>
<ol>
<li>
<p>In the Weston terminal, go to the directory with the Windows 11 image and run the VM without sudo and as a non-root user using the following Ghaf script:</p>
<pre><code>cd /mnt
windows-launcher ./Windows11_InsiderPreview_Client_ARM64_en-us_25324.VHDX
</code></pre>
</li>
<li>
<p>Windows 11 requires Internet access to finish the setup. To boot the VM without an Internet connection, open cmd with Shift+F10 and type <code>OOBE\BYPASSNRO</code>. After the configuration restart click ‚ÄúI don‚Äôt have internet‚Äú to skip the Internet connection step and continue the installation.</p>
<blockquote>
<p>TIP: If after pressing Shift+F10 the command window is not displayed, try to switch between opened windows by using Alt+Tab.</p>
</blockquote>
</li>
</ol>
<h4 id="running-windows-11-in-vm-on-generic-x86-device"><a class="header" href="#running-windows-11-in-vm-on-generic-x86-device">Running Windows 11 in VM on Generic x86 Device</a></h4>
<p>On x86_64 device Windows 11 VM can be launched with either an ISO image or QCOW2:</p>
<ul>
<li>For an ISO image, the script creates an empty QCOW2 image in the same directory which is used as a system disk in the VM.</li>
<li>After installing Windows 11, run the script for the QCOW2 image.</li>
</ul>
<p>Do the following:</p>
<ol>
<li>
<p>In the Weston terminal, go to the directory with the Windows 11 image and run the VM without sudo and as a non-root user using the following Ghaf script:</p>
<pre><code>cd /mnt
windows-launcher ./Win11_22H2_English_x64v2.iso
</code></pre>
</li>
<li>
<p>When the VM starts booting press any key to boot from a CD.</p>
</li>
<li>
<p>In order to bypass Windows 11 system requirements, open cmd with Shift+F10 and type <code>regedit</code>. In HKEY_LOCAL_MACHINE\SYSTEM\Setup, right-click New &gt; Key and type LabConfig. For this key create two DWORD (32-bit) parameters:</p>
<ul>
<li>Name: <code>BypassTPMCheck</code>, value <code>1</code>.</li>
<li>Name: <code>BypassSecureBootCheck</code>, value <code>1</code>.</li>
</ul>
<blockquote>
<p>TIP: [For Ghaf running on a laptop] If after pressing Shift+F10 the command window is not displayed, try again with the Fn key (Shift+Fn+F10) or switch between opened windows by using Alt+Tab.</p>
</blockquote>
</li>
<li>
<p>Install Windows 11 in the VM.</p>
</li>
<li>
<p>Windows 11 requires Internet access to finish the setup. To boot the VM without an Internet connection, open cmd with Shift+F10 and type <code>OOBE\BYPASSNRO</code>. After the configuration restart click ‚ÄúI don‚Äôt have internet‚Äú to skip the Internet connection step and continue the installation.</p>
</li>
<li>
<p>After the installation is completed the script is launched with the QCOW2 image:</p>
<pre><code>windows-launcher ./win11.qcow2
</code></pre>
</li>
</ol>
<h2 id="using-ui-to-launch-windows-11-vm"><a class="header" href="#using-ui-to-launch-windows-11-vm">Using UI to Launch Windows 11 VM</a></h2>
<p>Instead of running Windows launcher from the command line it is possible to launch the Windows 11 VM by clicking the corresponding icon in the Weston taskbar.</p>
<p>When you click it for the first time, you will see a file selection dialog. Once Windows 11 image has been selected, it saves the path to the <code>~/.config/windows-launcher-ui.conf</code> configuration file and launches the VM. Next time, the VM will be immediately launched with one click.</p>
<p>In order to use a different image instead of the saved one, delete the configuration file:</p>
<pre><code>rm ~/.config/windows-launcher-ui.conf
</code></pre>
<h2 id="passing-additional-parameters-to-qemu"><a class="header" href="#passing-additional-parameters-to-qemu">Passing Additional Parameters to QEMU</a></h2>
<p>It is possible to pass additional parameters to QEMU when running Windows launcher from the command line.</p>
<p>NVIDIA Jetson Orin AGX (ARM64) example:</p>
<pre><code>windows-launcher ./Windows11_InsiderPreview_Client_ARM64_en-us_25324.VHDX -serial stdio
</code></pre>
<p>Generic x86 example:</p>
<pre><code>windows-launcher ./win11.qcow2 -serial stdio
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="running-android-cuttlefish-virtual-device-on-ghaf"><a class="header" href="#running-android-cuttlefish-virtual-device-on-ghaf">Running Android Cuttlefish Virtual Device on Ghaf</a></h1>
<p>Cuttlefish is a configurable virtual Android device (virtual-machine based Android emulator) that can run both remotely (using third-party cloud offerings such as Google Cloud Engine) and locally (on Linux x86 machines). For more information about Cuttlefish, see the official <a href="https://source.android.com/docs/setup/create/cuttlefish">Cuttlefish Virtual Android Devices</a> documentation.</p>
<p>You can run Android as a VM on Ghaf for testing and development purposes using NVIDIA Jetson Orin AGX (ARM64) or Generic x86.</p>
<h2 id="installing-cuttlefish"><a class="header" href="#installing-cuttlefish">Installing Cuttlefish</a></h2>
<ol>
<li>
<p>Download <em>host_package</em> (includes binaries and scripts that must be run on the host machine to set up and run the Cuttlefish virtual device) and <em>aosp_cf_phone-img</em> (a system image) files from the Android CI server and copy them to Ghaf:</p>
<ul>
<li>For NVIDIA Jetson Orin AGX (ARM64): <a href="https://ci.android.com/builds/submitted/9970479/aosp_cf_arm64_phone-userdebug/latest/cvd-host_package.tar.gz">cvd-host_package.tar.gz</a> and <a href="https://ci.android.com/builds/submitted/9970479/aosp_cf_arm64_phone-userdebug/latest/aosp_cf_arm64_phone-img-9970479.zip">aosp_cf_arm64_phone-img-9970479.zip</a></li>
<li>For Generic x86: <a href="https://ci.android.com/builds/submitted/9970479/aosp_cf_x86_64_phone-userdebug/latest/cvd-host_package.tar.gz">cvd-host_package.tar.gz</a> and <a href="https://ci.android.com/builds/submitted/9970479/aosp_cf_x86_64_phone-userdebug/latest/aosp_cf_x86_64_phone-img-9970479.zip">aosp_cf_x86_64_phone-img-9970479.zip</a></li>
</ul>
<blockquote>
<p>Download a host package from the same build as the image.</p>
</blockquote>
</li>
<li>
<p>Make sure Internet connection is working in Ghaf. If the system gets an IP address but the DNS server is not responding, set the correct date and time.</p>
</li>
<li>
<p>[For x86_64 only] Install the required packages:</p>
<pre><code>NIXPKGS_ALLOW_UNSUPPORTED_SYSTEM=1 nix-env -i python3 openssl bash unzip
</code></pre>
</li>
<li>
<p>Create some hackish links that are required for running Cuttlefish:</p>
<pre><code>sudo ln -s $(which mv) /bin/mv
sudo ln -s $(which bash) /bin/bash
sudo mkdir -p /usr/lib/cuttlefish-common/bin/
sudo touch /usr/lib/cuttlefish-common/bin/capability_query.py
sudo chmod 755 /usr/lib/cuttlefish-common/bin/capability_query.py
sudo groupadd -f cvdnetwork
sudo usermod -aG cvdnetwork $USER
sudo usermod -aG kvm $USER
sudo su ghaf
</code></pre>
</li>
<li>
<p>Change directory to the one that contains host package and image files and extract them:</p>
<ul>
<li>
<p>For NVIDIA Jetson Orin AGX (ARM64):</p>
<pre><code>tar xvf cvd-host_package.tar.gz
unzip aosp_cf_arm64_phone-img-9970479.zip
</code></pre>
</li>
<li>
<p>For Generic x86:</p>
<pre><code>tar xvf cvd-host_package.tar.gz
unzip aosp_cf_x86_64_phone-img-9970479.zip
</code></pre>
</li>
</ul>
</li>
<li>
<p>[For x86_64 only] Extra steps to fix missing dependencies:</p>
<ul>
<li>
<p>Find ld-linux-x86-64.so.2 and create a link in <code>/lib64</code>:</p>
<pre><code>sudo find /nix/store -name ld-linux-x86-64.so.2
sudo mkdir /lib64
sudo ln -s /nix/store/dg8mpqqykmw9c7l0bgzzb5znkymlbfjw-glibc-2.37-8/lib/ld-linux-x86-64.so.2 /lib64
</code></pre>
</li>
<li>
<p>Find libdrm.so.2 in the <code>/nix/store</code> and copy it to the lib64 directory where the host package was extracted:</p>
<pre><code>sudo find /nix/store -name libdrm.so.2
cp /nix/store/2jdx0r0yiz1k38ra0diwqm5akb0k1rjh-libdrm-2.4.115/lib/ ./lib64
</code></pre>
</li>
</ul>
</li>
</ol>
<h2 id="running-cuttlefish"><a class="header" href="#running-cuttlefish">Running Cuttlefish</a></h2>
<p>Go to the directory with exctacted host package and image files and run Cuttlefish:</p>
<pre><code>HOME=$PWD ./bin/launch_cvd -report_anonymous_usage_stats=n
</code></pre>
<p>It will take some time to load. There should be the following messages in the console when the VM is booted and ready to use:</p>
<pre><code>VIRTUAL_DEVICE_DISPLAY_POWER_MODE_CHANGED
VIRTUAL_DEVICE_BOOT_STARTED
VIRTUAL_DEVICE_BOOT_COMPLETED
Virtual device booted successfully
</code></pre>
<h2 id="connecting-to-cuttlefish-device"><a class="header" href="#connecting-to-cuttlefish-device">Connecting to Cuttlefish Device</a></h2>
<ol>
<li>
<p>Run the Chromium browser by clicking on the corresponding icon in Weston and navigate to <a href="https://localhost:8443">https://localhost:8443</a>. Ignore a warning about the SSL certificate (‚ÄúYour connection is not private‚Äú) and click <strong>Advanced</strong> &gt; <strong>Proceed to 127.0.0.1 (unsafe)</strong>.</p>
</li>
<li>
<p>Click the <strong>cvd-1 Connect</strong> button. A new tab with an Android VM window will be opened.</p>
</li>
<li>
<p>[Optionally] You can close the browser and use the following command to open a standalone window with an Android VM:</p>
</li>
</ol>
<pre><code>chromium-browser --enable-features=UseOzonePlatform --ozone-platform=wayland --new-window --app=https://127.0.0.1:8443/client.html?deviceId=cvd-1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>This is a glossary of terms and abbreviations developed by the Ghaf team.</p>
<p><strong>Abbreviation</strong> is a shortened form of a word or phrase. Usually is used to save space and time, to avoid repetition of long words and phrases.</p>
<p>The styling of abbreviations is inconsistent and includes several possible variations. Some abbreviations are formed by omitting all but the first few letters of a word. Such abbreviations usually end in a period: Mr. for mister, Oct. for October.</p>
<p>When abbreviations are formed from the initial letters of a phrase, they are categorized as either <strong>initialisms</strong> or <strong>acronyms</strong>:</p>
<ul>
<li>
<p>With <strong>initialisms</strong>, each letter is pronounced separately. For example: FBI for Federal Bureau of Investigation, CIA for Central Intelligence Agency, CD for Compact Disk, and also OK for Okay, ‚Äòorl korrekt‚Äò that is a misspelling of "all correct". Initialisms cannot be pronounced as words.</p>
</li>
<li>
<p><strong>Acronyms</strong> are another type of abbreviation formed from the initial letters but that are pronounced as if they were words themselves. For example: ROFL for ‚Äòrolling on the floor laughing‚Äô, FEMA for Federal Emergency Management Agency, NATO for North Atlantic Treaty Organization.</p>
</li>
</ul>
<p>All acronyms are abbreviations, but not all abbreviations are acronyms. ASAP that comes from ‚Äòas soon as possible‚Äô and appt (for appointment) are both considered abbreviations, but only ASAP is an acronym.</p>
<h3 id="appropriate-use-of-articles-before-abbreviations"><a class="header" href="#appropriate-use-of-articles-before-abbreviations">Appropriate Use of Articles before Abbreviations</a></h3>
<ul>
<li>Articles (a, an, the) are common with initialisms. The indefinite article should be chosen according to the first sound‚Äînot the first letter:
<ul>
<li>‚ÄòA‚Äô is correct before initialisms beginning with a consonant sound, including a vowel pronounced as a ‚Äòw‚Äô or ‚Äòy‚Äô sound. For example: ‚Äòa NASA launch‚Äô, but ‚ÄòNASA launches take place‚Äô.</li>
<li>When an initialism begins with a vowel sound (including silent consonants or a consonant pronounced with an initial vowel sound), ‚Äòan‚Äô should be used instead. For example, ‚Äòread about an FBI raid‚Äô.</li>
</ul>
</li>
<li>Acronyms not require articles except when they are used adjectivally. For example: ‚Äòthe patient was diagnosed with AIDS‚Äô, but ‚Äòthe AIDS patient‚Äô; ‚Äòthe NASA launch takes place‚Äô.</li>
</ul>
<p>So, read the abbreviation aloud: it may be either an initialism or an acronym. Focus on the sounds, not on the letters: ‚Äò<em>an</em> unidentified flying object‚Äô but ‚Äò<em>a</em> UFO‚Äô as it pronounced ‚Äúa YOO-ef-OH‚Äù (/ÀåjuÀê…õfÀà…ô ä/). More examples: a EULA (‚ÄúYOO-luh‚Äù), a LAN router, an XML file, an HTML page.</p>
<h3 id="trivia"><a class="header" href="#trivia">Trivia</a></h3>
<p>If you do not find the term or abbreviation you are looking for, share your questions using <a href="https://github.com/tiiuae/ghaf/issues">GitHub Issues</a>.</p>
<p>Wikipedia is not a dictionary.</p>
<hr />
<p>Groups of terms and abbreviations:</p>
<ul>
<li><a href="appendices/glossary.html#project-related">Project Related</a></li>
<li><a href="appendices/glossary.html#core-concepts">Core Concepts</a></li>
<li><a href="appendices/glossary.html#scs-related">SCS Related</a></li>
</ul>
<hr />
<h2 id="project-related"><a class="header" href="#project-related">Project Related</a></h2>
<h3 id="ghaf"><a class="header" href="#ghaf">Ghaf</a></h3>
<p><em>The project code name that represents the Ghaf tree.</em><br />
Source: <a href="https://connectwithnature.ae/knowledge-hub/ghaf-tree">https://connectwithnature.ae/knowledge-hub/ghaf-tree</a></p>
<h3 id="cicd"><a class="header" href="#cicd">CI/CD</a></h3>
<p><em>Continuous Integration and Continuous Delivery is a Ghaf software development lifecycle. Continuous Integration refers to regularly integrating code changes into a shared repository, where they are automatically tested and verified. Continuous Delivery‚Äîsoftware is released in short iterations.</em></p>
<blockquote>
<p>Currently, Continuous Deployment is not set up. Continuous Deployment‚Äîcode is deployed to customers automatically.</p>
</blockquote>
<h3 id="ssrc"><a class="header" href="#ssrc">SSRC</a></h3>
<p><em>Secure Systems Research Center is a global center of excellence in the development of end-to-end security and resilience for cyber-physical and autonomous systems. SSRC is a part of TII.</em><br />
Source: <a href="https://www.tii.ae/secure-systems">https://www.tii.ae/secure-systems</a></p>
<h3 id="tii"><a class="header" href="#tii">TII</a></h3>
<p><em>Technology Innovation Institute is a UAE-based research center that aims to lead global advances in artificial intelligence, autonomous robotics, quantum computing, cryptography and quantum communications, directed energy, secure communication, smart devices, advanced materials, and propulsion and space technologies.</em><br />
Source: <a href="https://www.tii.ae/">https://www.tii.ae/</a></p>
<hr />
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="adr"><a class="header" href="#adr">ADR</a></h3>
<p><em>An Architecture Decision (AD) is a justified software design choice that addresses a functional or non-functional requirement that is architecturally significant. An Architectural Decision Record (ADR) captures a single AD and its rationale; the collection of ADRs created and maintained in a project constitute its decision log.</em><br />
Source: <a href="https://adr.github.io/">https://adr.github.io/</a></p>
<h3 id="bpmp"><a class="header" href="#bpmp">BPMP</a></h3>
<p><em>Boot and Power Management Processor. The NVIDIA processor provides a set of hardware functions that support booting process handling and offloading the power management, clock management, and reset control tasks from the CPU.</em><br />
Source: <a href="https://developer.download.nvidia.com/assets/embedded/secure/jetson/agx_orin/Orin-TRM_DP10508002_v1.2p.pdf?iuc0WbcuowCBOIVqmVy-NHasaaKLPPoH_J74-C98Mnf_nPX-3LeG7pG9bUoWq28u9X2cW9dNB5bbIJwjmGcuGpdG3BErfZoaGTB0lzfWAUrpxZcO0nP9Z8SW4whsNkrGn6RFSM5_P9if4YR2RVXWLzjwoXbpzRWBvBk_De_WBM_4Erk=&amp;t=eyJscyI6IndlYnNpdGUiLCJsc2QiOiJkZXZlbG9wZXIubnZpZGlhLmNvbS9lbWJlZGRlZC9kb3dubG9hZHMifQ==">NVIDIA Orin Series System-on-Chip, Technical Reference Manual, Version: 1.2, Date: 29-September-2023</a></p>
<h3 id="bsp"><a class="header" href="#bsp">BSP</a></h3>
<p><em>A board support package is a collection of software used to boot and run the embedded system.</em></p>
<h3 id="dhcp"><a class="header" href="#dhcp">DHCP</a></h3>
<p><em>The Dynamic Host Configuration Protocol is a network protocol that automatically sets IP addresses and other attributes to enable information transfer between network nodes.</em><br />
Source: Computer Networks: A Systems Approach, <a href="https://book.systemsapproach.org/internetworking/basic-ip.html#host-configuration-dhcp">https://book.systemsapproach.org/internetworking/basic-ip.html#host-configuration-dhcp</a></p>
<h3 id="dma"><a class="header" href="#dma">DMA</a></h3>
<p><em>A direct memory access is a process in which data may be moved directly to or from the main memory of a computer system by operations not under the control of the central processing unit.</em><br />
Source: <a href="https://www.collinsdictionary.com/dictionary/english/direct-memory-access">https://www.collinsdictionary.com/dictionary/english/direct-memory-access</a></p>
<h3 id="emmc-e-mmc"><a class="header" href="#emmc-e-mmc">eMMC, e-MMC</a></h3>
<p><em>embedded MultiMediaCard</em></p>
<h3 id="eula"><a class="header" href="#eula">EULA</a></h3>
<p><em>end-user license agreement</em></p>
<h3 id="fw"><a class="header" href="#fw">FW</a></h3>
<p><em>firmware</em></p>
<h3 id="gala"><a class="header" href="#gala">GALA</a></h3>
<p><em>The Google Android Look Alike application. Mobile client application for connecting to a Cloud Android device in Secured Google Cloud Platform VMs. Users see a remotely rendered Android phone desktop on their own device screen and interact with the Cloud Android device like the real mobile device. All application processing runs in the cloud.</em></p>
<h3 id="gui"><a class="header" href="#gui">GUI</a></h3>
<p><em>graphical user interface</em></p>
<h3 id="ids"><a class="header" href="#ids">IDS</a></h3>
<p><em>An intrusion detection system (also intrusion prevention system or IPS) monitors network traffic for suspicious activity and report when such activity is discovered.</em></p>
<h3 id="iommu"><a class="header" href="#iommu">IOMMU</a></h3>
<p><em>input‚Äìoutput memory management unit</em></p>
<h3 id="ip"><a class="header" href="#ip">IP</a></h3>
<p><em>The Internet Protocol is a set of rules for communication over the Internet, such as sending email, streaming video, or connecting to a website.</em></p>
<h3 id="isa"><a class="header" href="#isa">ISA</a></h3>
<p><em>An Instruction Set Architecture is part of the abstract model of a computer that defines how the CPU is controlled by the software.</em><br />
Source: <a href="https://www.arm.com/glossary/isa">https://www.arm.com/glossary/isa</a></p>
<h3 id="kvm"><a class="header" href="#kvm">KVM</a></h3>
<p><em>Kernel-based Virtual Machine, an open-source virtualization technology built into Linux.</em></p>
<h3 id="kvms"><a class="header" href="#kvms">KVMS</a></h3>
<p><em>Kernel-based Virtual Machine Secured, an open-source project.</em><br />
Source: <a href="https://github.com/jkrh/kvms">https://github.com/jkrh/kvms</a></p>
<h3 id="labwc-labwc"><a class="header" href="#labwc-labwc">labwc, LabWC</a></h3>
<p><em>Lab Wayland Compositor, a window-stacking compositor for Wayland, an open-source project.</em><br />
Source: <a href="https://github.com/labwc/labwc">https://github.com/labwc/labwc</a></p>
<h3 id="mmu"><a class="header" href="#mmu">MMU</a></h3>
<p><em>memory management unit</em></p>
<h3 id="msi"><a class="header" href="#msi">MSI</a></h3>
<p><em>Message Signaled Interrupts</em></p>
<h3 id="nixos"><a class="header" href="#nixos">NixOS</a></h3>
<p><em>A Linux distribution based on the Nix package manager and build system.</em><br />
Source: <a href="https://nixos.wiki/wiki/Overview_of_the_NixOS_Linux_distribution">https://nixos.wiki/wiki/Overview_of_the_NixOS_Linux_distribution</a></p>
<h3 id="oem"><a class="header" href="#oem">OEM</a></h3>
<p><em>original equipment manufacturer</em></p>
<h3 id="os"><a class="header" href="#os">OS</a></h3>
<p><em>operating system</em></p>
<h3 id="pci"><a class="header" href="#pci">PCI</a></h3>
<p><em>Peripheral Component Interconnect</em></p>
<h3 id="pcie"><a class="header" href="#pcie">PCIe</a></h3>
<p><em>Peripheral Component Interconnect Express</em></p>
<h3 id="qemu"><a class="header" href="#qemu">QEMU</a></h3>
<p><em>A generic and open source machine emulator and virtualizer.</em><br />
Source: <a href="https://www.qemu.org/docs/master/about/index.html">QEMU‚Äôs documentation</a></p>
<h3 id="sbsa"><a class="header" href="#sbsa">SBSA</a></h3>
<p><em>The Server Base System Architecture specifies a hardware system architecture, based on Arm 64-bit architecture, that server system software, for example operating systems, hypervisors, and firmware can rely on.</em><br />
Source: <a href="https://developer.arm.com/documentation/den0029/latest">Arm¬Æ Server Base System Architecture 7.1 Platform Design Document</a></p>
<h3 id="sku"><a class="header" href="#sku">SKU</a></h3>
<p><em>A stock keeping unit, is a unique code used by sellers to identify and track products.</em></p>
<h3 id="soc"><a class="header" href="#soc">SoC</a></h3>
<p><em>A system on chip, a microchip that contains the necessary electronic circuits for a fully functional system on a single integrated circuit (IC).</em></p>
<h3 id="ssd"><a class="header" href="#ssd">SSD</a></h3>
<p><em>solid-state drive</em></p>
<h3 id="tcb"><a class="header" href="#tcb">TCB</a></h3>
<p><em>Trusted computing base defines the security requirements by providing separation of users and data or resources.</em><br />
Source: <a href="https://csrc.nist.gov/csrc/media/publications/conference-paper/1998/10/08/proceedings-of-the-21st-nissc-1998/documents/early-cs-papers/dod85.pdf">Department of Defense trusted computer system evaluation criteria, DoD 5200.28-STD, 1985</a></p>
<h3 id="tls"><a class="header" href="#tls">TLS</a></h3>
<p><em>Transport Layer Security, a security protocol.</em></p>
<h3 id="uart"><a class="header" href="#uart">UART</a></h3>
<p><em>An universal asynchronous receiver-transmitter, a hardware communication protocol.</em></p>
<h3 id="uefi"><a class="header" href="#uefi">UEFI</a></h3>
<p><em>Unified Extensible Firmware Interface is a specifications that defines a new model for the interface between personal-computer operating systems and platform firmware.</em><br />
Source: <a href="https://uefi.org/faq">Unified Extensible Firmware Interface Forum</a></p>
<h3 id="ui"><a class="header" href="#ui">UI</a></h3>
<p><em>user interface</em></p>
<h3 id="vfio"><a class="header" href="#vfio">VFIO</a></h3>
<p><em>Virtual Function I/O</em><br />
Source: <a href="https://docs.kernel.org/driver-api/vfio.html">https://docs.kernel.org/driver-api/vfio.html</a></p>
<h3 id="vm"><a class="header" href="#vm">VM</a></h3>
<p><em>virtual machine</em></p>
<h3 id="vmm"><a class="header" href="#vmm">VMM</a></h3>
<p><em>Virtual Machine Manager</em></p>
<h3 id="zta"><a class="header" href="#zta">ZTA</a></h3>
<p><em>zero trust architecture, zero trust security model</em></p>
<hr />
<h2 id="scs-related"><a class="header" href="#scs-related">SCS Related</a></h2>
<h3 id="ca"><a class="header" href="#ca">CA</a></h3>
<p><em>certificate authority</em></p>
<h3 id="cms"><a class="header" href="#cms">CMS</a></h3>
<p><em>Certificate Management System</em></p>
<h3 id="eddsa"><a class="header" href="#eddsa">EdDSA</a></h3>
<p><em>Edwards-curve Digital Signature Algorithm</em></p>
<h3 id="gpg"><a class="header" href="#gpg">GPG</a></h3>
<p><em>The GNU Privacy Guard (also GnuPG) is a complete and free implementation of the OpenPGP standard as defined by RFC4880.</em><br />
Source: <a href="https://gnupg.org/">https://gnupg.org/</a></p>
<h3 id="hsm"><a class="header" href="#hsm">HSM</a></h3>
<p><em>A hardware security module is a crypto processor designed for the crypto key lifecycle protection.</em></p>
<h3 id="openssl"><a class="header" href="#openssl">OpenSSL</a></h3>
<p><em>Cryptography and SSL/TLS Toolkit.</em><br />
Source: <a href="https://www.openssl.org/">https://www.openssl.org/</a></p>
<h3 id="pki"><a class="header" href="#pki">PKI</a></h3>
<p><em>A public key infrastructure is the framework of encryption and cybersecurity.</em></p>
<h3 id="pynacl"><a class="header" href="#pynacl">PyNaCl</a></h3>
<p><em>A Python binding to libsodium, which is a fork of the Networking and Cryptography library.</em><br />
Source: <a href="https://pypi.org/project/PyNaCl/">https://pypi.org/project/PyNaCl/</a></p>
<h3 id="ra"><a class="header" href="#ra">RA</a></h3>
<p><em>registration authority</em></p>
<h3 id="sbom"><a class="header" href="#sbom">SBOM</a></h3>
<p><em>A software bill of materials is a machine-readable document of all software components, open source licenses, and dependencies in a target software.</em></p>
<h3 id="scs"><a class="header" href="#scs">SCS</a></h3>
<p><em>A supply chain security is a process of securing the machinery of the development, building, and release environment.</em></p>
<h3 id="secure-cryptoprocessor"><a class="header" href="#secure-cryptoprocessor">secure cryptoprocessor</a></h3>
<p><em>A security chip that performs encryption and decryption operations.</em></p>
<h3 id="software-artifact"><a class="header" href="#software-artifact">software artifact</a></h3>
<p><em>An immutable blob of data; primarily refers to software, but SLSA can be used for any artifact.</em><br />
Source: <a href="https://slsa.dev/spec/v0.1/terminology">https://slsa.dev/spec/v0.1/terminology</a></p>
<h3 id="slsa"><a class="header" href="#slsa">SLSA</a></h3>
<p><em>Supply chain Levels for Software Artifacts is a security framework, a check-list of standards and controls to prevent tampering, improve integrity, and secure packages and infrastructure in your projects, businesses or enterprises.</em><br />
Source: <a href="https://slsa.dev/">https://slsa.dev/</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="research-notes"><a class="header" href="#research-notes">Research Notes</a></h1>
<p>Our experience in research, studies and lessons learned activities:</p>
<ul>
<li><a href="research/passthrough/ethernet.html">i.MX 8QM platform bus ethernet passthrough</a></li>
<li><a href="research/installation.html">System installation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="imx-8qm-ethernet-passthrough"><a class="header" href="#imx-8qm-ethernet-passthrough">i.MX 8QM Ethernet Passthrough</a></h1>
<p>The i.MX 8QuadMax (i.MX 8QM, iMX8QM, imx8qm) passthrough host setup relies as much as possible on the default i.MX 8QM MEK (imx8qm-mek) device tree configuration. Some guidance on what is required for passthrough to work on i.MX 8 can be found in the XEN device trees.</p>
<p>This document provides a detailed description of what has been done and why. For the more impatient readers, the example device tree files for i.MX 8QM guest and host with Ethernet passthrough are available here:</p>
<ul>
<li>Full host device tree: <a href="research/passthrough/imx8qm-mek_conn-host.dts">imx8qm-mek_conn-host.dts</a></li>
<li>Full guest device tree: <a href="research/passthrough/imx8qm-mek_conn-guest.dts">imx8qm-mek_conn-guest.dts</a></li>
</ul>
<p><strong>NOTE 20.12.2022:</strong>
At the current state, the passthrough is not completely functional. The Ethernet device (fec1) or even both devices (fec1 and fec2) can be set up in the guest. The devices respond and seem functional, the device node does activate, the drivers load correctly, the power state of the device changes to active, and the link state of the Ethernet connection seems to change correctly. However, for some reason, no actual Ethernet data packages go through the Ethernet adapter. The most visible issue is that no interrupts come to the Ethernet devices.</p>
<p>See the following topics:</p>
<ul>
<li><a href="research/passthrough/ethernet.html#imx-8qm-ethernet-passthrough">i.MX 8QM Ethernet Passthrough</a>
<ul>
<li><a href="research/passthrough/ethernet.html#host-kernel-configuration">Host Kernel Configuration</a></li>
<li><a href="research/passthrough/ethernet.html#host-device-tree-explained">Host Device Tree Explained</a>
<ul>
<li><a href="research/passthrough/ethernet.html#other-notes-about-passthrough">Other Notes About Passthrough</a></li>
</ul>
</li>
<li><a href="research/passthrough/ethernet.html#changes-in-u-boot">Changes in U-Boot</a></li>
<li><a href="research/passthrough/ethernet.html#running-platform-device-passthrough-in-qemu">Running Platform Device Passthrough in QEMU</a></li>
<li><a href="research/passthrough/ethernet.html#guest-setup">Guest Setup</a>
<ul>
<li><a href="research/passthrough/ethernet.html#adding-devices-to-guest">Adding Devices to Guest</a></li>
<li><a href="research/passthrough/ethernet.html#some-final-touches-for-guest-devices">Some Final Touches for Guest Devices</a></li>
</ul>
</li>
<li><a href="research/passthrough/ethernet.html#compiling-the-device-tree-source-to-binary-form">Compiling the Device Tree Source to Binary Form</a>
<ul>
<li><a href="research/passthrough/ethernet.html#compiling-for-guest">Compiling for Guest</a></li>
<li><a href="research/passthrough/ethernet.html#compiling-for-host">Compiling for Host</a></li>
</ul>
</li>
<li><a href="research/passthrough/ethernet.html#running-qemu-with-passthrough-platform-devices">Running QEMU with Passthrough Platform Devices</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="host-kernel-configuration"><a class="header" href="#host-kernel-configuration">Host Kernel Configuration</a></h2>
<p>Kernel version 5.10 was used during the setup. For the passthrough to work, a few kernel configuration options need to be added to the default i.MX 8QM configuration:</p>
<ul>
<li>CONFIG_VFIO_PLATFORM=y</li>
<li>CONFIG_IOMMU_DEFAULT_PASSTHROUGH=y</li>
<li>CONFIG_VFIO_PLATFORM=y</li>
<li>CONFIG_ARM_SMMU_V3_SVA=y</li>
</ul>
<h2 id="host-device-tree-explained"><a class="header" href="#host-device-tree-explained">Host Device Tree Explained</a></h2>
<p>The default Freescale i.MX 8QM MEK configuration is included and then updated to get the Ethernet device passthrough configuration added on top of the original device configuration.</p>
<p>There are two problems with using the i.MX 8 XEN configuration as a reference. The first issue is that the configuration between XEN and KVM do not map one to one. The second issue is more specific to Ethernet passthrough, as i.MX 8 XEN configuration does not set up passthrough for Ethernet so most of the configuration needs to be figured out from scratch.</p>
<pre><code>#include "freescale/imx8qm-mek.dts"
/ {
    domu {
        /*
        * There are 5 MUs, 0A is used by Dom0, 1A is used
        * by ATF, so for DomU, 2A/3A/4A could be used.
        * SC_R_MU_0A
        * SC_R_MU_1A
        * SC_R_MU_2A
        * SC_R_MU_3A
        * SC_R_MU_4A
        * The rsrcs and pads will be configured by uboot scu_rm cmd
        */
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;0&gt;;
        doma {
            compatible = "xen,domu";
            /*
            * The name entry in VM configuration file
            * needs to be same as here.
            */
            domain_name = "DomU";
            /*
            * The reg property will be updated by U-Boot to
            * reflect the partition id.
            */
            reg = &lt;0&gt;;
            
            /*
            * Initialize and activate the Mailbox MU2A at boot
            */
            init_on_rsrcs = &lt;
                IMX_SC_R_MU_2A
            &gt;;

            /*
            * Mark the Mailbox and Ethernet adapter power domains available to guest
            */
            rsrcs = &lt;
                IMX_SC_R_MU_2A
                IMX_SC_R_ENET_0
            &gt;;

            /* 
            * Mark the pads for ethernet adapter fec1 available to guest
            */
            pads = &lt;
                IMX8QM_ENET0_MDIO
                IMX8QM_ENET0_MDC
                IMX8QM_ENET0_REFCLK_125M_25M

                IMX8QM_ENET0_RGMII_TXC
                IMX8QM_ENET0_RGMII_TX_CTL
                IMX8QM_ENET0_RGMII_TXD0
                IMX8QM_ENET0_RGMII_TXD1
                IMX8QM_ENET0_RGMII_TXD2
                IMX8QM_ENET0_RGMII_TXD3
                IMX8QM_ENET0_RGMII_RXC
                IMX8QM_ENET0_RGMII_RX_CTL
                IMX8QM_ENET0_RGMII_RXD0
                IMX8QM_ENET0_RGMII_RXD1
                IMX8QM_ENET0_RGMII_RXD2
                IMX8QM_ENET0_RGMII_RXD3
                IMX8QM_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB

                IMX8QM_SCU_GPIO0_07
                IMX8QM_SPI0_CS1
                IMX8QM_SPI2_CS1
                IMX8QM_SAI1_RXFS
                IMX8QM_SAI1_RXC
            &gt;;

            /* GPIOS as default from imxqm XEN device tree */
            gpios = &lt;&amp;lsio_gpio1 13 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 19 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 27 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 28 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 30 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 1 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 3 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 6 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 9 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 11 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 19 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 22 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 25 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 26 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 27 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 29 GPIO_ACTIVE_LOW&gt;;
        };
    };
};

/*
 * Add iommus property for the passed through device nodes to allow setting up vfio  
 * The device type "compatible" is changed to prevent the system from loading a  
 * driver the the adapter.  
 * Most other properties are removed from the adapter.
 */
&amp;fec1 {
    iommus = &lt;&amp;smmu 0x12 0x7f80&gt;;
    compatible = "fsl,dummy";
    status = "okay";

    /delete-property/ power-domains;
    /delete-property/ clocks;
    /delete-property/ clock-names;
    /delete-property/ assigned-clocks;
    /delete-property/ assigned-clock-rates;
    /delete-property/ phy-handle;
    /delete-property/ pinctrl-names;
    /delete-property/ pinctrl-0;
};

/* 
 * The device is not being used by guest. Just to make sure it is removed from iommu
 * group and disabled.
 */
&amp;fec2 {
    /delete-property/ iommus;
    status = "disabled";
};

/*
 * Timer device for fec1
&amp;enet0_lpcg {
    iommus = &lt;&amp;smmu 0x12 0x7f80&gt;;
    compatible = "fsl,dummy";
    status = "okay";
    /delete-property/ power-domains;
    /delete-property/ clocks;
    /delete-property/ clock-names;
    /delete-property/ assigned-clocks;
    /delete-property/ assigned-clock-rates;
    /delete-property/ pinctrl-0;
};

&amp;enet1_lpcg {
    /delete-property/ iommus;
    status = "disabled";
};

&amp;lsio_mu2 {
    iommus = &lt;&amp;smmu 0x12 0x7f80&gt;;
    compatible = "fsl,dummy";
    status = "okay";
};

/*
* Remove iommus properties from other devices which are not passed through for  Network VM
*/
&amp;usdhc1 {
    /delete-property/ iommus;
};

&amp;usdhc2 {
    /delete-property/ iommus;
};

&amp;usdhc3 {
    /delete-property/ iommus;
};

&amp;sata {
    /delete-property/ iommus;
};

&amp;usbotg3 {
    /delete-property/ iommus;
};

&amp;usbotg3_cdns3 {
    /delete-property/ iommus;
};
</code></pre>
<h3 id="other-notes-about-passthrough"><a class="header" href="#other-notes-about-passthrough">Other Notes About Passthrough</a></h3>
<ul>
<li>All devices which belong to the same VFIO/IOMMU group need to be passed through to the guest.</li>
<li>To prevent the device from being initialized by the host, change the device-compatible property to a dummy such as "fsl,dummy".</li>
<li>The device status need needs to be "okay" for the device node to be available.</li>
<li>If U-Boot finds devices that appear in the doma <em>rsrcs</em> that contains the properties listed below, the device will get removed from the DTB:
<ul>
<li>power-domains</li>
<li>clocks</li>
<li>clock-names</li>
<li>assigned-clocks</li>
<li>assigned-clock-rates</li>
<li>pinctrl-0</li>
</ul>
</li>
</ul>
<h2 id="changes-in-u-boot"><a class="header" href="#changes-in-u-boot">Changes in U-Boot</a></h2>
<p>In our host device tree, we defined a couple of "rsrcs" resources to be handed over to the guest system. The ownership of these registers needs to be transferred to the guest after loading our device tree and before the actual boot. This can be done in U-Boot with a command:</p>
<pre><code>scu_rm dtb ${fdt_addr}
</code></pre>
<p>The easiest way to accomplish this automatically during boot is to add the "scu_rm" to the default i.MX 8QM U-Boot "boot_os" command and save the changes as below:</p>
<pre><code>setenv boot_os 'scu_rm dtb ${fdt_addr}; booti ${loadaddr} - ${fdt_addr};'
saveenv
</code></pre>
<h2 id="running-platform-device-passthrough-in-qemu"><a class="header" href="#running-platform-device-passthrough-in-qemu">Running Platform Device Passthrough in QEMU</a></h2>
<p>Before you start QEMU, the passedthrough devices need to be bind to the VFIO driver.</p>
<p>In some cases, the default driver needs to be unbind before the device can be bind to VFIO. However, in this case, all devices were changed to use the dummy device type in the device tree, so the step below is not required for this setup.</p>
<pre><code>echo 5d1d0000.mailbox &gt; /sys/bus/platform/devices/5d1d0000.mailbox/driver/unbind
echo 5b040000.ethernet &gt; /sys/bus/platform/devices/5b040000.ethernet/driver/unbind
echo 5b230000.clock-controller &gt; /sys/bus/platform/devices/5b230000.clock-controller/driver/unbind
</code></pre>
<p>The VFIO driver allows user-level access to the devices. Binding required devices to VFIO can be done as below:</p>
<pre><code>echo vfio-platform  &gt; /sys/bus/platform/devices/5d1d0000.mailbox/driver_override
echo 5d1d0000.mailbox &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b040000.ethernet/driver_override
echo 5b040000.ethernet &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b230000.clock-controller/driver_override
echo 5b230000.clock-controller &gt; /sys/bus/platform/drivers/vfio-platform/bind
</code></pre>
<p>After binding the devices to VFIO so it is possible to pass the devices to QEMU using "<strong>-device vfio-platform</strong>" arguments as below. The order in which the device arguments are given to QEMU may have an effect on some device properties such as interrupts.</p>
<pre><code>-device vfio-platform,host=5b230000.clock-controller
-device vfio-platform,host=5b040000.ethernet
-device vfio-platform,host=5d1d0000.mailbox
</code></pre>
<h2 id="guest-setup"><a class="header" href="#guest-setup">Guest Setup</a></h2>
<p>Before starting the virtual machine with passed-through devices, we need to define our virtual machine device tree. One way of gaining a template for our QEMU device tree is by starting our QEMU instance and requesting a dump of its device tree in the DTB format as below.</p>
<p>DTB is a binary format of the device tree so we also need to use the command line tool device tree compiler <strong>dtc</strong> to convert the binary device tree to a more human-friendly device tree source format. Converting the device tree to source format may give a few warnings of missing or unrecognized properties and such but that is normal.</p>
<pre><code>qemu-system-aarch64 \
    -M virt,gic-version=host,dumpdtb=virt.dtb -enable-kvm -nographic

# Convert binary to source device tree format
dtc -I dtb -O dts virt.dtb &gt; virt.dts
</code></pre>
<p>This will provide a "<strong>virt.dts</strong>" file which can be used as a base for adding our passedthrough devices. The U-Boot device tree may change based on the U-Boot version, so the guest device tree may need some maintenance every now and then.</p>
<h3 id="adding-devices-to-guest"><a class="header" href="#adding-devices-to-guest">Adding Devices to Guest</a></h3>
<p>The platform devices which are going to get passed through should be added to the QEMU device tree <strong>platform</strong> bus section.</p>
<p>In this case, the main devices are <strong>fec1</strong>, <strong>enet0_lpcg</strong> and <strong>lsio_mu2</strong>. At the time of writing, the platform bus address in QEMU is "<strong>c000000</strong>" but that can be changed within the following code (needs recompiling QEMU) or it might change during some the QEMU code update.</p>
<pre><code>platform@c000000 {
	compatible = "qemu,platform\0simple-bus";
	interrupt-parent = &lt;0x8001&gt;;
	#address-cells = &lt;0x02&gt;;
	#size-cells = &lt;0x02&gt;;

    /* Devices register remapping 
	// ranges = &lt;0xc000000 0x00 0xc000000 0x2000000&gt;;
	ranges = &lt;0x00 0x5b230000 0x00 0xc000000 0x00 0x10000&gt;,
			 &lt;0x00 0x5b040000 0x00 0xc010000 0x00 0x10000&gt;,
			 &lt;0x00 0x5d1d0000 0x00 0xc020000 0x00 0x10000&gt;;

    /*
    * Fec1 device configuration
    * Mostly the same that was set in the original host device configuration
    * The original interrupts can be left here as reference but they are updated at the end of config
    */
    fec1: ethernet@5b040000 {
        reg = &lt;0x00 0x5b040000 0x00 0x10000&gt;;
        interrupts = &lt;GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH&gt;;
        clocks = &lt;&amp;enet0_lpcg 4&gt;,
            &lt;&amp;enet0_lpcg 2&gt;,
            &lt;&amp;enet0_lpcg 3&gt;,
            &lt;&amp;enet0_lpcg 0&gt;,
            &lt;&amp;enet0_lpcg 1&gt;;
        clock-names = "ipg", "ahb", "enet_clk_ref", "ptp", "enet_2x_txclk";
        assigned-clocks = &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_PM_CLK_PER&gt;,
                &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_C_CLKDIV&gt;;
        assigned-clock-rates = &lt;250000000&gt;, &lt;125000000&gt;;
        fsl,num-tx-queues=&lt;1&gt;;
        fsl,num-rx-queues=&lt;1&gt;;
        power-domains = &lt;&amp;pd IMX_SC_R_ENET_0&gt;;
        status = "okay";
    };

    /*
    * Fec1 devices clock controller device configuration
    * Mostly the same that was set in the original host device configuration
    * The actual clocks are nor configured so those need to be added to guest
    */
    enet0_lpcg: clock-controller@5b230000 {
        compatible = "fsl,imx8qxp-lpcg";
        reg = &lt;0x00 0x5b230000 0x00 0x10000&gt;;
        #clock-cells = &lt;1&gt;;
        clocks = &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_PM_CLK_PER&gt;,
            &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_PM_CLK_PER&gt;,
            &lt;&amp;conn_axi_clk&gt;,
            &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_C_TXCLK&gt;,
            &lt;&amp;conn_ipg_clk&gt;,
            &lt;&amp;conn_ipg_clk&gt;;
        bit-offset = &lt;0 4 8 12 16 20&gt;;
        clock-output-names = "enet0_lpcg_timer_clk",
                    "enet0_lpcg_txc_sampling_clk",
                    "enet0_lpcg_ahb_clk",
                    "enet0_lpcg_rgmii_txc_clk",
                    "enet0_lpcg_ipg_clk",
                    "enet0_lpcg_ipg_s_clk";
        power-domains = &lt;&amp;pd IMX_SC_R_ENET_0&gt;;
        status = "okay";
    };

    /*
    * Mailbox device for Fec1 (and SCU)
    * The host needs its own Mailbox (lsio_mu1 by default) and SCU
    * The original interrupt can be left here as reference but that is updated at the end of config
    */
    lsio_mu2: mailbox@5d1d0000 {
		compatible = "fsl,imx8-mu-scu", "fsl,imx8qm-mu", "fsl,imx6sx-mu";
		reg = &lt;0x00 0x5d1d0000 0x00 0x10000&gt;;
        interrupts = &lt;GIC_SPI 178 IRQ_TYPE_LEVEL_HIGH&gt;;
		#mbox-cells = &lt;0x02&gt;;
		status = "okay";
	};
};
</code></pre>
<p>The actual devices which were passed through may have some dependencies (such as clocks) which also need to be configured in the guest for the main devices to work properly. In most cases, they can be just copy-pasted from the original host configuration with a few minor alterations. Required dependencies need a bit of manual labor and depend on case to case.</p>
<p>The main key is to go through the whole original device tree and list out device node names that are used by the passedthrough devices. This may require several passes as the dependencies may also contain some dependencies of their own. On top of the requirements, it is good also to check if the passedthrough devices are used by some other devices.</p>
<p>Some devices may be used through a controller, such as <strong>lsio_mu2</strong> is used by the main system control unit <strong>scu</strong>. In this case, the dependencies consist of several clock devices and their controller and also the i.MX 8 system control unit <strong>SCU</strong> device with its internals.</p>
<p>The assisting devices can be added just before the start "<strong>platform@c000000</strong>" bus configuration section:</p>
<pre><code>/**
 * Several clocks and a regulator copied from original host config.
 **/
clk_dummy: clock-dummy {
	compatible = "fixed-clock";
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;0&gt;;
	clock-output-names = "clk_dummy";
};

xtal32k: clock-xtal32k {
	compatible = "fixed-clock";
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;32768&gt;;
	clock-output-names = "xtal_32KHz";
};

xtal24m: clock-xtal24m {
	compatible = "fixed-clock";
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;24000000&gt;;
	clock-output-names = "xtal_24MHz";
};

reg_fec2_supply: fec2_nvcc {
	compatible = "regulator-fixed";
	regulator-name = "fec2_nvcc";
	regulator-min-microvolt = &lt;1800000&gt;;
	regulator-max-microvolt = &lt;1800000&gt;;
//	gpio = &lt;&amp;max7322 0 GPIO_ACTIVE_HIGH&gt;;
	enable-active-high;
	status = "okay";
};

conn_axi_clk: clock-conn-axi {
	compatible = "fixed-clock";
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;333333333&gt;;
	clock-output-names = "conn_axi_clk";
};

conn_ahb_clk: clock-conn-ahb {
	compatible = "fixed-clock";
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;166666666&gt;;
	clock-output-names = "conn_ahb_clk";
};

conn_ipg_clk: clock-conn-ipg {
	compatible = "fixed-clock";
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;83333333&gt;;
	clock-output-names = "conn_ipg_clk";
};

conn_bch_clk: clock-conn-bch {
	compatible = "fixed-clock";
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;400000000&gt;;
	clock-output-names = "conn_bch_clk";
};

/**
 * imx8 SCU device and its content with changed to use "lsio_mu2" mailbox
 * The original scu used lsio_mu1 so we need to use one of lsio_mu2 to lsio_mu4
 **/
scu {
	compatible = "fsl,imx-scu";
	mbox-names = "tx0", "rx0", "gip3";
	mboxes = &lt;&amp;lsio_mu2 0 0
		&amp;lsio_mu2 1 0
		&amp;lsio_mu2 3 3&gt;;

	pd: imx8qx-pd {
		compatible = "fsl,imx8qm-scu-pd", "fsl,scu-pd";
		#power-domain-cells = &lt;1&gt;;
		status = "okay";

		wakeup-irq = &lt;235 236 237 258 262 267 271
				345 346 347 348&gt;;
	};

	clk: clock-controller {
		compatible = "fsl,imx8qm-clk", "fsl,scu-clk";
		#clock-cells = &lt;2&gt;;
		clocks = &lt;&amp;xtal32k &amp;xtal24m&gt;;
		clock-names = "xtal_32KHz", "xtal_24Mhz";
	};

	iomuxc: pinctrl {
		compatible = "fsl,imx8qm-iomuxc";
	};

	ocotp: imx8qm-ocotp {
		compatible = "fsl,imx8qm-scu-ocotp";
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;1&gt;;
		read-only;

		fec_mac0: mac@1c4 {
			reg = &lt;0x1c4 6&gt;;
		};

		fec_mac1: mac@1c6 {
			reg = &lt;0x1c6 6&gt;;
		};
	};

	rtc: rtc {
		compatible = "fsl,imx8qm-sc-rtc";
	};

	watchdog {
		compatible = "fsl,imx8qm-sc-wdt", "fsl,imx-sc-wdt";
		timeout-sec = &lt;60&gt;;
	};

	tsens: thermal-sensor {
		compatible = "fsl,imx-sc-thermal";
		tsens-num = &lt;6&gt;;
		#thermal-sensor-cells = &lt;1&gt;;
	};
};

/**
 * And the platform bus that was done earlier would start from here..
 */
platform@c000000 {
    ...
};
</code></pre>
<h3 id="some-final-touches-for-guest-devices"><a class="header" href="#some-final-touches-for-guest-devices">Some Final Touches for Guest Devices</a></h3>
<p>Now we have most of the actual devices setup. Some final modifications for individual devices can be done at the end of the guest device tree configuration. These can be done outside the main node, as we just modify some node properties which are already defined.</p>
<pre><code>/**
 * For fec1 we need to update the interrupts to match the ones used by guest pass-through.
 * Most of the configuration is exactly the same that was set original imx8 config
 * Qemu starts its pass-through interrupts at 0x70 so lets change that
 * It is not strictly required to remove the possible iommus property but lets do that anyway
 */
&amp;fec1 {
    compatible = "fsl,imx8qm-fec", "fsl,imx6sx-fec";
    interrupts = &lt;GIC_SPI 0x70 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 0x71 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 0x72 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 0x73 IRQ_TYPE_LEVEL_HIGH&gt;;
    /delete-property/ iommus;
    pinctrl-names = "default";
    pinctrl-0 = &lt;&amp;pinctrl_fec1&gt;;
    phy-mode = "rgmii-txid";
    phy-handle = &lt;&amp;ethphy0&gt;;
    fsl,magic-packet;
    nvmem-cells = &lt;&amp;fec_mac0&gt;;
    nvmem-cell-names = "mac-address";
    status = "okay";

    mdio {
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;0&gt;;

        ethphy0: ethernet-phy@0 {
            compatible = "ethernet-phy-ieee802.3-c22";
            reg = &lt;0&gt;;
            at803x,eee-disabled;
            at803x,vddio-1p8v;
            qca,disable-smarteee;
            vddio-supply = &lt;&amp;vddio0&gt;;

            vddio0: vddio-regulator {
                regulator-min-microvolt = &lt;1800000&gt;;
                regulator-max-microvolt = &lt;1800000&gt;;
            };
        };
    };
};

/**
 * Not much to do for clock controller
 * Remove the iommus as it is not needed in guest and turn the device on
 */
&amp;enet0_lpcg {
    status = "okay";
    /delete-property/ iommus;
};

/**
 * Same for our mailbox
 * Update the interrupts to match next available interrupt in Qemu
 */
&amp;lsio_mu2 {
    compatible = "fsl,imx8-mu-scu", "fsl,imx8qm-mu", "fsl,imx6sx-mu";
    interrupts = &lt;GIC_SPI 0x74 IRQ_TYPE_LEVEL_HIGH&gt;;
    /delete-property/ iommus;
    status = "okay";
};

/**
 * In the host devicetree we had some pads which were transferred to guest.
 * There can be found in the original imx8 hosts config.
 **/
&amp;iomuxc {
    pinctrl-names = "default";
    status = "okay";

    pinctrl_fec1: fec1grp {
        fsl,pins = &lt;
            IMX8QM_COMP_CTL_GPIO_1V8_3V3_ENET_ENETA_PAD		0x000014a0
            IMX8QM_ENET0_MDC_CONN_ENET0_MDC				0x06000020
            IMX8QM_ENET0_MDIO_CONN_ENET0_MDIO			0x06000020
            IMX8QM_ENET0_RGMII_TX_CTL_CONN_ENET0_RGMII_TX_CTL	0x06000020
            IMX8QM_ENET0_RGMII_TXC_CONN_ENET0_RGMII_TXC		0x06000020
            IMX8QM_ENET0_RGMII_TXD0_CONN_ENET0_RGMII_TXD0		0x06000020
            IMX8QM_ENET0_RGMII_TXD1_CONN_ENET0_RGMII_TXD1		0x06000020
            IMX8QM_ENET0_RGMII_TXD2_CONN_ENET0_RGMII_TXD2		0x06000020
            IMX8QM_ENET0_RGMII_TXD3_CONN_ENET0_RGMII_TXD3		0x06000020
            IMX8QM_ENET0_RGMII_RXC_CONN_ENET0_RGMII_RXC		0x06000020
            IMX8QM_ENET0_RGMII_RX_CTL_CONN_ENET0_RGMII_RX_CTL	0x06000020
            IMX8QM_ENET0_RGMII_RXD0_CONN_ENET0_RGMII_RXD0		0x06000020
            IMX8QM_ENET0_RGMII_RXD1_CONN_ENET0_RGMII_RXD1		0x06000020
            IMX8QM_ENET0_RGMII_RXD2_CONN_ENET0_RGMII_RXD2		0x06000020
            IMX8QM_ENET0_RGMII_RXD3_CONN_ENET0_RGMII_RXD3		0x06000020
        &gt;;
    };
};
</code></pre>
<p>With our additional devices also some headers and definitions need to be included at the beginning of the device tree. These additions can be found also from the original i.MX 8 device tree files. See the full device tree below for reference.</p>
<h2 id="compiling-the-device-tree-source-to-binary-form"><a class="header" href="#compiling-the-device-tree-source-to-binary-form">Compiling the Device Tree Source to Binary Form</a></h2>
<p>The device trees need to be compiled within the Linux kernel source directory. They depend on some kernel device tree headers and in the host device case‚Äîother device tree source files.</p>
<ul>
<li>Full host device tree: <a href="research/passthrough/imx8qm-mek_conn-host.dts">imx8qm-mek_conn-host.dts</a></li>
<li>Full guest device tree: <a href="research/passthrough/imx8qm-mek_conn-guest.dts">imx8qm-mek_conn-guest.dts</a></li>
</ul>
<h3 id="compiling-for-guest"><a class="header" href="#compiling-for-guest">Compiling for Guest</a></h3>
<pre><code>cpp -nostdinc -I include -I arch  -undef -x assembler-with-cpp \
    arch/arm64/boot/dts/freescale/imx8qm-mek_conn-guest.dts imx8qm-mek_conn-guest.dts.preprocessed; \
    dtc -I dts -O dtb -p 0x1000 imx8qm-mek_conn-guest.preprocessed -o imx8qm-mek_conn-guest.dtb
</code></pre>
<h3 id="compiling-for-host"><a class="header" href="#compiling-for-host">Compiling for Host</a></h3>
<pre><code>cpp -nostdinc -I include -I arch  -undef -x assembler-with-cpp \
    arch/arm64/boot/dts/freescale/imx8qm-mek_conn-host.dts imx8qm-mek_conn-host.dts.preprocessed; \
    dtc -I dts -O dtb -p 0x1000 imx8qm-mek_conn-host.preprocessed -o imx8qm-mek_conn-host.dtb
</code></pre>
<h2 id="running-qemu-with-passthrough-platform-devices"><a class="header" href="#running-qemu-with-passthrough-platform-devices">Running QEMU with Passthrough Platform Devices</a></h2>
<p>To get passthrough working, i.MX 8 QM needs to be booted using our freshly built hosts <strong>imx8qm-mek_conn-host.dtb</strong> device tree file.</p>
<p>When the system has booted, we need to set up the passedthrough devices for the VFIO driver and start QEMU with devices passed through.</p>
<p>First, the devices need to be setup for VFIO:</p>
<pre><code>echo vfio-platform  &gt; /sys/bus/platform/devices/5d1d0000.mailbox/driver_override
echo 5d1d0000.mailbox &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b040000.ethernet/driver_override
echo 5b040000.ethernet &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b230000.clock-controller/driver_override
echo 5b230000.clock-controller &gt; /sys/bus/platform/drivers/vfio-platform/bind
</code></pre>
<p>After, QEMU can be started with our devices over the devices.</p>
<p>This is just as an example. It may require a bit of change in other environments.</p>
<p>In this example, the guest kernel image‚Äîext2 rootfs and guest device tree‚Äîall use the same filename prefix <strong>imx8qm-mek_conn-guest</strong>.</p>
<pre><code>qemu-system-aarch64 \
    -M virt,gic-version=host -enable-kvm \
    -cpu host \
    -m 512M \
    -kernel "imx8qm-mek_conn-guest.Image" \
    -drive file="imx8qm-mek_conn-guest.ext2",if=virtio,format=raw -dtb "imx8qm-mek_conn-guest.dtb" \
    -nographic \
    -append "loglevel=7 rootwait root=/dev/vda console=ttyAMA0 earlycon earlyprintk" \
    -device vfio-platform,host=5b230000.clock-controller \
    -device vfio-platform,host=5b040000.ethernet \
    -device vfio-platform,host=5d1d0000.mailbox
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2024 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="approaches-to-ghaf-system-installation"><a class="header" href="#approaches-to-ghaf-system-installation">Approaches to Ghaf System Installation</a></h1>
<p>A hardened system installation covers multiple phases from establishing trust to the installation process. This section describes developing mechanisms to set up a Ghaf system in target hardware.</p>
<h3 id="ghaf-initial-approach"><a class="header" href="#ghaf-initial-approach">Ghaf Initial Approach</a></h3>
<p>The initial Ghaf installation approach to using Ghaf in development and demos is to build target system raw images (<code>img</code>) as binary disk images. The process results in an image based on modular and configurable declarations that are repeatably built using NixOS tooling.</p>
<p>In practice, Ghaf disk images are built with:</p>
<pre><code>nix build .#package.&lt;hardware-architecture&gt;.&lt;target-device-[release|debug]&gt;
</code></pre>
<p>which results in disk image:</p>
<pre><code>result\nixos.img
</code></pre>
<p>For information on how to build and run a Ghaf image, see <a href="https://tiiuae.github.io/ghaf/ref_impl/build_and_run.html">Build &amp; Run</a> for details.</p>
<p>The initial Ghaf installation approach differed from the NixOS installation approach:</p>
<ul>
<li>The key reason in Ghaf was practical: initially, it is simple to write a specific target disk image to a USB boot media or target HW internal persistent media.</li>
<li>The NixOS approach is more generic: supporting as many devices as possible. Similar to other Linux distributions like Ubuntu or Fedora.</li>
</ul>
<p>The development objective of Ghaf is to support a portable secure system that results in a target device-specific small trusted computing base. In practice, this means that Ghaf installations are by design not meant to support a generic Linux kernel with about all the device drivers (modules) out there like Ubuntu or Fedora. Ghaf reference installations are designed and to be developed to support particular (declaratively) hardened host and guest kernels with limited drivers only. The Ghaf approach significantly reduces the size of the trusted computing base as the unneeded modules and kernel parts are not taken into use.</p>
<h3 id="nixos-approach"><a class="header" href="#nixos-approach">NixOS Approach</a></h3>
<p><a href="https://nixos.org/manual/nixos/stable/#ch-installation">NixOS installation</a> is well documented and thus is only summarized here. The key in the NixOS approach is to have a generic, bootable installation media (<code>iso</code>) like any other Linux distribution. As the NixOS installer aims to support as many devices as possible: the installer has a generic kernel (per hardware architecture), hardware recognition script, and generic requirements for system partitioning (<code>boot</code> and <code>root</code> partitions).</p>
<p>Much of the NixOS installation can be modified interactively during installation either from a graphical installer, manually, or even declaratively. After installation, the whole system can be managed fully declaratively and purely (<code>flakes</code>) which is a novel approach compared to other Linux distributions. In practice, you can store your target system declaration in version control (git) to both maintain the system setup and back it up. Ghaf uses this approach for reference system declarations with <a href="https://github.com/tiiuae/ghaf/blob/main/flake.nix">flake.nix</a>.</p>
<p>NixOS usage is popular in cloud system installations. However many cloud providers do not provide NixOS as an option and bare-metal cloud is always not an alternative. For this need, approaches like <a href="https://github.com/nix-community/nixos-anywhere">nixos-anywhere</a> have been developed. <a href="https://numtide.com/blog/we-dont-need-nixos-cloud-images-anymore-2/">Using a smart approach with <code>kexec</code></a>, one can completely replace cloud provider default Linux options.</p>
<h3 id="modular-interactive"><a class="header" href="#modular-interactive">Modular Interactive</a></h3>
<p>Ghaf introduced a modular structure for an <a href="https://tiiuae.github.io/ghaf/ref_impl/installer.html">interactive installer</a>. The initial Ghaf reference installer still uses a raw disk image per target device. In practice, it just writes the raw disk image to the target device's internal persistent memory, for example, NVMe.</p>
<p>The key idea with the modular interactive Ghaf installer is to enable customization of the installer per target device needs and at the same time support further development of the Ghaf graphical installer.</p>
<p>The challenge with the interactive installer is to determine the combination of configurable options, to develop, and test them. Given the Ghaf approach of target device-specific installation <a href="research/installation.html#ghaf-initial-approach">Ghaf Initial Approach</a>, the requirement for Ghaf a device-specific installer is challenging. Ghaf installer would have to either:</p>
<ul>
<li>embed the device-specific installation raw disk image in the installer (current way) which results in a huge installer image</li>
<li>dynamically build the device-specific installation according to the user's interactive selection</li>
<li>download a pre-built device-specific raw disk image which could result in a huge number of configurations</li>
<li>use some combination of generic and specific (a compromise)</li>
</ul>
<p>None of which seem feasible in the long run. None of these are either Ghaf's objectives in the long run either.</p>
<p>But how to achieve a device-specific secure system installation without getting lost in the generic Linux distro requirements?</p>
<h3 id="declarative-non-interactive-installation"><a class="header" href="#declarative-non-interactive-installation">Declarative, Non-Interactive Installation</a></h3>
<p>Now that we already have version control reference device-specific secure system declarations, the question is if we can transfer those into the device installations without requiring a user too many actions that make the installation unnecessarily difficult to implement.</p>
<p>This alone is not a novel idea. Automatic Original Equipment Manufacturer (OEM) installers have been doing this for long. Those are often not declarative but rather scripted guidance to answer questions in generic installers.</p>
<p>The target device-specific disk partitioning has been left to the user in manual installation. Traditionally in generic installers, it is also risk management. A user typically might not want her device disk wiped out without questions asked. Of course, we could let the user know what is about to happen and ask the user for agreement in confirmation before we install it fully automatically. Declarative configurations can handle user preferences. If one wants to change something, it can be changed in the declarations, stored, and shared via version control. <a href="https://github.com/nix-community/disko">Also including the declarative partitioning</a> that has been tested from within the Ghaf installer.</p>
<p>So, according to the <a href="https://numtide.com/blog/we-dont-need-nixos-cloud-images-anymore-2/">We don't need NixOS cloud images anymore</a> article, one can think that a secure, virtualized edge device could be handled similarly to cloud images. A simple (even secure) boot and installation supporting media could provide secure network access to the installation target device and then deploy the specific installation from declarations. In practice, a target device can be booted with a USB media (or even network boot) that provides SSH access to the device using an authorized key. After that, one command can be used to install specific secure system configuration automatically. This is used in <a href="https://tiiuae.github.io/ghaf/ref_impl/development.html">Ghaf updates in development</a> with <code>nixos-rebuild ... switch</code> and <a href="https://github.com/tiiuae/ghaf/pull/340">was also tested with new (clean) systems</a>.</p>
<hr />
<h2 id="discussion"><a class="header" href="#discussion">Discussion</a></h2>
<p>As of now, the proposed approach declarative non-interactive approach using the example tooling depends on Internet access. Secure system installation will require steps additional to functional system setup. For example, establishing trust and setting up secrets. Many guidelines instruct to setup secrets in an air-gapped environment (without network access) for a reason. Above mentioned tools <a href="https://github.com/nix-community/disko/issues/408">do not yet support offline installation</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
