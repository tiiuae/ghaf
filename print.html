<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ghaf Framework</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Documentation for TII SSRC Secure Technologies.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> About Ghaf</a></li><li class="chapter-item expanded "><a href="features/features.html"><strong aria-hidden="true">2.</strong> Features</a></li><li class="chapter-item expanded "><a href="architecture/architecture.html"><strong aria-hidden="true">3.</strong> Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/variants.html"><strong aria-hidden="true">3.1.</strong> Architectural Variants</a></li><li class="chapter-item expanded "><a href="architecture/adr.html"><strong aria-hidden="true">3.2.</strong> Architecture Decision Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/adr/minimal-host.html"><strong aria-hidden="true">3.2.1.</strong> Minimal Host</a></li><li class="chapter-item expanded "><a href="architecture/adr/netvm.html"><strong aria-hidden="true">3.2.2.</strong> Networking VM</a></li></ol></li><li class="chapter-item expanded "><a href="architecture/stack.html"><strong aria-hidden="true">3.3.</strong> Stack</a></li></ol></li><li class="chapter-item expanded "><a href="technologies/technologies.html"><strong aria-hidden="true">4.</strong> Technologies</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="technologies/passthrough.html"><strong aria-hidden="true">4.1.</strong> Passthrough</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="technologies/nvidia_agx_pt_uart.html"><strong aria-hidden="true">4.1.1.</strong> NVIDIA Jetson AGX Orin: UART Passthrough</a></li><li class="chapter-item expanded "><a href="technologies/nvidia_agx_pt_pcie.html"><strong aria-hidden="true">4.1.2.</strong> NVIDIA Jetson AGX Orin: PCIe Passthrough</a></li></ol></li><li class="chapter-item expanded "><a href="technologies/hypervisor_options.html"><strong aria-hidden="true">4.2.</strong> Hypervisor Options</a></li></ol></li><li class="chapter-item expanded "><a href="ref_impl/reference_implementations.html"><strong aria-hidden="true">5.</strong> Reference Implementations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ref_impl/usage.html"><strong aria-hidden="true">5.1.</strong> Usage</a></li><li class="chapter-item expanded "><a href="ref_impl/development.html"><strong aria-hidden="true">5.2.</strong> Development</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ref_impl/build_and_run.html"><strong aria-hidden="true">5.2.1.</strong> Build and Run</a></li><li class="chapter-item expanded "><a href="ref_impl/cross_compilation.html"><strong aria-hidden="true">5.2.2.</strong> Cross-Compilation</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="scs/scs.html"><strong aria-hidden="true">6.</strong> Supply Chain Security</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="scs/slsa-framework.html"><strong aria-hidden="true">6.1.</strong> SLSA Framework</a></li><li class="chapter-item expanded "><a href="scs/basics.html"><strong aria-hidden="true">6.2.</strong> Basic Security Measures</a></li><li class="chapter-item expanded "><a href="scs/sbom.html"><strong aria-hidden="true">6.3.</strong> Software Bill of Materials</a></li><li class="chapter-item expanded "><a href="scs/pki.html"><strong aria-hidden="true">6.4.</strong> Public Key Infrastructure</a></li><li class="chapter-item expanded "><a href="scs/patching-automation.html"><strong aria-hidden="true">6.5.</strong> Patch Management Automation</a></li></ol></li><li class="chapter-item expanded "><a href="research/research.html"><strong aria-hidden="true">7.</strong> Research Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="research/passthrough/ethernet.html"><strong aria-hidden="true">7.1.</strong> i.MX 8QM Ethernet Passthrough</a></li><li class="chapter-item expanded "><a href="research/run_win_vm.html"><strong aria-hidden="true">7.2.</strong> Running Windows VM on Ghaf</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="appendices/glossary.html">Glossary</a></li><li class="chapter-item expanded affix "><a href="appendices/contributing_general.html">Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ghaf Framework</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/tiiuae/ghaf" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="about-ghaf"><a class="header" href="#about-ghaf">About Ghaf</a></h1>
<p><em><a href="./appendices/glossary.html#ghaf">Ghaf Framework</a></em> is an open-source project that provides information about our work and studies in the security technologies field in the context of embedded virtualization.</p>
<p>The applied software research supports <em><a href="./appendices/glossary.html#ssrc">Secure Systems Research Center</a> (SSRC)</em> focus areas.</p>
<p><em>Ghaf Framework</em> can be used to build the <em>Ghaf Platform</em> that will provide an edge device software architecture with key features such as modularity and scalability through virtualization, support research and development of zero trust architecture (ZTA), and allow for low maintenance efforts while keeping the main code base stable and secure. The SSRC team focus is to research on enhancing ZTA to scale horizontally across edge HW platforms (phones, drones, laptops, communication modules) and vertically across SW platforms (Linux, Android, Browser, applications).</p>
<p>The Ghaf Platform is a baseline software platform for edge devices, utilizing a virtualized architecture for research and product development aiming to achieve the following core objectives: apply the general security principles of zero trust within the software architecture, and act as an enabler for ZTAs within organizations.</p>
<p><img src="./img/ghaf_platform_infrastructure.png" alt="Ghaf Platform Infrastructure" title="Typical devices and infrastructure around the Ghaf Platform" /></p>
<h2 id="embedded-virtualization"><a class="header" href="#embedded-virtualization">Embedded Virtualization</a></h2>
<p>Virtualization is one of the core enablers to transform the traditionally monolithic software stack within edge devices into isolated components with minimal TCB and clearly defined functionality.</p>
<p>The Ghaf Platform utilizes a collection of virtual machines (VMs) to define a system.</p>
<p>Contrary to the traditional monolithic OS, this concept allows to define and run host services in isolated environments, which breaks up the monolithic structure and allows for a modular system definition that is customizable for a specific use case. To this end, various applications and guest OSs can be deployed while simultaneously utilizing the Platform's features. </p>
<h2 id="ghaf-platform-applications"><a class="header" href="#ghaf-platform-applications">Ghaf Platform Applications</a></h2>
<p>The Ghaf Platform development is focused on the transition to a modular architecture for edge devices. Products such as secure phones, drones, laptops, and other communication devices have unique challenges in their respective hardware and software ecosystems.</p>
<p>Enabling the integration of individual technology stacks into an organizational framework can be a challenging task. The Ghaf Platform is designed to ease this process and enable research to overcome a number of challenges.</p>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<p>The design principles influencing the architecture of the Ghaf Platform are the following:</p>
<ul>
<li>
<p>Edge security</p>
<p>The Ghaf security architecture under development by SSRC aims to provide an understandable yet comprehensive view of security controls in the Platform so that vendors can make informed decisions and adopt the Platform for their use cases. The security architecture and subsequent research will be published by SSRC in a series of technical white papers. </p>
</li>
<li>
<p>Zero trust</p>
<p>The Ghaf Platform aims to apply the general security principles of zero trust within the software architecture and to act as an enabler for ZTA for edge devices within organizations. </p>
</li>
<li>
<p>Trusted computing base </p>
<p>The general principle for establishing the trusted Ghaf Platform code base is to rely on audited software and proven security modules while carefully evaluating and integrating new concepts. The modularized platform not only simplifies the integration of additional security measures but also facilitates the integration of hardware security features. Leveraging and contributing to open-source projects is not only a cornerstone for the Platform components' maintainability but also for the toolchain to increase transparency and auditability. By providing a hardened code base for the hypervisor and OS for the various VMs in the architecture, the Ghaf Platform leverages security benefits across all modules.</p>
</li>
<li>
<p>Configurable, declarative and reproducible</p>
</li>
</ul>
<h2 id="build-system-and-supply-chain"><a class="header" href="#build-system-and-supply-chain">Build System and Supply Chain</a></h2>
<p>As software supply chain security becomes more and more relevant to product security, it is necessary to provide mechanisms to assert reproducible builds, with a transparent chain from source code over the build environment to the final binaries. Such a system allows faster analysis of not only software bugs but also security vulnerabilities and their impact on a product without the need for extensive analysis. This approach further reduces the efforts required for patching and allows mechanisms for safe fallbacks to secure states.</p>
<p>For more information on Ghaf supply chain security, see <a href="./scs/scs.html">Supply Chain Security</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="features"><a class="header" href="#features">Features</a></h1>
<p>The vision for the Ghaf platform is to create a virtualized, scalable reference platform that enables the building of secure products leveraging trusted, reusable, and portable software for edge devices. For more information on reference implementation for several devices, see <a href="features/../ref_impl/reference_implementations.html">Reference Implementations</a>.</p>
<p>Ghaf demo desktop and applications are illustrated in the screen capture below:
<img src="features/../img/ghaf_demo_desktop.png" alt="Ghaf demo desktop and application" /> </p>
<h2 id="status"><a class="header" href="#status">Status</a></h2>
<ul>
<li>‚úÖ - integrated and tested in the <code>main</code> branch. No known regression.</li>
<li>üöß - prototyped or work in progress in the development branch.</li>
<li>‚ùå - the feature has known regression or bugs.</li>
</ul>
<h3 id="reference-devices"><a class="header" href="#reference-devices">Reference Devices</a></h3>
<ul>
<li><code>Orin</code>‚ÄîNVIDIA Jetson AGX Orin as the main reference device.</li>
<li><code>x86</code>‚Äîgeneric x86_64; tested on Intel NUC (Next Unit of Computing) or laptop.</li>
<li><code>aarch64</code>‚Äîgeneric AArch64; tested on an ARM server, laptop (e.g. Apple M's), or NVIDIA Jetson AGX Orin.</li>
<li><code>All variants</code>‚Äîsupported devices from <a href="https://tiiuae.github.io/ghaf/architecture/variants.html">Architectural Variants</a>.</li>
</ul>
<p>The following tables show the status of Ghaf Platform features:</p>
<h2 id="release-builds-and-hw-architecture-support"><a class="header" href="#release-builds-and-hw-architecture-support">Release builds and HW architecture support</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Reference Device</th><th>Details</th></tr></thead><tbody>
<tr><td>Ghaf in virtual machine</td><td>‚úÖ</td><td><code>x86</code></td><td><code>nix run .#packages.x86_64-linux.vm-debug</code></td></tr>
<tr><td><code>aarch64</code> reference image</td><td>‚úÖ</td><td><code>Orin</code></td><td>Based on <a href="https://developer.nvidia.com/embedded/jetson-linux">Jetson Linux</a>, <a href="https://github.com/OE4T">OE4T</a> and <a href="https://github.com/anduril/jetpack-nixos">jetpack-nixos</a>.</td></tr>
<tr><td><code>aarch64</code> reference image</td><td>‚úÖ</td><td><code>imx8qm</code></td><td>Based on NXP BSP, implemented as <a href="https://github.com/NixOS/nixos-hardware/tree/master/nxp">nixos-hardware module</a></td></tr>
<tr><td><code>x86</code> generic image</td><td>‚úÖ</td><td><code>x86</code></td><td>Generic x86 computer, based on generic <a href="https://nixos.org/">NixOS</a>. NOTE: requires device specific configuration.</td></tr>
<tr><td>Native build</td><td>‚úÖ</td><td><code>aarch64, x86</code></td><td>Remote <code>aarc64</code> nixos builders recommended</td></tr>
<tr><td>Cross-compilation</td><td>üöß</td><td><code>aarch64</code></td><td>Depends on NixOS <code>nixpkgs 23.05</code> support for cross-compilation</td></tr>
<tr><td>CI builds</td><td>‚úÖ</td><td><code>All</code></td><td><a href="https://vedenemo.dev/">Only <code>main</code>-branch, not for all PRs</a>.</td></tr>
<tr><td>Emulated build</td><td>‚ùå</td><td><code>aarch64</code></td><td><code>binfmt</code>, may freeze the build machine. Not recommended. <a href="https://tiiuae.github.io/ghaf/ref_impl/cross_compilation.html#binfmt">See instructions.</a></td></tr>
</tbody></table>
</div>
<h2 id="development"><a class="header" href="#development">Development</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Reference Device</th><th>Details</th></tr></thead><tbody>
<tr><td>Quick target update</td><td>‚úÖ</td><td><code>all</code></td><td><code>nixos-rebuild --flake .#nvidia-jetson-orin-debug --target-host root@ghaf-host --fast switch</code></td></tr>
<tr><td><code>aarch64</code> device flashing</td><td>‚úÖ</td><td><code>Orin</code></td><td><a href="https://tiiuae.github.io/ghaf/ref_impl/build_and_run.html#flashing-nvidia-jetson-orin-agx">Full device software flashing using <code>x86</code> machine</a></td></tr>
<tr><td>root filesystem flashing</td><td>‚úÖ</td><td><code>x86, imx8qm</code></td><td><code>dd</code> image to bootable media - <a href="https://tiiuae.github.io/ghaf/ref_impl/build_and_run.html#running-ghaf-image-for-x86-computer">see</a></td></tr>
<tr><td>Debug: SSH</td><td>‚úÖ</td><td><code>Orin</code>, <code>x86</code></td><td>Host access only in <code>-debug</code>-target, see <a href="https://github.com/tiiuae/ghaf/blob/main/modules/development/authentication.nix">authentication.nix</a></td></tr>
<tr><td>Debug: Serial</td><td>‚úÖ</td><td><code>all</code></td><td>Host access only in <code>-debug</code>-target - e.g. <code>screen /dev/ttyACM0 115200</code></td></tr>
</tbody></table>
</div>
<h2 id="target-architecture"><a class="header" href="#target-architecture">Target architecture</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Reference Device</th><th>Details</th></tr></thead><tbody>
<tr><td><code>minimal host</code></td><td>üöß</td><td><a href="https://tiiuae.github.io/ghaf/architecture/variants.html"><code>all</code></a></td><td>See <a href="https://tiiuae.github.io/ghaf/architecture/adr/minimal-host.html">Minimal Host</a> and <a href="https://github.com/tiiuae/ghaf/pull/140">PR #140</a>.</td></tr>
<tr><td><code>netvm</code></td><td>‚úÖ</td><td><code>Orin</code></td><td>See <a href="https://tiiuae.github.io/ghaf/architecture/adr/netvm.html">netvm</a>. Passthrough with Wifi works but requires SSID/password configuration</td></tr>
<tr><td><code>idsvm</code></td><td>‚úÖ</td><td><code>Orin</code></td><td><a href="https://github.com/tiiuae/ghaf/pull/146">Defensive security VM placeholder PR open</a></td></tr>
<tr><td><code>guivm</code></td><td>üöß</td><td><code>All</code></td><td>Currently Wayland stack and apps on host for demos. Graphics are host-only for now. <a href="https://github.com/tiiuae/ghaf/pull/118">PCI GPU passthrough and guivm PR open</a></td></tr>
<tr><td><code>adminvm</code></td><td>‚úÖ</td><td><code>All</code></td><td>Not started</td></tr>
<tr><td>Inter VM comms - IP-based</td><td>üöß</td><td><code>All</code></td><td><code>-debug</code>-targets have network bridges to access VMs from host</td></tr>
<tr><td>Inter VM comms - shared memory</td><td>üöß</td><td><code>All</code></td><td></td></tr>
<tr><td>Inter VM Wayland</td><td>üöß</td><td><code>All</code></td><td>Being ported from previous work</td></tr>
<tr><td>SW update</td><td>üöß</td><td><code>All</code></td><td>A/B update tooling being evaluated</td></tr>
<tr><td>USB passthrough</td><td>üöß</td><td><code>Orin</code></td><td>No reference implementation integrated yet</td></tr>
<tr><td>PCI passthrough</td><td>‚úÖ</td><td><code>All</code></td><td>Used for reference in <code>netvm</code> on <code>Orin</code></td></tr>
<tr><td>UART passthrough</td><td>üöß</td><td><code>Orin</code></td><td>See <a href="https://tiiuae.github.io/ghaf/build_config/passthrough/nvidia_agx_pt_uart.html">NVIDIA Jetson AGX Orin: UART Passthrough</a>. Not integrated to any VM.</td></tr>
<tr><td>ARM platform bus devices passthrough</td><td>üöß</td><td><code>Orin</code></td><td>NVIDIA BPMP virtualization being developed</td></tr>
</tbody></table>
</div>
<h2 id="applications-and-vm-control"><a class="header" href="#applications-and-vm-control">Applications and VM control</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Status</th><th>Reference Device</th><th>Details</th></tr></thead><tbody>
<tr><td>Wayland-compositor</td><td>üöß</td><td><code>Orin</code>, <code>x86</code></td><td>On host</td></tr>
<tr><td>Chromium</td><td>üöß</td><td><code>Orin</code>, <code>x86</code></td><td>On host</td></tr>
<tr><td>Element</td><td>üöß</td><td><code>Orin</code>, <code>x86</code></td><td>On host</td></tr>
<tr><td>Cloud Android (CVD) client app (GALA )</td><td>üöß</td><td><code>Orin</code>, <code>x86</code></td><td>On host</td></tr>
<tr><td>Virtualization control</td><td>üöß</td><td><a href="https://tiiuae.github.io/ghaf/architecture/variants.html"><code>All</code></a></td><td>See <a href="https://github.com/tiiuae/vmd/blob/main/doc/design.md">vmd design</a>.</td></tr>
</tbody></table>
</div>
<h2 id="next-steps"><a class="header" href="#next-steps">Next steps</a></h2>
<p><a href="https://github.com/tiiuae/ghaf/issues/150#issuecomment-1564061850">See discussion for the outline of next steps</a> </p>
<p><img src="https://user-images.githubusercontent.com/1027150/241167552-bcb3a3f9-72f3-4b96-af8b-e9df6d1f3d5e.png" alt="Outline of next phases" /> </p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="architecture"><a class="header" href="#architecture">Architecture</a></h1>
<p>The main architectural concept of the Ghaf Platform is to break up the traditional monolithic structure to modularized components, virtual machines (VM). These VMs on hardened host OS implement the Ghaf edge virtualization platform.</p>
<p>Embedded virtualization builds on cloud technologies in the development of end-to-end security. With hardware support for virtualization, we provide a hardened system of a small trusted computing base (TCB)‚Äîthin host‚Äîthat enables isolation of use cases and their resources. Use cases are protected in guest virtual machines (VMs). Embedded targets are small devices (personal or headless) instead of high-performance cloud servers. Our scope is illustrated in the following diagram. For more information, see <a href="architecture/architecture/stack.html">stack</a>.</p>
<p><img src="architecture/./../img/stack.drawio.png" alt="Scope!" title="Embedded Virtualization Scope" /></p>
<p>If you are interested in why we do something <em>this</em> way instead of <em>that</em> way, see <a href="architecture/adr.html">Architecture Decision Records</a>.</p>
<p>The Ghaf Platform components are used in reference configurations to build images for reference devices. For more information, see <a href="architecture/../ref_impl/reference_implementations.html">Reference Implementations</a>.</p>
<h2 id="in-this-chapter"><a class="header" href="#in-this-chapter">In This Chapter</a></h2>
<ul>
<li><a href="architecture/./variants.html">Architectural Variants</a></li>
<li><a href="architecture/./adr.html">Architecture Decision Records</a>
<ul>
<li><a href="architecture/./adr/minimal-host.html">Minimal Host</a></li>
<li><a href="architecture/./adr/netvm.html">Networking VM</a></li>
</ul>
</li>
<li><a href="architecture/./stack.html">Stack</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="architectural-variants"><a class="header" href="#architectural-variants">Architectural Variants</a></h1>
<p>The main scope of the Ghaf platform is edge virtualization. However, to support modular development and testing of the platform, variants are supported with the following definitions:</p>
<ul>
<li>
<p><code>Default</code><br />
A default variant. Supports <a href="architecture/./adr/minimal-host.html">minimal host</a>, GUI VM<sup class="footnote-reference"><a href="#note">1</a></sup> and <a href="architecture/./adr/netvm.html">netvm</a>. May host other VMs. For more information, see <a href="architecture/./stack.html">Stack</a>.</p>
</li>
<li>
<p><code>Headless</code><br />
A variant with <a href="architecture/./adr/minimal-host.html">minimal host</a> and <a href="architecture/./adr/netvm.html">netvm</a>. May host other VMs but does not have GUI VM or graphics stack on a host.</p>
</li>
<li>
<p><code>Host only</code>
A variant with <a href="architecture/./adr/minimal-host.html">minimal host</a> <em>only</em>. A user can manually install software to a host, including VMs (if supported by hardware).</p>
</li>
<li>
<p><code>No virtualization</code>
A variant for hardware with no support for virtualization. May run any software, similar to popular Linux distributions, but cannot support guest virtual machines. May host any software deployed directly on a host.</p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Variant Name</th><th>Headless</th><th>Graphics</th><th>VMs</th><th>Devices</th></tr></thead><tbody>
<tr><td><code>Default</code></td><td>No</td><td>GUI VM <sup class="footnote-reference"><a href="#note">1</a></sup></td><td>Supported</td><td>Jetson, generic x86</td></tr>
<tr><td><code>Headless</code></td><td>Yes</td><td>No</td><td>Supported</td><td>Jetson, generic x86</td></tr>
<tr><td><code>Host Only</code></td><td>Yes</td><td>No</td><td>May be supported but not included</td><td>Jetson, generic x86</td></tr>
<tr><td><code>No Virtualization</code></td><td>Yes or no</td><td>Native on host</td><td>Not supported</td><td>Raspberry Pi, RISC-V</td></tr>
</tbody></table>
</div>
<p><sup class="footnote-reference"><a href="#note">1</a></sup> As of early 2023, the graphics stack is deployed on a host to support application development. Work is ongoing to define the GUI VM and isolate graphics with GPU passthrough.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="architecture-decision-records"><a class="header" href="#architecture-decision-records">Architecture Decision Records</a></h1>
<p>Architecturally significant decisions are recorded as <a href="https://adr.github.io">architecture decision records (ADR)</a>.</p>
<p>The Ghaf platform decision log:</p>
<div class="table-wrapper"><table><thead><tr><th>Decision Record</th><th>Status</th></tr></thead><tbody>
<tr><td><a href="architecture/../architecture/adr/minimal-host.html">Minimal Host</a></td><td>Proposed.</td></tr>
<tr><td><a href="architecture/../architecture/adr/netvm.html">netvm‚ÄîNetworking Virtual Machine</a></td><td>Proposed, partially implemented for development and testing.</td></tr>
</tbody></table>
</div>
<p>To create an architectural decision proposal, open <a href="https://github.com/tiiuae/ghaf/blob/main/CONTRIBUTING.md#contributing-documentation">a pull request</a> and use the <a href="https://github.com/tiiuae/ghaf/blob/main/docs/src/architecture/adr/template.md">decision record template</a>. Contributions to the Ghaf architecture decisions are welcome.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="minimal-host"><a class="header" href="#minimal-host">Minimal Host</a></h1>
<h2 id="status-1"><a class="header" href="#status-1">Status</a></h2>
<p>Proposed</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>Ghaf uses the default NixOS configuration as a baseline to build the target image.</p>
<p>The default NixOS configuration is targeted for more general use with the inclusion of multiple packages that are not supporting the Ghaf design target of a minimal TCB to protect the host. Depending on the flexibility of the NixOS configuration, Ghaf minimal host may require new development to support the requirements.</p>
<p>This structure in the Ghaf host configuration imports the NixOS minimal profile which suits the minimal TCB better. Even better, the modular declarative profile enables the further optimization of the minimal TCB while supporting other profiles that suit the evaluation of other objectives such as feasibility studies of additional functionality,
security and performance.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>Following table describes the development requirements of minimal host. All requirements originate from TII SSRC unless otherwise noted. Scope further defines:</p>
<ul>
<li>target configuration: <code>R</code> for release, <code>D</code> for debug</li>
<li><a href="https://tiiuae.github.io/ghaf/architecture/variants.html">architectural variant</a>: <code>V</code> for
virtualization supporting variant, <code>A</code> for all, including <code>No Virtualization</code></li>
</ul>
<p>Compliance states the progress of requirement compliance as follows:</p>
<ul>
<li><code>D</code> for Designed, design requirement from TII SSRC for analysis and evaluation.</li>
<li><code>I</code> for Implemented, design requirement met with possible, limitations documented
under <a href="architecture/adr/minimal-host.html#consequences">Consequences</a>.</li>
<li><code>P</code> for Proposed, raised for discussion but not yet designed.</li>
<li><code>M</code> for Met, the requirement is reviewed and approved at <a href="https://en.wikipedia.org/wiki/Technology_readiness_level">technology readiness level 4</a>.</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>ID</th><th>Requirement</th><th>Description</th><th>Scope</th><th>Compliance</th></tr></thead><tbody>
<tr><td>MH01</td><td>Defined in <code>nix</code></td><td>Host declaration in <code>nix</code></td><td><code>R&amp;D</code>,<code>A</code></td><td><code>I</code></td></tr>
<tr><td>MH02</td><td>Reduced profile</td><td>Remove unnecessary</td><td><code>R</code>, <code>V</code></td><td><code>I</code></td></tr>
<tr><td>MH03</td><td>No networking</td><td>Host has no networking</td><td><code>R</code>, <code>V</code></td><td><code>D</code></td></tr>
<tr><td>MH04</td><td>No graphics</td><td>Host has no GUI stack</td><td><code>R</code>, <code>V</code></td><td><code>D</code></td></tr>
<tr><td>MH05</td><td>No getty</td><td>Host has no terminal</td><td><code>R</code>, <code>V</code></td><td><code>P</code></td></tr>
<tr><td>MH06</td><td>No nix tooling</td><td>Only <code>/nix/store</code>, no nix</td><td><code>R</code>, <code>V</code></td><td><code>P</code></td></tr>
<tr><td>MH07</td><td>Minimal defconfig</td><td>Host kernel is minimized</td><td><code>R</code>, <code>V</code></td><td><code>D</code></td></tr>
<tr><td>MH08</td><td>Update via adminvm</td><td>A/B update outside host</td><td><code>R</code>, <code>V</code></td><td><code>P</code></td></tr>
<tr><td>MH09</td><td>Read-only filesystem</td><td>Mounted RO, integrity checked</td><td><code>R</code>, <code>V</code></td><td><code>P </code></td></tr>
</tbody></table>
</div>
<p>This list of requirements is not yet comprehensive and may be changed based on findings of further analysis as stated in the following section.</p>
<h2 id="decision"><a class="header" href="#decision">Decision</a></h2>
<p>This ADR adopts a custom developed minimal profile using nixpkgs. It reduces both image and root partition size by eliminating the host OS content per requirements and implements a minimal TCB.</p>
<p>The current implementation of NixOS overridden. For more information on a minimal host profile, see <a href="https://github.com/tiiuae/ghaf/blob/main/modules/host/minimal.nix">minimal.nix</a>.</p>
<p>With the progress of implementing the requirements, the minimal host customization will be illustrated.</p>
<h2 id="consequences"><a class="header" href="#consequences">Consequences</a></h2>
<h3 id="defined-in-nix-mh01"><a class="header" href="#defined-in-nix-mh01">Defined in <code>nix</code> (MH01)</a></h3>
<p>Ghaf minimal host module is implemented in <a href="https://github.com/tiiuae/ghaf/tree/main/modules/host"><code>nix</code> modules</a>.
Currently, host and VM declarations are implemented using <a href="https://github.com/tiiuae/ghaf/blob/main/modules/host/microvm.nix">microvm.nix</a> but this is not strict requirement for ghaf release mode declarations if the limitations or dependencies of microvm.nix do not comply with other requirements. This may require separate release mode custom nix declarations to support flexibility with microvm.nix in debug mode.</p>
<h3 id="reduced-profile-mh02"><a class="header" href="#reduced-profile-mh02">Reduced profile (MH02)</a></h3>
<p>Initial Ghaf minimal profile host size reduction <a href="https://github.com/tiiuae/ghaf/pull/95">is implemented</a> with metrics on host total size and break down of size of the largest dependencies. Based on the metrics, further analysis is needed on several key modules including, but not limited to, kernel, systemd and nixos.</p>
<h3 id="no-networking-mh03"><a class="header" href="#no-networking-mh03">No networking (MH03)</a></h3>
<p>Currently ghaf host profile for both release and debug target has networking. Requirement of no networking on release target requires declarative host configuration where:</p>
<ul>
<li>The release target host kernel is built without networking support. Networking must be enabled for debug target.</li>
<li>The release target host user space has no networking tools nor configurations. Access to tools on host must be enabled for debug target.</li>
</ul>
<p>To support development of configuration changes between release and debug target, the debug target must support networking. This also supports <code>No Virtualization</code>-variant development in which networking must be enabled.</p>
<p>The exception to no networking requirement is the virtual machine manager control socket from host to guest(s). The amount of required kernel configuration dependencies and impact to different VMMs must be further analyzed.</p>
<p>No networking has impact on how <a href="https://github.com/tiiuae/vmd/blob/main/doc/design.md"><code>vmd</code></a> adminvm to host communication is implemented. With no networking, shared memory is proposed.</p>
<p>No networking may have impact on how the guest-to-guest inter virtual machine communication configuration must implemented with VMMs. This must be further analyzed.</p>
<h3 id="no-graphics-mh04"><a class="header" href="#no-graphics-mh04">No graphics (MH04)</a></h3>
<p>Ghaf minimal host profile for release target has no graphics. Graphics will be compartmentalized to GUIVM.
All graphics and display output related components and dependencies, including kernel drivers, must be removed from kernel configuration. Those are to be passed through to GUIVM.</p>
<h3 id="no-getty-mh05"><a class="header" href="#no-getty-mh05">No getty (MH05)</a></h3>
<p>Ghaf host in release mode must have no terminals (TTYs) to interact with. In the current state of development, this cannot be enabled yet and has minimum requirement of system logging outside the host. Proposed design to approach this is requirement is to enable getty declaratively only in a debug serial terminal under <a href="https://github.com/tiiuae/ghaf/tree/main/modules/development"><code>modules/development</code></a>.</p>
<h3 id="no-nix-toolings-mh06"><a class="header" href="#no-nix-toolings-mh06">No <code>nix</code> toolings (MH06)</a></h3>
<p>Ghaf host in release mode has no nix tooling to work with the <code>/nix/store</code>. The <code>/nix/store</code> is only used to build the host system. In release mode, no modifications to nix store are possible. Changes are handled with update (MH08).</p>
<p>Ghaf host in debug mode must support nix tooling via read-writable host filesystem. This must be taken into account in build-time nix module declarations.</p>
<h3 id="minimal-defconfig-mh07"><a class="header" href="#minimal-defconfig-mh07">Minimal defconfig (MH07)</a></h3>
<p>Ghaf host release mode kernel configuration must be minimal and hardened in the limits of HW vendor BSP. Kernel configuration per device is to be further analyzed iteratively. Limitations are to be documented per target device kernel configurations and HW support for virtualization.</p>
<h3 id="update-via-adminvm-mh08"><a class="header" href="#update-via-adminvm-mh08">Update via adminvm (MH08)</a></h3>
<p>Ghaf host release mode filesystem updates are to be implemented using A/B update mechanism from adminvm. This will be designed and covered in a separate ADR.</p>
<h3 id="read-only-filesystem-mh09"><a class="header" href="#read-only-filesystem-mh09">Read-only filesystem (MH09)</a></h3>
<p>Ghaf minimal host in release mode must be implemented with read-only, integrity checked (<code>dm-verity</code>) filesystem. </p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="netvmnetworking-virtual-machine"><a class="header" href="#netvmnetworking-virtual-machine">netvm‚ÄîNetworking Virtual Machine</a></h1>
<h2 id="status-2"><a class="header" href="#status-2">Status</a></h2>
<p>Proposed, partially implemented for development and testing.</p>
<p><em>netvm</em> reference declaration is available at <a href="https://github.com/tiiuae/ghaf/blob/main/microvmConfigurations/netvm/default.nix">netvm/default.nix</a>.</p>
<h2 id="context-1"><a class="header" href="#context-1">Context</a></h2>
<p>Ghaf high-level design target is to secure a monolithic OS by modularizing the OS to networked VMs. The key security target is to not expose the trusted host directly to the Internet. This isolates the attack surface from the Internet to <em>netvm</em>.</p>
<p>The following context diagram illustrates development and secure scenarios:</p>
<p><img src="architecture/adr/../../img/netvm.drawio.png" alt="Scope!" title="netvm Context" /></p>
<p><strong>Left</strong>: An insecure development scenario. The host is directly connected to the Internet, and the network is bridged from the host to other parts of the system.</p>
<p><strong>Right</strong>: A secure scenario. The network is passed through to <em>netvm</em> and routed to other parts of the system.</p>
<h2 id="decision-1"><a class="header" href="#decision-1">Decision</a></h2>
<p>The development scenario simplifies the target system network access and configuration. This ADR proposes the development <em>netvm</em> configuration is maintained to support system development.</p>
<p>The secure scenario is proposed to be implemented with the use of passthrough to DMA and remap the host physical network interface card (PHY NIC) to <em>netvm</em>. This cannot be generalized for all hardware targets as it requires:</p>
<ul>
<li>Low-level device tree configuration for bootloader and host (at least on platform NIC).</li>
<li>VMM host user space NIC bus mapping from the host to <em>netvm</em>.</li>
<li>Native network interface driver (not virtual) in <em>netvm</em>. Native driver is bound the vendor BSP supported kernel version.</li>
</ul>
<p>These depend on the hardware setup. The proposed target setup is that the passthrough network device(s) are implemented as declarative nix-modules for easier user hardware-specific configuration. In practice, a user may configure the declaration of a PCI or USB network card that is available to the available hardware setup.</p>
<p><em>netvm</em> will provide:</p>
<ul>
<li>dynamic network configuration:
<ul>
<li>A DHCP server for <em>netvm</em> to provide IP addresses for the other parts of the system, both static and dynamic.</li>
<li>Routing from <em>netvm</em> to the Internet and/or inter VM.</li>
</ul>
</li>
</ul>
<p>For common reference hardware with platform NIC, the configured modules for network interface passthrough are provided. For more information, see <a href="https://tiiuae.github.io/ghaf/research/passthrough/ethernet.html">i.MX 8QM Ethernet Passthrough</a>.</p>
<p>Details of other network components, such as default firewall rules, DHCP (static and dynamic client addresses), routing, reverse proxies and security monitoring are to be described in their respective architecture decision records. In this context, these are illustrated in the context diagram on the right side of the <em>netvm</em> network interface driver. </p>
<h2 id="consequences-1"><a class="header" href="#consequences-1">Consequences</a></h2>
<p>Isolating the attack surface from the host to networking-specific guest VM makes it easier to protect the critical host system from compromise. The isolation also makes it easier to deploy further security, such as a zero trust policy engine or intrusion detection system (IDS).</p>
<p>Isolation makes configuration and comprehension of the system more difficult.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="stack"><a class="header" href="#stack">Stack</a></h1>
<p>The Ghaf stack includes a host with VMs. The host consists of two layers‚ÄîOS kernel with hypervisor and OS user space‚Äîand provides virtualization for the guest VMs: system VMs, application or service VMs, or guest OSs.
The stack layers and top-level components are illustrated in the following diagram.</p>
<p><img src="architecture/../img/stack.drawio.png" alt="Stack!" title="Ghaf Stack" /></p>
<p>At the lowest levels of the stack lay hardware vendor-provided hardware, firmware, and board support package. The Ghaf project aims to use the vendor-provided components either as they are or configure them as supported by the vendor. Configuration may include, for example, host kernel hardening and including only selected components from the vendor BSP.</p>
<p>The Ghaf project provides the reference minimal host with user space as defined in the <a href="architecture/./adr/minimal-host.html">Minimal Host</a>.</p>
<h2 id="system-vms"><a class="header" href="#system-vms">System VMs</a></h2>
<p>Ghaf provides reference system VMs for networking, GUI and storage.</p>
<div class="table-wrapper"><table><thead><tr><th>System VM</th><th>Defined</th><th>Implementation Status</th></tr></thead><tbody>
<tr><td>Networking</td><td><a href="architecture/adr/netvm.html">Yes</a></td><td>Partial</td></tr>
<tr><td>GUI (optional)</td><td>No</td><td>Reference Wayland on host, to be isolated to VM</td></tr>
</tbody></table>
</div>
<p>GUI VM is considered optional as it may not be needed in some headless configurations.</p>
<h2 id="application-or-service-vm"><a class="header" href="#application-or-service-vm">Application or Service VM</a></h2>
<p>Ghaf should provide reference application VMs and service VMs that isolate respective software from the host. Depending on the use case requirements, these VMs will communicate with other parts of the system over networking and shared memory. As an example, application VMs (Wayland client) will communicate with the GUI VM (Wayland compositor) across the VM boundaries. This is called cross-domain Wayland. Another, already partially implemented area is networking VM that will securely provide Internet access to other VMs.</p>
<h2 id="guest-oss"><a class="header" href="#guest-oss">Guest OSs</a></h2>
<p>Ghaf aims to support users with guest OSs such as other Linux distributions (Ubuntu, Fedora, etc.), Windows, and Android. Some of these have been already prototyped.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="technologies"><a class="header" href="#technologies">Technologies</a></h1>
<p>Embedded virtualization builds on technologies from cloud security. Cloud services provide scalable but isolated computation ‚Äî your business case is isolated from someone else's business case.</p>
<p>At the hardware level. Similarly, hardware support in modern personal devices has enabled the isolation of device resources with virtualization. This provides the baseline for secure system design for use case protection.</p>
<p>In practice, the user can use the same device with a trusted application and with an untrusted application. Both applications are isolated from each other to protect valuable user data and privacy.</p>
<p>Our systems are built using <a href="https://github.com/NixOS/nixpkgs">Nixpkgs</a> and various <a href="https://nixos.org/guides/nix-language.html">Nix</a>-based tools and configurations. For more information on Nix ecosystem, see <a href="https://nix.dev/">nix.dev</a>.</p>
<h2 id="hardware-requirements-for-virtualization"><a class="header" href="#hardware-requirements-for-virtualization">Hardware Requirements for Virtualization</a></h2>
<p>Protected computation resources include CPU, memory, storage, and other IO devices. Allocation of these resources is managed with the hypervisor.</p>
<p>In our reference implementation, we use KVM (Kernel Virtual Machine) from Linux to virtualize hardware access. From hardware, this requires MMU (memory management unit) for CPU physical to virtual address mapping and IOMMU for direct memory access (DMA) capable device virtual addresses to physical addresses of the main memory. Many 64-bit CPUs support virtualization via hypervisor extensions already. Our reference implementation supports x86-64 and Aarch64, and we follow RISC-V hypervisor extensions development.</p>
<h2 id="virtual-machine-manager-vmm"><a class="header" href="#virtual-machine-manager-vmm">Virtual Machine Manager (VMM)</a></h2>
<p>On top of OS kernel hypervisor support with KVM. We allocate virtual resources for use cases with user-space virtual machine manager (VMM) using <a href="https://github.com/rust-vmm">rust-vmm</a> based projects such as <a href="https://github.com/cloud-hypervisor/cloud-hypervisor">cloud-hypervisor</a> and <a href="https://github.com/google/crosvm">crosvm</a>. <a href="https://www.qemu.org/">QEMU</a> is enabled for certain development use cases.</p>
<p>In addition, we have also experimental, Aarch64 demonstrated support for a KVM variant ‚Äî <a href="https://github.com/jkrh/kvms">KVMS</a> ‚Äî which adds security features to standard KVM.</p>
<h2 id="in-this-chapter-1"><a class="header" href="#in-this-chapter-1">In This Chapter</a></h2>
<ul>
<li><a href="technologies/./passthrough.html">Passthrough</a>
<ul>
<li><a href="technologies/./nvidia_agx_pt_uart.html">NVIDIA Jetson AGX Orin: UART Passthrough</a></li>
<li><a href="technologies/./nvidia_agx_pt_pcie.html">Nvidia Jetson AGX Orin: PCIe Passthrough</a></li>
</ul>
</li>
<li><a href="technologies/./hypervisor_options.html">Hypervisor Options</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="devices-passthrough"><a class="header" href="#devices-passthrough">Devices Passthrough</a></h1>
<p>Devices passthrough to virtual machines (VM) allows us to isolate the device drivers 
and their memory access in one or several VMs. This reduces the Trusted Code Base (TCB) in the host, due to the passed-through device drivers can be removed completely from the host kernel.</p>
<p>Our current supported passthrough devices implementations:</p>
<ul>
<li><a href="technologies/nvidia_agx_pt_uart.html">NVIDIA Jetson AGX Orin: UART Passthrough</a></li>
<li><a href="technologies/nvidia_agx_pt_pcie.html">NVIDIA Jetson AGX Orin: PCIe Passthrough</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="nvidia-jetson-agx-orin-uart-passthrough"><a class="header" href="#nvidia-jetson-agx-orin-uart-passthrough">NVIDIA Jetson AGX Orin: UART Passthrough</a></h1>
<p>This document describes the UART passthrough implementations on the NVIDIA Jetson AGX Orin board. The goal of this document is to guide more complex devices passthrough implementations.</p>
<h2 id="uart-connections"><a class="header" href="#uart-connections">UART Connections</a></h2>
<p>There are eight UART units in the System on Chip (SoC) and two Server Base System Architecture (SBSA) UART units:</p>
<ul>
<li>The SoC UART units are named with an alphabetical suffix:
<ul>
<li>UARTA, UARTB, UARTC, UARTD, UARTE, UARTF, UARTG, UARTH (which may be referred to as UART1, UART2, UART3, UART4, UART5, UART6, UART7, and UART8).</li>
</ul>
</li>
<li>The SBRA UART units are named UARTI and UARTJ. These units are pin-muxed with the UARTE and UARTC respectively.</li>
</ul>
<p>The following table describes the UART units mapping and connections:</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Device tree def.</strong></th><th style="text-align: center"><strong>CPU pin</strong></th><th style="text-align: center"><strong>SoC pin</strong></th><th><strong>Connected to</strong></th></tr></thead><tbody>
<tr><td>uarta: serial@3100000</td><td style="text-align: center">UART1</td><td style="text-align: center">UART1</td><td>40 pin header 3v3</td></tr>
<tr><td>uartb: serial@3110000</td><td style="text-align: center">UART2</td><td style="text-align: center">UART5</td><td>M.2 key E (WiFi card)</td></tr>
<tr><td>uartc: serial@c280000</td><td style="text-align: center">UART3</td><td style="text-align: center">UART3</td><td>USB Debug ttyACM0</td></tr>
<tr><td>uartd: serial@3130000</td><td style="text-align: center">UART4</td><td style="text-align: center">UART4</td><td>Camera connector</td></tr>
<tr><td>uarte: serial@3140000</td><td style="text-align: center">Not mapped</td><td style="text-align: center"></td><td></td></tr>
<tr><td>uartf: serial@3150000</td><td style="text-align: center">Not mapped</td><td style="text-align: center"></td><td></td></tr>
<tr><td>uartg: not on dtb</td><td style="text-align: center">UART7</td><td style="text-align: center">UART7</td><td>Optional, USB Debug ttyACM1</td></tr>
<tr><td>uarth: serial@3170000</td><td style="text-align: center">Not mapped</td><td style="text-align: center"></td><td></td></tr>
<tr><td>uarti: serial@31d0000</td><td style="text-align: center">UART5</td><td style="text-align: center">UART2</td><td>USB Debug ttyACM1</td></tr>
<tr><td>uartj: serial@c270000</td><td style="text-align: center">Not mapped</td><td style="text-align: center"></td><td></td></tr>
</tbody></table>
</div>
<p>Notes:</p>
<ul>
<li>The first column shows how the UART units are defined in the UART device tree file <em>tegra234-soc-uart.dtsi</em> <sup class="footnote-reference"><a href="#note1">1</a></sup>.</li>
<li>The second and third columns show the CPU and SoC pin connections. Note that for UART2 and UART5 these are swapped. The pin mapping configuration is described in the file <em>tegra234-mb1-bct-pinmux-p3701-0000.dtsi</em> <sup class="footnote-reference"><a href="#note2">2</a></sup>. This device tree file is automatically generated by the macro Excel file <em>Jetson_AGX_Orin_Series_Pinmux_Config_Template_1.5.xlsm</em> which is available at the official Jetson Download Center as the <em>Jetson AGX Orin Series Pinmux</em>.</li>
<li>The last column describes where the UART units are connected to the exterior.</li>
</ul>
<blockquote>
<p>Only two UART units are connected to the micro USB debug interface. The UART7 is not connected by default but it can be connected to the debug interface ttyACM1 by swapping the fuse resistors (see Debug MCU page 7 on P3737_A04_Concept_schematics.pdf <sup class="footnote-reference"><a href="#note3">3</a></sup>).</p>
</blockquote>
<h2 id="uarti-selected-for-passthrough"><a class="header" href="#uarti-selected-for-passthrough">UARTI Selected for Passthrough</a></h2>
<p>The UARTI unit was selected to do the first &quot;Hello world&quot; passthrough implementation as it does not show any dependencies on its device tree:</p>
<pre><code class="language-cpp">	uarti: serial@31d0000 {
		compatible = &quot;arm,sbsa-uart&quot;;
		reg = &lt;0x0 0x31d0000 0x0 0x10000&gt;;
		interrupts = &lt;0x0 TEGRA234_IRQ_UARTI 0x04&gt;;
		current-speed = &lt;115200&gt;;
		status = &quot;disabled&quot;;
	};
</code></pre>
<h2 id="host-device-tree"><a class="header" href="#host-device-tree">Host Device Tree</a></h2>
<p>To prepare the UARTI on the host for the passthrough:</p>
<ol>
<li>
<p>Modify the UARTI node in the <em>tegra234-soc-uart.dtsi</em> device tree file <sup class="footnote-reference"><a href="#note1">1</a></sup>:</p>
<ul>
<li><strong>compatible:</strong> put a dummy driver associated to this node so that the kernel will not bind any driver to this UART unit.</li>
<li><strong>iommus:</strong> add the iommus field with the test stream ID <em>TEGRA_SID_NISO1_SMMU_TEST</em> which by default is not used by any other device.</li>
</ul>
<pre><code class="language-cpp">	uarti: serial@31d0000 {
		compatible = &quot;arm,dummy&quot;;
		iommus = &lt;&amp;smmu_niso0 TEGRA_SID_NISO1_SMMU_TEST&gt;;
		reg = &lt;0x0 0x31d0000 0x0 0x10000&gt;;
		interrupts = &lt;0x0 TEGRA234_IRQ_UARTI 0x04&gt;;
		current-speed = &lt;115200&gt;;
		status = &quot;disabled&quot;;
	};
</code></pre>
</li>
<li>
<p>Include the modifications, compile the kernel to update the output DTB, and then flash it to the internal eMMC device tree A and B partitions with the following command:</p>
<pre><code>dd if=./arch/arm64/boot/dts/nvidia/tegra234-p3701-0000-p3737-0000.dtb of=/dev/mmcblk0p3
dd if=./arch/arm64/boot/dts/nvidia/tegra234-p3701-0000-p3737-0000.dtb of=/dev/mmcblk0p6
</code></pre>
</li>
</ol>
<h2 id="guest-device-tree"><a class="header" href="#guest-device-tree">Guest Device Tree</a></h2>
<p>The guest device tree is based on the device tree extracted from QEMU VM.</p>
<p>To get the base QEMU device tree, run the following command:</p>
<pre><code>qemu-system-aarch64 -machine virt,accel=kvm,dumpdtb=virt.dtb -cpu host
</code></pre>
<p>Add the passthrough devices inside the platform node to this device tree:</p>
<pre><code class="language-cpp">	platform@c000000 {
		interrupt-parent = &lt;0x8001&gt;;
		ranges = &lt;0xc000000 0x00 0xc000000 0x2000000&gt;;
		#address-cells = &lt;0x01&gt;;
		#size-cells = &lt;0x01&gt;;
		compatible = &quot;qemu,platform\0simple-bus&quot;;

		uarti: serial@c000000 {
		    compatible = &quot;arm,sbsa-uart&quot;;
		    current-speed = &lt;0x1c200&gt;;
		    interrupts = &lt;0x00 0x70 0x04&gt;;
		    reg = &lt;0x0c000000 0x10000&gt;;
		    status = &quot;okay&quot;;
        	};
	};
</code></pre>
<blockquote>
<p>In this example, the <em>uarti</em> node was added to the platform node. For this node the interrupt number was replaced to 0x70 and reg address to the one that was obtained from the QEMU monitor command: <em>info mtree -f</em>.</p>
</blockquote>
<h2 id="starting-guest-vm"><a class="header" href="#starting-guest-vm">Starting Guest VM</a></h2>
<p>To start the guest VM:</p>
<ol>
<li>
<p>Bind the UARTI to the VFIO driver:</p>
<pre><code>echo vfio-platform &gt; /sys/bus/platform/devices/31d0000.serial/driver_override
echo 31d0000.serial &gt; /sys/bus/platform/drivers/vfio-platform/bind
</code></pre>
<p>The VFIO gives the user-level an access to the devices, in this case, QEMU.</p>
</li>
<li>
<p>Connect the NVIDIA Jetson AGX Orin Debug USB to your PC and open the serial port ttyACM1 at 115200 bps. You can use picocom with the next command:</p>
<pre><code>picocom -b 115200 /dev/ttyACM1
</code></pre>
</li>
<li>
<p>Run the guest VM with the following QEMU command:</p>
<pre><code>qemu-system-aarch64 \
    -nographic \
    -machine virt,accel=kvm \
    -cpu host \
    -m 1024 \
    -no-reboot \
    -kernel Image \
    -drive file=focal-server-cloudimg-arm64.raw,if=virtio,format=raw \
    -device vfio-platform,host=31d0000.serial\
    -dtb uart.dtb \
    -append &quot;rootwait root=/dev/vda1 console=ttyAMA0&quot;
</code></pre>
</li>
</ol>
<p>When the guest VM is launched you can see the VM Linux command line in the opened ttyACM1 terminal.</p>
<div class="footnote-definition" id="note1"><sup class="footnote-definition-label">1</sup>
<p>kernel_src/hardware/nvidia/soc/t23x/kernel-dts/tegra234-soc/tegra234-soc-uart.dtsi</p>
</div>
<div class="footnote-definition" id="note2"><sup class="footnote-definition-label">2</sup>
<p>bootloader/t186ref/BCT/tegra234-mb1-bct-pinmux-p3701-0000.dtsi available in the BSP sources on: https://developer.nvidia.com/embedded/jetson-linux-r3521</p>
</div>
<div class="footnote-definition" id="note3"><sup class="footnote-definition-label">3</sup>
<p>Jetson_AGX_Orin_DevKit_Carrier_Board_Design_Files_A04_20221003/P3737_A04_Concept_schematics.pdf available in https://developer.nvidia.com/jetson-agx-orin-developer-kit-carrier-board-design-files-a04</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="nvidia-jetson-agx-orin-pcie-passthrough"><a class="header" href="#nvidia-jetson-agx-orin-pcie-passthrough">NVIDIA Jetson AGX Orin: PCIe passthrough</a></h1>
<p>This document describes the PCIe passthrough implementations on the NVIDIA Jetson AGX Orin board. The goal of this document is to give an overview of passing through different PCIe devices and the limitations of PCIe in the board.</p>
<h2 id="pcie-slots-in-nvidia-jetson-agx-orin"><a class="header" href="#pcie-slots-in-nvidia-jetson-agx-orin">PCIe Slots in NVIDIA Jetson AGX Orin</a></h2>
<p>There are two (or actually three) PCIe slots in the Jetson AGX Orin board:</p>
<ul>
<li>One of the connectors is a <a href="technologies/nvidia_agx_pt_pcie.html#full-size-pcie-slot">full-size PCIe 8x slot</a> located under a black plastic cover above the micro USB serial debug port on the side of the board.</li>
<li>The other slot is a <a href="technologies/nvidia_agx_pt_pcie.html#pcie-m2-slot">smaller M.2 slot</a> that is located at the bottom of the board. By default, the slot is in use of the included Wi-Fi and Bluetooth module.</li>
<li>The third slot is actually an <a href="technologies/nvidia_agx_pt_pcie.html#pcie-m2-nvme-2247-for-ssd">NVMe slot</a> which can be used to add an NVMe SSD to the board.</li>
</ul>
<blockquote>
<p>For more information on the board's connections details, see the <a href="https://developer.nvidia.com/embedded/learn/jetson-agx-orin-devkit-user-guide/developer_kit_layout.html">Hardware Layout</a> section of the Jetson AGX Orin Developer Kit User Guide.</p>
</blockquote>
<p>When using one of the slots:</p>
<ul>
<li>First and foremost, always turn off and disconnect any power sources from the board and its peripherals when connecting or disconnecting devices to any of the PCIe buses connect.</li>
<li>When adding or removing devices to the board, there is always a risk of setting off an electrical discharge in one of the components which may damage the connected device or the board itself.</li>
</ul>
<h4 id="full-size-pcie-slot"><a class="header" href="#full-size-pcie-slot">Full-Size PCIe Slot</a></h4>
<p>The full-size PCIe connector is under the black plastic cover on one of the sides of the device. The cover is held in place with a fairly strong magnet. There is a small connector ribbon and a few delicate wires going from the board internals to a Wi-Fi antenna on the cover.</p>
<blockquote>
<p><strong>TIP:</strong> Make sure to remove the cover carefully for not ripping the whole cover off along with the antenna cables.</p>
</blockquote>
<p>The PCIe slot is simular to one inside a desktop computer. One key difference: the Jetson AGX Orin board has limited 12V power output capabilities and can only output a maximum of 40W power to its PCIe slot. Regular desktop PCIe slot can output 75W at 12V so some more power-hungry PCIe cards <sup class="footnote-reference"><a href="#note1">1</a></sup> may not work with the Jetson AGX Orin board. There may also be a risk of damaging the board if a card tries to pull too much power from the PCIe socket.</p>
<blockquote>
<p><strong>TIP:</strong> We recommend to check carefully the power requirements of a device before turning the device on.</p>
</blockquote>
<p>A good rule of thumb might be if the device has a cooler to actively cool it down then some care should be taken before starting to use the card. Some trials have been done with GPU devices that use at maximum 30-34W power. The devices seem to work well in Jetson AGX Orin, but it is difficult to say how much power the card actually pulls from the slot at any given time. No real performance or stress tests have been done but under usual GUI and simple 3d application usage the cards (NVIDIA Quadro P1000 and NVIDIA Quadro T600) seem to work fine.</p>
<h4 id="pcie-m2-slot"><a class="header" href="#pcie-m2-slot">PCIe M.2 Slot</a></h4>
<p>The PCIe M.2 slot with key type A+E is at the bottom of the board. By default, this slot is in use of the internal Wi-Fi and Bluetooth card. There are different types of M.2 slots all of which are not compatible with one another. The slot in Jetson AGX Orin is type A+E, and it supports PCIe 2x and USB transport buses.</p>
<h4 id="pcie-m2-nvme-for-ssd"><a class="header" href="#pcie-m2-nvme-for-ssd">PCIe M.2 NVMe for SSD</a></h4>
<p>The third slot is M.2 NVMe 2280 (22 mm width and 80 mm length) and can be used for NVMe SSD. Passing through this interface has not been tested as the SSD is in most cases used by the host.</p>
<h2 id="enabling-pcie-devices-for-vfio"><a class="header" href="#enabling-pcie-devices-for-vfio">Enabling PCIe Devices for VFIO</a></h2>
<p>As in the <a href="technologies/nvidia_agx_pt_uart.html">UART Passthrough</a>, the default device tree requires some modifications.</p>
<p>With the default configuration, the PCI devices are set to the same VFIO group as the PCI bus itself. The trouble here is that the PCI bus is a platform bus device which is a bit tricky to pass through to the guest. It is possible to pass through only the individual PCI devices and not the whole bus.</p>
<p>To pass through individual PCI devices one by one, set the devices in their individual VFIO groups or remove the PCI bus from the same VFIO group:</p>
<pre><code class="language-cpp">/*
 * Modify the 'pcie_c1_rp' pci-e bus by removing its
 * iommu group definition.
 * This is to remove the pci bus from vfio group which
 * leaves the m2 pci device alone in the group.
 * This change is for the m2 pci-e &quot;wifi&quot; slot.
  */
&amp;pcie_c1_rp {
    /delete-property/ iommus;
};

/*
 * Modify the 'pci_c5_rp' pci bus by removing its
 * iommu group definition.
 * This is to remove the pci bus from vfio group which
 * leaves the pci device alone in the group.
 * This change is for the full size pci-e slot.
 */
&amp;pcie_c5_rp {
    /delete-property/ iommus;
};
</code></pre>
<h3 id="binding-device-for-vfio"><a class="header" href="#binding-device-for-vfio">Binding Device for VFIO</a></h3>
<p>To set up the device for VFIO, unload the device driver and then replac it with the <code>vfio-pci</code> driver.</p>
<p>The example below can be used for a device in the PCI bus <code>0001</code>.<br />
The device <code>0001:01:00.0</code> in the first bus is the Jetson AGX Orin board with the M.2 Wi-Fi card. The full size PCI bus id is <code>0005</code>. It is possible that a single PCI card contains multiple devices. In that case, all the devices need to be passed through together as they are in the same VFIO group. Usually the graphics card also contains some sound output device as a separate device.</p>
<pre><code>export DEVICE=&quot;0001:01:00.0&quot;
export VENDOR_ID=$(cat /sys/bus/pci/devices/$DEVICE/vendor)
export DEVICE_ID=$(cat /sys/bus/pci/devices/$DEVICE/device)

echo &quot;$DEVICE&quot; &gt; /sys/bus/pci/devices/$DEVICE/driver/unbind

echo &quot;$VENDOR_ID $DEVICE_ID&quot; &gt; /sys/bus/pci/drivers/vfio-pci/new_id
</code></pre>
<p>In case of success, this device is bound to VFIO. The VFIO nodes are usually owned by the root and in some cases may be group accessible by the VFIO group. To use the VFIO devices, the user who starts QEMU needs access to the VFIO device node:</p>
<pre><code># List of vfio device &lt;id&gt; nodes
ls /dev/vfio/

# List of devices within each iommu group
ls /sys/kernel/iommu_groups/&lt;id&gt;/devices/
</code></pre>
<p>You can also check the kernel logs to know which device belongs to which VFIO IOMMU group.</p>
<h2 id="starting-guest-vm-1"><a class="header" href="#starting-guest-vm-1">Starting Guest VM</a></h2>
<p>After binding a device to VFIO, you can access the device in a VM. To do so, use a command line argument (as in the example) for the PCI device to pass through to QEMU.</p>
<blockquote>
<p>It does not matter which VFIO node ID was assigned to the device earlier, as long as all the devices with the same VFIO node are passed through, and none of the devices in the same group is left behind.</p>
</blockquote>
<p>The QEMU command line argument for passthrough uses the PCIe device ID as identifier for the devices. Each
device which is passed through needs its own QEMU <code>-device</code> argument as below:</p>
<pre><code>-device vfio-pci,host=&quot;0001:01:00.0&quot;
</code></pre>
<h3 id="arm64-pci-device-interrupts"><a class="header" href="#arm64-pci-device-interrupts">ARM64 PCI Device Interrupts</a></h3>
<p>Modern PCI devices use the Message Signaled Interrupts (MSI) method to limit the need for physical hardware interrupt pins. As passing through PCI or any other devices is fairly new to QEMU, it seems MSI in ARM64 is not supported by QEMU <sup class="footnote-reference"><a href="#note2">2</a></sup>.</p>
<p>To get interrupts to work in the guest, we need to signal the kernel to disable MSI for our passthrough device. There are two ways of doing it:</p>
<ol>
<li>To modify the host device tree by disabling MSI completely from the whole PCI bus.</li>
<li>To disable MSI only from the guest by using the <code>pci=nomsi</code> kernel argument with QEMU. Disabling MSI is not required for the x86 QEMU guest as it has MSI support.</li>
</ol>
<p>The command below is provided only as a test example for passing through a PCI device for AArch64 <sup class="footnote-reference"><a href="#note3">3</a></sup>:</p>
<pre><code>qemu-system-aarch64 \
    -nographic \
    -machine virt,accel=kvm \
    -cpu host \
    -m 1024 \
    -no-reboot \
    -kernel Image \
    -drive file=focal-server-cloudimg-arm64.raw,if=virtio,format=raw \
    -device vfio-pci,host=0001:01:00.0\
    -append &quot;rootwait root=/dev/vda1 console=ttyAMA0 pci=nomsi&quot;
</code></pre>
<h3 id="more-work-for-arm64"><a class="header" href="#more-work-for-arm64">More Work for ARM64</a></h3>
<p>The information above is enough for x86 and also for ARM64 processor architecture when using some simple or a bit older PCIe devices. A bit more complex PCIe device which has a larger internal RAM pool needs some modifications with QEMU sources.</p>
<p>The problem with passing through such devices is that the memory address range reserved for PCIe devices is not large enough to map the internal memory of the PCI device. Some graphics cards have several gigabytes of internal RAM which needs to be accessible for the VM guest.</p>
<p>You can extend the VIRT_PCIE_ECAM memory address range in the QEMU source code to allow mapping the whole PCIe device memory range. In most cases a few gigabytes is sufficient:</p>
<pre><code>diff --git a/hw/arm/virt.c b/hw/arm/virt.c
index ac626b3bef..d6fb597aee 100644
--- a/hw/arm/virt.c
+++ b/hw/arm/virt.c
@@ -161,9 +161,10 @@ static const MemMapEntry base_memmap[] = {
     [VIRT_SECURE_MEM] =         { 0x0e000000, 0x01000000 },
     [VIRT_PCIE_MMIO] =          { 0x10000000, 0x2eff0000 },
     [VIRT_PCIE_PIO] =           { 0x3eff0000, 0x00010000 },
-    [VIRT_PCIE_ECAM] =          { 0x3f000000, 0x01000000 },
+    /* ..Reserved 11Gb range for pcie = 11*1024*1024*1024b */
+    [VIRT_PCIE_ECAM] =          { 0x40000000, 0x2C0000000 },
     /* Actual RAM size depends on initial RAM and device memory settings */
-    [VIRT_MEM] =                { GiB, LEGACY_RAMLIMIT_BYTES },
+    [VIRT_MEM] =                { 0x300000000, LEGACY_RAMLIMIT_BYTES },
 };

</code></pre>
<p>After these changes, compile QEMU and install it on the host system.</p>
<div class="footnote-definition" id="note1"><sup class="footnote-definition-label">1</sup>
<p>An example of a power-hungry card is a graphics accelerator card.</p>
</div>
<div class="footnote-definition" id="note2"><sup class="footnote-definition-label">2</sup>
<p>Our approach of using ARM as a VM host with passthroughs fairly new so it is hard to search for help or references online, but this bug <a href="https://bugs.launchpad.net/ubuntu/+source/libvirt/+bug/1832394">qemu-system-aarch64 error</a> seems to be close enough. The main hint of MSI not being fully supported yet by QEMU on ARM64 comes from the case when the device starts working only with MSI disabled from the guest kernel argument.</p>
</div>
<div class="footnote-definition" id="note3"><sup class="footnote-definition-label">3</sup>
<p>It may require some changes for real usage.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<!--
    Update this section after the pull request https://github.com/tiiuae/ghaf/pull/94 is accepted >_<
-->
<h1 id="ghaf-specific-microvm-hypervisor-options"><a class="header" href="#ghaf-specific-microvm-hypervisor-options">Ghaf-Specific microvm Hypervisor Options</a></h1>
<p><strong>microvm</strong> is the component defining a VM's launch services generated for systemd. It inputs a set of options mapped to the hypervisor command line call.</p>
<p>Nevertheless, it may happen that some hypervisor options are not supported by microvm. For example, adding specific devices. This document considers such cases.</p>
<h3 id="options-definitions"><a class="header" href="#options-definitions">Options Definitions</a></h3>
<p>A VM is defined under Ghaf‚Äôs subdirectory <code>microvmConfigurations/VM_NAME/default.nix</code>, for example:</p>
<pre><code>microvmConfigurations/memshare/default.nix
https://github.com/jkuro-tii/ghaf/blob/main/microvmConfigurations/memshare/default.nix
</code></pre>
<p>This file contains hypervisor‚Äôs options for running the VM. For each hypervisor there is a bunch of microvm‚Äôs defined options:
<a href="https://astro.github.io/microvm.nix/options.html">https://astro.github.io/microvm.nix/options.html</a></p>
<p>The way they are processed can be found in corresponding <code>.nix</code> files (runners) in the astro/microvm.nix repository:</p>
<ul>
<li><a href="https://github.com/astro/microvm.nix/blob/main/lib/runners/crosvm.nix">crosvm.nix</a></li>
<li><a href="https://github.com/astro/microvm.nix/blob/main/lib/runners/qemu.nix">qemu.nix</a></li>
</ul>
<p>The formula for setting hypervisor option is <code>microvm.option = value;</code>. For example:</p>
<pre><code>microvm.mem = 512;
microvm.vcpu = 2;
</code></pre>
<h3 id="generated-hypervisor-start-commands"><a class="header" href="#generated-hypervisor-start-commands">Generated Hypervisor Start Commands</a></h3>
<p>As a result of building the Ghaf tree, command lines for starting the VMs are generated. They reflect all parameters specified above‚Äîboth those specified explicitly and defaults. They are located under the Ghaf‚Äôs <code>/var/lib/microvms/ directory</code>.</p>
<pre><code>ls /var/lib/microvms/memsharevm-vm-debug/current/bin
</code></pre>
<pre><code>microvm-balloon
microvm-console
microvm-run
microvm-shutdown
</code></pre>
<p>The command which starts the hypervisor is the microvm-run bash script. Here is a sample generated:</p>
<pre><code> #! /nix/store/96ky1zdkpq871h2dlk198fz0zvklr1dr-bash-5.1-p16/bin/bash -e
exec '/nix/store/zsf59dn5sak8pbq4l3g5kqp7adyv3fph-qemu-host-cpu-only-7.1.0/bin/qemu-system-x86_64' '-
name' 'memshare' '-M' 'microvm,accel=kvm:tcg,x-option-roms=off,isa-serial=off,pit=off,pic=off,rtc=off,
mem-merge=on' '-m' '2512' '-cpu' 'host' '-smp' '17' '-machine' 'virt,accel=kvm' '-nodefaults' '-no-
user-config' '-nographic' '-no-reboot' '-serial' 'null' '-device' 'virtio-serial-device' '-chardev'
'pty,id=con0' '-device' 'virtconsole,chardev=con0' '-chardev' 'stdio,mux=on,id=con1,signal=off' '-
device' 'virtconsole,chardev=con1' '-device' 'virtio-rng-device' '-drive' 'id=root,format=raw,
media=cdrom,file=/nix/store/xnnqb3sb1l4kbx7s0ijazph5r0c0xhx5-rootfs.squashfs,if=none,aio=io_uring' '-
device' 'virtio-blk-device,drive=root' '-kernel' '/nix/store/ds5cmyby0p4ikw91afmrzihkz351kls7-linux-
6.2/bzImage' '-append' 'console=hvc1 console=hvc0 reboot=t panic=-1 root=/dev/vda ro init=/init
devtmpfs.mount=0 stage2init=/nix/store/0mbhpna8hplbsaz1il3n99f0zincr4vs-nixos-system-memshare-
22.11.20230310.824f886/init boot.panic_on_fail loglevel=4 regInfo=/nix/store
/j8id92qsd58qjnzq4xz6v5l38rlpq6is-closure-info/registration' '-sandbox' 'on' '-qmp' 'unix:memshare.
sock,server,nowait' '-device' 'virtio-balloon' '--option 1 --option 2'
</code></pre>
<p>for the input parameters:</p>
<pre><code>microvm.hypervisor = &quot;qemu&quot;;
</code></pre>
<p>Note that microvm sets several others.</p>
<pre><code>microvm.mem = 2000;
microvm.balloonMem = 512;
microvm.vcpu = 17;
microvm.qemu.extraArgs = [ &quot;--option 1 --option 2&quot; ];
</code></pre>
<h3 id="adding-option-to-hypervisor-command-line"><a class="header" href="#adding-option-to-hypervisor-command-line">Adding Option to Hypervisor Command Line</a></h3>
<p>microvm may not supply parameters for all possible options as adding specific devices. Processing of all microvm configuration options is done in the mentioned above hypervisor‚Äôs runner .nix file.</p>
<p>The runners support the <code>extraArgs</code> parameter. It allows setting any option in QEMU command line invocation. Its value is a list of strings. In this example the following <code>extraArgs</code> definition:</p>
<pre><code>microvm.qemu.extraArgs = [
&quot;-object memory-backend-file,id=mem1,mem-path=/dev/shm/virtio_pmem.img&quot;
&quot;-device virtio-pmem-pci,memdev=mem1,id=nv1&quot;
];
</code></pre>
<p>results in the generated command line parameters:</p>
<pre><code>'-object memory-backend-file,id=mem1,mem-path=/dev/shm/virtio_pmem.img' '-device v
irtio-pmem-pci,memdev=mem1,id=nv1'
</code></pre>
<blockquote>
<p>Support for the crosvm‚Äôs <code>extraArgs</code> parameter was added on April 7, 2023. Make sure to verify that your <code>flakes.lock</code> file refers to the proper version.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="reference-implementations"><a class="header" href="#reference-implementations">Reference Implementations</a></h1>
<p>Our hardened OS targets are build configurations based on NixOS. The canonical URL for the upstream Nix git repository is: <a href="https://github.com/NixOS">https://github.com/NixOS</a>.</p>
<p>Build configurations define our dependencies and configuration changes to packages and build mechanisms of NixOS. If you want to try Ghaf, see <a href="ref_impl/../ref_impl/build_and_run.html">Build and Run</a>.</p>
<h2 id="approach"><a class="header" href="#approach">Approach</a></h2>
<p>A build configuration is a target to build the hardened OS for a particular hardware device. Most packages used in a build configuration come from <a href="https://github.com/NixOS/nixpkgs">nixpkgs‚ÄîNixOS Packages collection</a>.</p>
<p>The upstream first approach means we aim the fix issues by contributing to nixpkgs. At the same time, we get the maintenance support of NixOS community and the benefits of the Nix language on how to build packages and track the origins of packages in the software supply chain security. For more information, see <a href="ref_impl/../scs/scs.html">Supply Chain Security</a>.</p>
<p>NixOS, a Linux OS distribution packaged with Nix, provides us with:</p>
<ul>
<li>generic hardware architecture support (<code>x86-64</code> and <code>AArch64</code>)</li>
<li>declarative and modular mechanism to describe the system</li>
<li>Nix packaging language mechanisms:
<ul>
<li>to extend and change packages with <a href="https://nixos.wiki/wiki/Overlays">overlays</a></li>
<li>to <a href="https://nixos.org/guides/nix-pills/override-design-pattern.html">override</a> packages</li>
</ul>
</li>
</ul>
<p>Even when unmodified upstream is often preferred, even ideal, to ensure timely security updates from upstream ‚Äî customizations are sometimes required.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>To support a reference board without a vendor board support package (BSP) ‚Äî bootloader, kernel, device drivers ‚Äî is often not feasible. With this approach, we can overlay the generic NixOS Linux kernel with the vendor kernel and add a vendor bootloader to build a target image.</p>
<p>Often the vendor BSPs are also open source but sometimes contain unfree binary blobs from the vendor's hardware. Those are handled by allowing <code>unfree</code> - if the user agrees with the end-user license agreement (EULA). If not, <code>unfree</code> support can be dropped along with that part of the BSP support.</p>
<p>The same goes with the architectural variants as headless devices or end-user devices differ in terms what kind of virtual machines (VM) they contain. The user needs graphics architecture and VM support for the user interface (UI) whereas a headless device is more like a small server without the UI.</p>
<h2 id="in-this-chapter-2"><a class="header" href="#in-this-chapter-2">In This Chapter</a></h2>
<ul>
<li><a href="ref_impl/./build_and_run.html">Build and Run</a></li>
<li><a href="ref_impl/./development.html">Development</a>
<ul>
<li><a href="ref_impl/./cross_compilation.html">Cross-Compilation</a></li>
</ul>
</li>
<li><a href="ref_impl/./custom_product.html">Define a Custom Project from Ghaf</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="usage"><a class="header" href="#usage">Usage</a></h1>
<p>Ghaf is a framework for creating virtualized edge devices, it is therefore expected that projects wishing to use Ghaf should import it to create a derived work for the specific use case.</p>
<p>In practice, projects should import Ghaf and it's dependencies in an external version control (git) repository.</p>
<p>Ghaf provides templates for the reference hardware to ease this process. This documented describes:</p>
<ul>
<li>overview of Ghaf usage and upstream dependencies</li>
<li>required steps to create a Ghaf-based project</li>
<li>updating the project to get the latest changes</li>
<li>customization of the project using Ghaf-modules
and Nix-supported mechanisms</li>
</ul>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Ghaf usage in your project is illustrated in the following diagram.
<img src="ref_impl/../img/usage_overview.drawio.png" alt="Ghaf Usage Overview" title="Your project and example inputs from Ghaf and other repositories" /></p>
<p>Ghaf platform repository provides declarative modules and reference implementations to help with declaring your customized, secure system.</p>
<p>External repositories help with making variety of HW options, system image generators and reference board-support packages available.</p>
<h2 id="creating-a-ghaf-based-project---step-by-step"><a class="header" href="#creating-a-ghaf-based-project---step-by-step">Creating a Ghaf-based project - step-by-step</a></h2>
<ol>
<li>Check the available target templates</li>
</ol>
<pre><code>    nix flake show github:tiiuae/ghaf
</code></pre>
<ol start="2">
<li>Select the appropriate template based on reference implementation e.g. <code>target-aarch64-nvidia-orin-agx</code></li>
</ol>
<pre><code>    nix flake new --template github:tiiuae/ghaf#target-aarch64-nvidia-orin-agx ~/ghaf-example
    wrote: ~/ghaf-example/flake.nix
</code></pre>
<ol start="3">
<li>See your project template outputs</li>
</ol>
<pre><code>    cd ~/ghaf-example/
    nix flake show
    git+file://~/ghaf-example
    ‚îú‚îÄ‚îÄ‚îÄformatter
    ‚îÇ   ‚îú‚îÄ‚îÄ‚îÄaarch64-linux: package 'alejandra-3.0.0'
    ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄx86_64-linux: package 'alejandra-3.0.0'
    ‚îú‚îÄ‚îÄ‚îÄnixosConfigurations
    ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄPROJ_NAME-ghaf-debug: NixOS configuration
    ‚îî‚îÄ‚îÄ‚îÄpackages
    ‚îú‚îÄ‚îÄ‚îÄaarch64-linux
    ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄPROJ_NAME-ghaf-debug: package 'nixos-disk-image'
    ‚îî‚îÄ‚îÄ‚îÄx86_64-linux
    ‚îî‚îÄ‚îÄ‚îÄPROJ_NAME-ghaf-debug-flash-script: package 'flash-ghaf'
</code></pre>
<ol start="4">
<li>Change the placeholder <code>&lt;PROJ NAME&gt;</code> to your new projects name e.g. <code>cool_project</code></li>
</ol>
<pre><code>    sed -i 's/PROJ_NAME/cool_project/g' flake.nix
</code></pre>
<h2 id="update-your-ghaf-based-project"><a class="header" href="#update-your-ghaf-based-project">Update your Ghaf-based project</a></h2>
<p>To update your project, run <code>nix flake update</code>.
This check the inputs for updates and based on availability of the updates, generate an updated <code>flake.lock</code> which locks the specific versions to support the reproducible builds without side effects.</p>
<p>In practice, nix flake will not allow floating inputs but all the inputs and declared packages must be mapped to specific hashes to get exact revisions of your inputs. This mechanism also supports the supply-chain security - if someone changes the upstream project e.g. by over-writing a part of the input so that the hash changes, you will notice. (Believe it or not, this happens even with large HW vendors). </p>
<p>After update, review and testing - commit the updated <code>flake.lock</code> to your version history to share reproducible builds within your project.</p>
<h2 id="customize-your-ghaf-based-project"><a class="header" href="#customize-your-ghaf-based-project">Customize your Ghaf-based project</a></h2>
<p>To use the Ghaf declarative module system, check what you need in your system and choose the module options you need. For example, import the ghaf <code>graphics</code>-module and declare that you won't need the reference Wayland-compositor Weston and the demo applications:</p>
<pre><code>          {
            ghaf.graphics.weston = {
              enable = false;
              enableDemoApplications = false;
            };
          }
</code></pre>
<p>After the change, rebuild the system and switch it into use in your target device and it will run with the GUI and apps removed. After testing, you can commit the changes and share them for your colleagues to be able to build the exactly same system - even system image - as needed in your project.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="development-1"><a class="header" href="#development-1">Development</a></h1>
<p>Ghaf Framework is free software, currently under active development.</p>
<p>Scope of target support is updated with development progress.</p>
<p>Once you are up and running, you can participate in the collaborative development process by building a development build with additional options. For example, with the development username and password that are defined in the<a href="https://github.com/tiiuae/ghaf/blob/main/modules/development/authentication.nix#L4-L5">authentication.nix</a> module.</p>
<p>If you set up development SSH keys in the <a href="https://github.com/tiiuae/ghaf/blob/main/modules/development/ssh.nix#L4">ssh.nix</a> module, you can use <code>nixos-rebuild switch</code> to quickly deploy your configuration changes to the development board over the network using SSH:</p>
<pre><code>nixos-rebuild --flake .#nvidia-jetson-orin-debug --target-host root@ghaf-host --fast switch
</code></pre>
<p>Pull requests are the way for contributors to submit code to the Ghaf project. For more information, see <a href="ref_impl/../appendices/contributing_general.html">Contribution Guidelines</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="build-and-run"><a class="header" href="#build-and-run">Build and Run</a></h1>
<p>This tutorial assumes that you already have basic <a href="https://git-scm.com/">git</a> experience.</p>
<p>The canonical URL for the upstream Ghaf git repository is <a href="https://github.com/tiiuae/ghaf">https://github.com/tiiuae/ghaf</a>. To try Ghaf, you can build it from the source.</p>
<blockquote>
<p><a href="ref_impl/../ref_impl/cross_compilation.html">Cross-compilation</a> support is currently under development and not available for the building process.</p>
</blockquote>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>First, follow the basic device-independent steps:</p>
<ul>
<li>Clone the git repository <a href="https://github.com/tiiuae/ghaf">https://github.com/tiiuae/ghaf</a>.</li>
<li>Ghaf uses a Nix flake approach to build the framework targets, make sure to:
<ul>
<li>Install Nix or full NixOS if needed: <a href="https://nixos.org/download.html">https://nixos.org/download.html</a>.</li>
<li>Enable flakes: <a href="https://nixos.wiki/wiki/Flakes#Enable_flakes">https://nixos.wiki/wiki/Flakes#Enable_flakes</a>.<br />
To see all Ghaf-supported outputs, type <code>nix flake show</code>.</li>
<li>Set up an AArch64 remote builder: <a href="https://nixos.org/manual/nix/stable/advanced-topics/distributed-builds.html">https://nixos.org/manual/nix/stable/advanced-topics/distributed-builds.html</a>.</li>
</ul>
</li>
</ul>
<p>Then you can use one of the following instructions for the supported targets:</p>
<div class="table-wrapper"><table><thead><tr><th>Device</th><th>Architecture</th><th>Instruction</th></tr></thead><tbody>
<tr><td>Virtual Machine</td><td>x86_64</td><td><a href="ref_impl/./build_and_run.html#running-ghaf-image-for-x86-vm-ghaf-host">Running Ghaf Image for x86 VM (ghaf-host)</a></td></tr>
<tr><td>Generic x86 –°omputer</td><td>x86_64</td><td><a href="ref_impl/./build_and_run.html#running-ghaf-image-for-x86-computer">Running Ghaf Image for x86 Computer</a></td></tr>
<tr><td>NVIDIA Jetson AGX Orin</td><td>AArch64</td><td><a href="ref_impl/./build_and_run.html#ghaf-image-for-nvidia-jetson-orin-agx">Ghaf Image for NVIDIA Jetson Orin AGX</a></td></tr>
<tr><td>NXP i.MX 8QM-MEK</td><td>AArch64</td><td><a href="ref_impl/./build_and_run.html#building-ghaf-image-for-nxp-imx-8qm-mek">Building Ghaf Image for NXP i.MX 8QM-MEK</a></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="running-ghaf-image-for-x86-vm-ghaf-host"><a class="header" href="#running-ghaf-image-for-x86-vm-ghaf-host">Running Ghaf Image for x86 VM (ghaf-host)</a></h2>
<p>Before you begin, check device-independent <a href="ref_impl/./build_and_run.html#prerequisites">prerequisites</a>.</p>
<p>From the <code>ghaf</code> source directory, run the <code>nix run .#packages.x86_64-linux.vm-debug</code> command.</p>
<p>This creates <code>ghaf-host.qcow2</code> copy-on-write overlay disk image in your current directory. If you do unclean shutdown for the QEMU VM, you might get weird errors the next time you boot. Simply removing <code>ghaf-host.qcow2</code> should be enough. To cleanly shut down the VM, from the menu bar of the QEMU Window, click Machine and then Power Down.</p>
<hr />
<h2 id="running-ghaf-image-for-x86-computer"><a class="header" href="#running-ghaf-image-for-x86-computer">Running Ghaf Image for x86 Computer</a></h2>
<p>Before you begin, check device-independent <a href="ref_impl/./build_and_run.html#prerequisites">prerequisites</a>.</p>
<p>Do the following:</p>
<ol>
<li>To build the target image, run the command:
<pre><code>nix build github:tiiuae/ghaf#generic-x86_64-debug
</code></pre>
</li>
<li>After the build is completed, prepare a USB boot media with the target image you built:
<pre><code>dd if=./result/nixos.img of=/dev/&lt;YOUR_USB_DRIVE&gt; bs=32M
</code></pre>
</li>
<li>Boot the computer from the USB media.</li>
</ol>
<hr />
<h2 id="ghaf-image-for-nvidia-jetson-orin-agx"><a class="header" href="#ghaf-image-for-nvidia-jetson-orin-agx">Ghaf Image for NVIDIA Jetson Orin AGX</a></h2>
<p>Before you begin:</p>
<ul>
<li>Check device-independent <a href="ref_impl/./build_and_run.html#prerequisites">prerequisites</a>.</li>
<li>If you use a new device, <a href="ref_impl/./build_and_run.html#flashing-nvidia-jetson-orin-agx">flash bootloader firmware</a> first. Then you can <a href="ref_impl/./build_and_run.html#building-and-running-ghaf-image-for-nvidia-jetson-orin-agx">build and run a Ghaf image</a>.</li>
</ul>
<h4 id="flashing-nvidia-jetson-orin-agx"><a class="header" href="#flashing-nvidia-jetson-orin-agx">Flashing NVIDIA Jetson Orin AGX</a></h4>
<ol>
<li>
<p>Run the command:</p>
<pre><code>nix build github:tiiuae/ghaf#nvidia-jetson-orin-debug-flash-script 
</code></pre>
<p>It will build the Ghaf image and bootloader firmware, and prepare the flashing script. Give &quot;yes&quot; answers to all script questions. The building process takes around 1,5 hours.</p>
</li>
<li>
<p>Set up the following connections:</p>
<ol>
<li>Connect the board to a power supply with a USB-C cable.</li>
<li>Connect a Linux laptop to the board with the USB-C cable.</li>
<li>Connect the Linux laptop to the board with a Micro-USB cable to use <a href="https://developer.ridgerun.com/wiki/index.php/NVIDIA_Jetson_Orin/In_Board/Getting_in_Board/Serial_Console">serial interface</a>.</li>
</ol>
<blockquote>
<p>For more information on the board's connections details, see the <a href="https://developer.nvidia.com/embedded/learn/jetson-agx-orin-devkit-user-guide/developer_kit_layout.html">Hardware Layout</a> section of the Jetson AGX Orin Developer Kit User Guide.</p>
</blockquote>
</li>
<li>
<p>After the build is completed, put the board in recovery mode. For more information, see the <a href="https://developer.nvidia.com/embedded/learn/jetson-agx-orin-devkit-user-guide/howto.html#force-recovery-mode">Force Recovery</a> Mode section in the Jetson AGX Orin Developer Kit User Guide.</p>
</li>
<li>
<p>Run the flashing script:</p>
<pre><code>sudo ~/result/bin/flash-ghaf-host 
</code></pre>
<p>There is a time-out for this operation, so run the script within one minute after putting the device in recovery mode. If you got the error message &quot;ERROR: might be timeout in USB write.&quot;:</p>
<ol>
<li>Reboot the device and put it in recovery mode again.</li>
<li>Check with the <code>lsusb</code> command if your computer can still recognize the board, and run the flash script again.</li>
</ol>
</li>
<li>
<p>Restart the device after flashing is done.</p>
</li>
</ol>
<h4 id="building-and-running-ghaf-image-for-nvidia-jetson-orin-agx"><a class="header" href="#building-and-running-ghaf-image-for-nvidia-jetson-orin-agx">Building and Running Ghaf Image for NVIDIA Jetson Orin AGX</a></h4>
<p>After the latest firmware is <a href="ref_impl/./build_and_run.html#flashing-nvidia-jetson-orin-agx">flashed</a>, it is possible to use a simplified process by building only the Ghaf disk image and running it from external media:</p>
<ol>
<li>To build the target image, run the command:
<pre><code>nix build github:tiiuae/ghaf#nvidia-jetson-orin-debug 
</code></pre>
</li>
<li>After the build is completed, prepare a USB boot media with the target image you built:
<pre><code>dd if=./result/nixos.img of=/dev/&lt;YOUR_USB_DRIVE&gt; bs=32M 
</code></pre>
</li>
<li>Boot the hardware from the USB media.</li>
</ol>
<p>In the current state of Ghaf, it is a bit tricky to make NVIDIA Jetson Orin AGX boot Ghaf from a USB if the same thing has already been flashed on the boards's eMMC. To succeed, you can change partition labels on eMMC (or optionally wiping everything away by formatting):</p>
<ol>
<li>Log in as a root:
<pre><code>sudo su
</code></pre>
</li>
<li>Check the current labels:
<pre><code>lsblk -o name,path,fstype,mountpoint,label,size,uuid
</code></pre>
</li>
<li>Change the ext4 partition label:
<pre><code>e2label /dev/mmcblk0p1 nixos_emmc
</code></pre>
</li>
<li>Change the vfat partition label:
<pre><code>dosfslabel /dev/mmcblk0p2 ESP_EMMC
</code></pre>
</li>
<li>Verify the labels that were changed:
<pre><code>lsblk -o name,path,fstype,mountpoint,label,size,uuid
</code></pre>
</li>
<li>After these changes NVIDIA Jetson Orin AGX cannot boot from its internal eMMC. It will boot from the USB device with the correct partition labels.</li>
</ol>
<hr />
<h2 id="building-ghaf-image-for-nxp-imx-8qm-mek"><a class="header" href="#building-ghaf-image-for-nxp-imx-8qm-mek">Building Ghaf Image for NXP i.MX 8QM-MEK</a></h2>
<p>Before you begin, check device-independent <a href="ref_impl/./build_and_run.html#prerequisites">prerequisites</a>.</p>
<p>In the case of i.MX8, Ghaf deployment contains of creating a bootable SD card with a first-stage bootloader (Tow-Boot) and creating USB media with the Ghaf image:</p>
<ol>
<li>
<p>To build and flash <a href="https://github.com/tiiuae/Tow-Boot"><strong>Tow-Boot</strong></a> bootloader:</p>
<pre><code>$ git clone https://github.com/tiiuae/Tow-Boot.git &amp;&amp; cd Tow-Boot
$ nix-build -A imx8qm-mek
$ sudo dd if=result/ shared.disk-image.img of=/dev/&lt;SDCARD&gt;
</code></pre>
</li>
<li>
<p>To build and flash the Ghaf image:</p>
<ol>
<li>Run the <code>nix build .#packages.aarch64-linux.imx8qm-mek-release</code> command.</li>
<li>Prepare the USB boot media with the target HW image you built: <code>dd if=./result/nixos.img of=/dev/&lt;YOUR_USB_DRIVE&gt; bs=32M</code>.</li>
</ol>
</li>
<li>
<p>Insert an SD card and USB boot media into the board and switch the power on.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="cross-compilation"><a class="header" href="#cross-compilation">Cross-Compilation</a></h1>
<blockquote>
<p>Cross-compilation is currently under development and cannot be used properly on the supported devices.</p>
</blockquote>
<p>Ghaf is targeted at a range of devices and form factors that support different instruction set architectures (ISA). Many small form-factor edge devices are not powerful enough to compile the needed applications or OSs that run on them. As the most common ISA used in desktops and servers is <code>x_86</code>, this will generally require that the code is cross-compiled for target ISA e.g. <code>AArch64</code> or <code>RISC-V</code>.</p>
<p>NixOS and Nixpkgs have good support for cross-compilation, however, there are still some that can not be compiled in this way.</p>
<h2 id="binfmt"><a class="header" href="#binfmt">binfmt</a></h2>
<p><a href="https://en.wikipedia.org/wiki/Binfmt_misc">binfmt</a> allows running different ISA on a development machine. This is achieved by running the target binary in an emulator such as <code>QEMU</code> or in a VM.</p>
<p>To enable <code>binfmt</code>, we recommend to set the following in your host systems <code>configuration.nix</code>:</p>
<pre><code>boot.binfmt.emulatedSystems = [
  &quot;riscv64-linux&quot;
  &quot;aarch64-linux&quot;
];
</code></pre>
<p>In addition, it is recommended to enable KVM support with either</p>
<pre><code>boot.kernelModules = [ &quot;kvm-amd&quot; ];
</code></pre>
<p>or</p>
<pre><code>boot.kernelModules = [ &quot;kvm-intel&quot; ];
</code></pre>
<p>depending on whether your development host is running AMD or Intel processor.</p>
<h2 id="future-cross-compilation-support"><a class="header" href="#future-cross-compilation-support">Future Cross-Compilation Support</a></h2>
<p>This will involve working with upstream package maintainers to ensure that the packages are cross-compilation aware. This will be addressed on a package-by-package basis.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="supply-chain-security"><a class="header" href="#supply-chain-security">Supply Chain Security</a></h1>
<p>To be aware of what is exactly in our software supply chain, it is reviewed for security issues and known vulnerabilities.</p>
<p><img src="scs/../img/threat_processing.drawio.png" alt="Supply Chain Attacks Diagram" title="Supply Chain Attacks" /></p>
<p>We implement a <em>supply chain security (SCS)</em> ‚Äî process of securing the machinery of the development, building, and release environment. That means that every component that a software artifact might be touching on its way from the developer to the consumer will be secured.</p>
<p>The software artifact should be encrypted on each possible transition phase and its integrity should be verified at each destination. Each build should be accompanied by means of <a href="scs/../appendices/glossary.html#sbom"><em>software bill of materials (SBOM)</em></a>, identifying all the components that the software package consists of.</p>
<p>SBOM containing reference to each dependency, its source and version together with provenance, containing build information are collected at the build time, signed, and used for vulnerability analysis during the next steps.</p>
<p>The software artifact, SBOM, and provenance are signed by the build machinery at the build time, and the signature is verifiable at every destination of the package. The certificates that are used for signing and verification are provided by the <em>public key infrastructure (PKI)</em> system and are signed by the same root <em>certificate authority (CA)</em>. That allows you to confirm the author of the signature (build machinery) and guarantees that the package has not been tampered with since the build time.</p>
<h2 id="in-this-chapter-3"><a class="header" href="#in-this-chapter-3">In This Chapter</a></h2>
<ul>
<li><a href="scs/../scs/slsa-framework.html">SLSA Framework</a></li>
<li><a href="scs/../scs/basics.html">Basic Security Measures</a></li>
<li><a href="scs/../scs/sbom.html">SBOM</a></li>
<li><a href="scs/../scs/pki.html">Public Key Infrastructure</a></li>
<li><a href="scs/../scs/patching-automation.html">Patch Management Automation</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="slsa-framework"><a class="header" href="#slsa-framework">SLSA Framework</a></h1>
<p>Supply chain Levels for Software Artifacts (SLSA) is a security framework for tampering prevention, integrity improvement, and securing packages and infrastructure of a project. For more information about the SLSA framework, see the offical website <a href="https://slsa.dev">https://slsa.dev</a>.</p>
<h2 id="slsa-terminology"><a class="header" href="#slsa-terminology">SLSA Terminology</a></h2>
<p><strong>Immutable reference:</strong> An identifier, guaranteed to always point to the same, immutable artifact.</p>
<p><strong>Provenance:</strong> Metadata about how an artifact was produced.</p>
<p><strong>Revision:</strong> An immutable, coherent state of a source.</p>
<h2 id="levels-of-assurance"><a class="header" href="#levels-of-assurance">Levels of Assurance</a></h2>
<p>One of the requirements for the solution is to reach SLSA Level 4 and even go beyond that. This requires a lot of process changes as well as technical work. </p>
<p>The SLSA model consists of 4 levels, offering an incremental level of anti-tampering protection. Levels 1-3 represent milestones with certain integrity guarantees, whereas level 4 is an ideal end state.</p>
<p><strong>Level 0</strong> means no SLSA compliance and no guarantees are given.</p>
<p><strong>Level 1</strong> demands a fully scripted / automated build process and provenance generation. It offers basic confidence in the origin of the software but doesn‚Äôt provide any tamper resistance.</p>
<p><strong>Level 2</strong> Introduces authenticated provenance generated by a hosted build at the same time demanding version control system usage. Provenance prevents tampering and offers trust in the build service.</p>
<p><strong>Level 3</strong> offers auditability of the source and the integrity of the provenance. Much stronger tampering protection is provided by preventing specific classes of threats such as cross-build contamination.</p>
<p><strong>Level 4</strong> requires two-peer source code review and a hermetic, reproducible build process. Overall Level 4 offers a high degree of confidence in the anti-tampering protection of the software.</p>
<p>SLSA level is not transitive, thus level of the artifact is not dependent on the level of dependencies, which are expected to have their own SLSA levels. This makes it possible to build a Level 4 artifact from Level 0 dependencies. </p>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Requirements</th><th>Level 1</th><th>Level 2</th><th>Level 3</th><th>Level 4</th></tr></thead><tbody>
<tr><td>Source ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#version-controlled">Version controlled</a></td><td></td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Source ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#verified-history">Verified history</a></td><td></td><td></td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Source ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#retained-indefinitely">Retained indefinitely</a></td><td></td><td></td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Source ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#two-person-reviewed">Two-person reviewed</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#scripted-build">Scripted build</a></td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#build-service">Build service</a></td><td></td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#build-as-code">Build as code</a></td><td></td><td></td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#ephemeral-environment">Ephemeral environment</a></td><td></td><td></td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#isolated">Isolated</a></td><td></td><td></td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#parameterless">Parameterless</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#hermetic">Hermetic</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
<tr><td>Build ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#reproducible">Reproducible</a></td><td></td><td></td><td></td><td>‚óã</td></tr>
<tr><td>Provenance ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#available">Available</a></td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Provenance ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#authenticated">Authenticated</a></td><td></td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Provenance ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#service-generated">Service generated</a></td><td></td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Provenance ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#non-falsifiable">Non-falsifiable</a></td><td></td><td></td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Provenance ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#dependencies-complete">Dependencies complete</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
<tr><td>Common ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#security">Security</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
<tr><td>Common ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#access">Access</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
<tr><td>Common ‚Äî <a href="https://slsa.dev/spec/v0.1/requirements#superusers">Superusers</a></td><td></td><td></td><td></td><td>‚úì</td></tr>
</tbody></table>
</div>
<p>‚úì ‚Äî required</p>
<p>‚óã ‚Äî required unless justified otherwise</p>
<p>empty cell ‚Äî not required</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="basic-security-measures"><a class="header" href="#basic-security-measures">Basic Security Measures</a></h1>
<h2 id="source-code--version-control-security"><a class="header" href="#source-code--version-control-security">Source Code / Version Control Security</a></h2>
<p>The source code security is based on the fact that the source code is two-person reviewed, version controlled, and the history is verified and retained indefinitely.</p>
<h3 id="commit-signing"><a class="header" href="#commit-signing">Commit Signing</a></h3>
<p>All the commits to repositories must be GPG-signed. This can be achieved by enabling GPG commit signatures in the config:</p>
<p><code>git config --global commit.gpgsign true</code></p>
<p>For more detailed information, see the <a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/signing-commits" title="Signing Commits on GitHub">Signing commits</a> article of the GitHub Docs.</p>
<h3 id="branch-protection"><a class="header" href="#branch-protection">Branch Protection</a></h3>
<p>In the case of GitHub the following settings should be considered:</p>
<ul>
<li>Require pull request reviews before merging (req: two-person reviewed source).</li>
<li>Require status checks before merging.</li>
<li>Require conversation resolution before merging.</li>
<li>Require signed commits.</li>
<li>Deletions should be forbidden (req: immutable history).</li>
</ul>
<h2 id="software-signing"><a class="header" href="#software-signing">Software Signing</a></h2>
<p>Software signing is an important measure to validate the author and ensure that the code has not been altered on the way from the developer to the customer. Nix tooling is offering means to sign the derivations using libsodium with EdDSA, however, as the modular system is assumed, scripts need to be developed to support signing mechanisms in an absence of Nix tooling.</p>
<p>By default, the software image is signed only at the binary cache per request. Which leaves the path from Hydra to the binary cache unsecured. The problem can be resolved in two ways:</p>
<ul>
<li>Enabling the image signing on Hydra</li>
<li>Shared Nix Store</li>
</ul>
<h3 id="enabling-image-signing-on-hydra"><a class="header" href="#enabling-image-signing-on-hydra">Enabling Image Signing on Hydra</a></h3>
<p>Enabling the image signing on Hydra requires some extra work due to the lack of well-documented support of image signing at Hydra at the time of writing this document. As already mentioned, NixOS is using libsodium-based EdDSA solution for image signing. So similar scripts can be implemented. For example, in Python by using existing libsodium bindings, such as PyNaCl.</p>
<p><img src="scs/../img/threat_processing_2serv.drawio.png" alt="Enabling Image Signing on Hydra" title="Enabling The Image Signing On Hydra" /></p>
<h3 id="shared-nix-store"><a class="header" href="#shared-nix-store">Shared Nix Store</a></h3>
<p>The shared NixStore option is rather straightforward if Hydra is combined with the binary cache. This kind of setup is lacking the extra transition path. Thus the packages signed by the binary cache will be served straight from the Hydra NixStore.</p>
<p><img src="scs/../img/threat_processing_1serv.drawio.png" alt="Shared NixStore Solution" title="Shared NixStore" /></p>
<h2 id="data-encryption-in-transit"><a class="header" href="#data-encryption-in-transit">Data Encryption in Transit</a></h2>
<p>All the data should be transported over secure encrypted channels. Since all the transportation is done over TCP/IP protocol stack, it is possible to use native solutions like TLS to secure the traffic between the nodes. Version 1.2 is a minimum requirement.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="software-bill-of-materials-sbom"><a class="header" href="#software-bill-of-materials-sbom">Software Bill of Materials (SBOM)</a></h1>
<p>Software bill of materials (SBOM) is a formal, machine-readable document that provides a list of software components that make up the target software and all its dependencies.</p>
<h2 id="sbom-formats-and-specifications"><a class="header" href="#sbom-formats-and-specifications">SBOM Formats and Specifications</a></h2>
<p>There are three main delivery formats and specifications for SBOM: CycloneDX, SPDX, and SWID.</p>
<p><a href="https://cyclonedx.org/specification/overview/">CycloneDX</a> is an open-source standard with origins in the <a href="https://en.wikipedia.org/wiki/OWASP">OWASP</a> community. The specification's original focus is on security. There's a large growing community and open source tooling that support CycloneDX format.</p>
<p><a href="https://spdx.dev/specifications/">SPDX</a> is also a product of an open-source community, with the original focus on licensing. SPDX is run and maintained by <a href="https://en.wikipedia.org/wiki/Linux_Foundation">Linux Foundation</a>. Similarly to CycloneDX, many open-source tools support the SPDX format. </p>
<p><a href="https://nvd.nist.gov/products/swid">SWID</a> is a <a href="https://www.iso.org/standard/65666.html">standard</a> that originates from <a href="https://www.nist.gov/">NIST</a>. SWID tags aim to help organizations create accurate software inventories. While SWID can serve as an SBOM too, it is not as widely used SBOM format in open source as the two other specifications.</p>
<h2 id="sbom-usage-in-ghaf"><a class="header" href="#sbom-usage-in-ghaf">SBOM Usage in Ghaf</a></h2>
<p>Ghaf framework will use SBOMs for:</p>
<ul>
<li>Vulnerability identification: automatic correlation of SBOM against known vulnerabilities.</li>
<li>Vulnerability remediation: automatic process to suggest fixes for identified vulnerabilities.</li>
<li>Dependency analysis: categorization of open-source and closed source software dependencies.</li>
<li>Dependency analysis: creation of a directed acyclic graph</li>
<li>License compliance: know and comply with the license obligations.</li>
<li>Market signal: publish SBOM together with other release artifacts.</li>
</ul>
<h2 id="sbom-tooling-in-ghaf"><a class="header" href="#sbom-tooling-in-ghaf">SBOM Tooling in Ghaf</a></h2>
<p>Ghaf is based on Nix, therefore, the selected SBOM tooling needs to support creating SBOMs for nix artifacts. As part of the Ghaf project, we have created the sbomnix tool to support SBOM generation for Ghaf and, more generally, for any nix targets. For more details on the SBOM tooling in Ghaf, see <a href="https://github.com/tiiuae/sbomnix#sbomnix">sbomnix</a> and <a href="https://github.com/tiiuae/sbomnix/blob/main/doc/nixgraph.md#nixgraph">nixgraph</a>.</p>
<p>Initially, sbomnix will support <a href="https://cyclonedx.org/specification/overview/">CycloneDX</a> SBOM specification, due to the availability of other open source tools that also support CycloneDX. Support for other SBOM formats to sbomnix might be added in later versions.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://ntia.gov/page/software-bill-materials">https://ntia.gov/page/software-bill-materials</a></li>
<li><a href="https://slsa.dev/blog/2022/05/slsa-sbom">https://slsa.dev/blog/2022/05/slsa-sbom</a></li>
<li><a href="https://fossa.com/blog/software-bill-of-materials-formats-use-cases-tools">https://fossa.com/blog/software-bill-of-materials-formats-use-cases-tools</a></li>
<li><a href="https://www.legitsecurity.com/blog/what-is-an-sbom-sbom-explained-in-5-minutes">https://www.legitsecurity.com/blog/what-is-an-sbom-sbom-explained-in-5-minutes</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="public-key-infrastructure"><a class="header" href="#public-key-infrastructure">Public Key Infrastructure</a></h1>
<p>In the SCS context, a public key infrastructure (PKI) term refers to a system for the creation, storage, and distribution of digital certificates which are used to verify that a particular key belongs to a certain entity. PKI creates and manages a hierarchical set of digital certificates which map public keys to certain entities. Storage and revocation methodologies are to be defined.</p>
<p>The PKI of SCS should consist of:</p>
<ul>
<li>Certificate authority (CA) for storing, issuing, and signing the digital certificates.</li>
<li>Registration authority (RA) for requesting entity identity verification.</li>
<li>Central directory for the secure storage of the keys.</li>
<li>Certificate Management System (CMS) for managing access to stored certificates.</li>
</ul>
<h2 id="private-certificate-authority-pca"><a class="header" href="#private-certificate-authority-pca">Private Certificate Authority (PCA)</a></h2>
<p>PCA enables the creation of private certificate authority hierarchies, consisting of Root and Subordinate CAs. It issues end-entity X.509 certificates, that are used for: </p>
<ul>
<li>Encrypted TLS communication channels (data encryption in transit)</li>
<li>Code and image signing</li>
</ul>
<p>PCA can be established in the cloud or on-premises. Initially, the OpenSSL-based solution deployed on-premises is assumed, however, some of the target projects might consider using commercial cloud solutions. </p>
<h2 id="hardware-security-module"><a class="header" href="#hardware-security-module">Hardware Security Module</a></h2>
<p>On-premises solution can be further improved by adding a Hardware Security Module (HSM). It is a physical device for managing cryptographic material such as digital keys. </p>
<p>HSM can be also used to perform cryptographic operations such as digital signing, encryption, and decryption. The HSM contains one or more Secure Cryptoprocessors that are dedicated microprocessors optimized for carrying out cryptographic operations. </p>
<p>One example of affordable HSM solutions is YubiHSM developed by Yubico.</p>
<h3 id="hsm-variants-for-consideration"><a class="header" href="#hsm-variants-for-consideration">HSM Variants for Consideration</a></h3>
<p>The following HSM solutions are considered for the Ghaf project:</p>
<ul>
<li><a href="https://www.yubico.com/fi/product/yubihsm-2/" title="YubiHSM2">YubiHSM2</a></li>
<li><a href="https://shop.nitrokey.com/shop/product/nkhs2-nitrokey-hsm-2-7" title="NitrokeyHSM2">NitrokeyHSM2</a></li>
<li><a href="https://github.com/opendnssec/SoftHSMv2" title="SoftHSMv2">SoftHSMv2</a></li>
<li>BreadboardHSM</li>
</ul>
<p>The following table provides feature comparison of the proposed solutions: </p>
<blockquote>
<p>Since the feature list is quite extensive, the table is limited to the features that are either planned to be used in Ghaf or might benefit the project in the future.</p>
</blockquote>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>YubiHSM 2</th><th>NitrokeyHSM2</th><th>SoftHSMv2</th><th>BreadboardHSM</th></tr></thead><tbody>
<tr><td>Secure key storage</td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>ECC</td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>EdDSA (ed25519)</td><td>‚úì</td><td></td><td>?</td><td></td></tr>
<tr><td>ECDSA</td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>RSA</td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td></td></tr>
<tr><td>PKCS#11 interface</td><td>‚úì</td><td>‚úì</td><td>‚úì</td><td>‚úì</td></tr>
<tr><td>Network shareable</td><td>‚úì</td><td></td><td>‚úì</td><td></td></tr>
<tr><td>M of N wrap rule</td><td>‚úì</td><td>‚úì</td><td></td><td></td></tr>
<tr><td>Tamper evident audit logging</td><td>‚úì</td><td></td><td></td><td></td></tr>
<tr><td>Storage capacity</td><td>128KB, 255xAny ECC</td><td>76KB, 35xECC-512</td><td></td><td>9.7Kb, 16 slots</td></tr>
<tr><td>Price</td><td>650EUR (VAT 0%)</td><td>99 EUR</td><td>FOSS</td><td>HW Costs</td></tr>
</tbody></table>
</div>
<p>YubiHSM2 is the leading solution considering its cryptographic capabilities. However, taking into account quite modest needs of SCS, NitrokeyHSM2 represents an adequate option. </p>
<p>The main benefit of YubiHSM2 from SCS perspective is its native support of EdDSA-curve25519, which is the one that NixOS is using for package signing. Thus YubiHSM2 could be used directly with NixOS. However, as the package doesn't change in transit from the Build System to the Consumer, usage of inbuilt tooling is not always necessary.</p>
<p>BreadboardHSM solution is based on Microchip ATECC608B (TrustFLEX + cryptoauthlib + gtutls), though development work is still ongoing at the time of writing this document. The SoftHSMv2 and BreadboardHSM are taken for comparison showing what can be achieved using FOSS variants. </p>
<h2 id="ca-hierarchy-options"><a class="header" href="#ca-hierarchy-options">CA Hierarchy Options</a></h2>
<p>CA usually consists of:</p>
<ul>
<li>Root CA - the root of trust of the entire PKI, for issuing and signing the certificates used by other CAs.</li>
<li>Subordinate CA for issuing end-entity certificates.</li>
</ul>
<p>There are three types of hierarchies: one-tier, two-tier, and three-tier. The hierarchy can be chosen based on the target project's needs and complexity. A one-tier hierarchy is not considered for any production usage due to the low security, as the compromise of a single CA leads to a compromise of the entire PKI.</p>
<p>In a two-tier hierarchy, the Root CA and issuing (Subordinate) CAs are separated for increasing the security level. This is the simplest production level hierarchy allowing to keep Root CA at the most secure and restrictive levels, yet making subordinate CA access slightly more permissive. This hierarchy is most likely sufficient for most of the target projects.</p>
<p>In a three-tier CA, an intermediate CA is placed between the Root CA and the Subordinate (issuing) CA. This is done to separate the Root CA from low-level CA operations. The middle layer (intermediate CA) is only used to sign Subordinate CAs that issue the end-entity certificates. </p>
<h2 id="proposed-ca-hierarchy"><a class="header" href="#proposed-ca-hierarchy">Proposed CA Hierarchy</a></h2>
<p>The following diagram describes the proposed CA for the SCS. The three-tier CA is chosen based on the high-security level and the potential need to scale it to several projects, later on, keeping the main control under the same Root CA.</p>
<p><img src="scs/../img/ca_implementation.drawio.png" alt="Proposed CA" title="CA Implementation Proposal" /></p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="patch-management-automation"><a class="header" href="#patch-management-automation">Patch Management Automation</a></h1>
<p>An automated patch management solution increases complex software development efficiency concurrently ensuring a high level of vulnerability remediation in a reasonable time frame.</p>
<p><img src="scs/../img/autopatching.drawio.png" alt="Patch Management Automation" title="Automated Patch Management Solution" /></p>
<p>The patch management automation (PMA) system processes data in cycles. Every cycle includes a number of stages:</p>
<ol>
<li>The developer submits the change to the repository. Hydra builds the package from the source.</li>
<li>The Vulnerability Analysis (VA) component scans each software artifact for vulnerabilities immediately after the build.</li>
<li>If new vulnerabilities are discovered, the PMA system scans each dependency provenance for the update availability.</li>
<li>If update availability exists, the PMA system downloads new dependencies, and Hydra builds the new package.</li>
<li>The package is rebuilding with updated dependencies that may affect functionality. The PMA system starts the package regression testing.</li>
<li>A package passing the testing will be presented to the concerned developers for review and approval. The SBOM, scan and test results along with the package are published to a web server. The developer downloads the artifacts for review and approval.</li>
<li>All approved artifacts become release candidates and can be found on the web server.</li>
</ol>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="dependency-tracking"><a class="header" href="#dependency-tracking">Dependency Tracking</a></h3>
<p>The dependency tracking solution is based on Package URL (PURL), natively supported by ClyconeDX. PURL is a URL, composed of seven components:</p>
<p><code>scheme:type/namespace/name@version?qualifiers#subpath</code></p>
<ul>
<li><strong>scheme</strong>: URL scheme, with the constant value &quot;pkg&quot;, facilitating the future official registration of the &quot;pkg&quot; scheme for package URLs.</li>
<li><strong>type</strong>: the package type, such as npm, maven, etc.</li>
<li><strong>namespace</strong>: name prefix. For example GitHub user, organization, etc.</li>
<li><strong>name</strong>: the name of the package.</li>
<li><strong>version</strong>: the version of the package.</li>
<li><strong>qualifiers</strong>: extra qualifying data, e.g. OS, distro, architecture, etc.</li>
<li><strong>subpath</strong>: extra subpath relative to package root.</li>
</ul>
<p>In addition to PURL, each component should contain at least one hash value, computed from cryptographic hash functions. The hash values help to verify the original package integrity and source prior to update the download. Thus minimizing security risks during the process.</p>
<h3 id="package-update"><a class="header" href="#package-update">Package Update</a></h3>
<p>The update mechanism implementation depends on a system and will differ from one build system to another.</p>
<p>For example, in Nix it is enough that respective Nix files are automatically updated and the package is rebuilt. For more information on package update steps, see the <a href="https://nixos.wiki/wiki/Update_a_package">Update a package</a> article of the NixOS Wiki.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="research-notes"><a class="header" href="#research-notes">Research Notes</a></h1>
<p>Our experience in research and lessons learned activities:</p>
<ul>
<li><a href="research/passthrough/ethernet.html">i.MX 8QM platform bus ethernet passthrough</a></li>
<li><a href="research/run_win_vm.html">Windows 11 in VM on Ghaf</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="imx-8qm-ethernet-passthrough"><a class="header" href="#imx-8qm-ethernet-passthrough">i.MX 8QM Ethernet Passthrough</a></h1>
<p>The i.MX 8QuadMax (i.MX 8QM, iMX8QM, imx8qm) passthrough host setup relies as much as possible on the default i.MX 8QM MEK (imx8qm-mek) device tree configuration. Some guidance on what is required for passthrough to work on i.MX 8 can be found in the XEN device trees.</p>
<p>This document provides a detailed description of what has been done and why. For the more impatient readers, the example device tree files for i.MX 8QM guest and host with Ethernet passthrough are available here:</p>
<ul>
<li>Full host device tree: <a href="research/passthrough/imx8qm-mek_conn-host.dts">imx8qm-mek_conn-host.dts</a></li>
<li>Full guest device tree: <a href="research/passthrough/imx8qm-mek_conn-guest.dts">imx8qm-mek_conn-guest.dts</a></li>
</ul>
<p><strong>NOTE 20.12.2022:</strong>
At the current state, the passthrough is not completely functional. The Ethernet device (fec1) or even both devices (fec1 and fec2) can be set up in the guest. The devices respond and seem functional, the device node does activate, the drivers load correctly, the power state of the device changes to active, and the link state of the Ethernet connection seems to change correctly. However, for some reason, no actual Ethernet data packages go through the Ethernet adapter. The most visible issue is that no interrupts come to the Ethernet devices.</p>
<p>See the following topics:</p>
<ul>
<li><a href="research/passthrough/ethernet.html#imx-8qm-ethernet-passthrough">i.MX 8QM Ethernet Passthrough</a>
<ul>
<li><a href="research/passthrough/ethernet.html#host-kernel-configuration">Host Kernel Configuration</a></li>
<li><a href="research/passthrough/ethernet.html#host-device-tree-explained">Host Device Tree Explained</a>
<ul>
<li><a href="research/passthrough/ethernet.html#other-notes-about-passthrough">Other Notes About Passthrough</a></li>
</ul>
</li>
<li><a href="research/passthrough/ethernet.html#changes-in-u-boot">Changes in U-Boot</a></li>
<li><a href="research/passthrough/ethernet.html#running-platform-device-passthrough-in-qemu">Running Platform Device Passthrough in QEMU</a></li>
<li><a href="research/passthrough/ethernet.html#guest-setup">Guest Setup</a>
<ul>
<li><a href="research/passthrough/ethernet.html#adding-devices-to-guest">Adding Devices to Guest</a></li>
<li><a href="research/passthrough/ethernet.html#some-final-touches-for-guest-devices">Some Final Touches for Guest Devices</a></li>
</ul>
</li>
<li><a href="research/passthrough/ethernet.html#compiling-the-device-tree-source-to-binary-form">Compiling the Device Tree Source to Binary Form</a>
<ul>
<li><a href="research/passthrough/ethernet.html#compiling-for-guest">Compiling for Guest</a></li>
<li><a href="research/passthrough/ethernet.html#compiling-for-host">Compiling for Host</a></li>
</ul>
</li>
<li><a href="research/passthrough/ethernet.html#running-qemu-with-passthrough-platform-devices">Running QEMU with Passthrough Platform Devices</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="host-kernel-configuration"><a class="header" href="#host-kernel-configuration">Host Kernel Configuration</a></h2>
<p>Kernel version 5.10 was used during the setup. For the passthrough to work, a few kernel configuration options need to be added to the default i.MX 8QM configuration:</p>
<ul>
<li>CONFIG_VFIO_PLATFORM=y</li>
<li>CONFIG_IOMMU_DEFAULT_PASSTHROUGH=y</li>
<li>CONFIG_VFIO_PLATFORM=y</li>
<li>CONFIG_ARM_SMMU_V3_SVA=y</li>
</ul>
<h2 id="host-device-tree-explained"><a class="header" href="#host-device-tree-explained">Host Device Tree Explained</a></h2>
<p>The default Freescale i.MX 8QM MEK configuration is included and then updated to get the Ethernet device passthrough configuration added on top of the original device configuration.</p>
<p>There are two problems with using the i.MX 8 XEN configuration as a reference. The first issue is that the configuration between XEN and KVM do not map one to one. The second issue is more specific to Ethernet passthrough, as i.MX 8 XEN configuration does not set up passthrough for Ethernet so most of the configuration needs to be figured out from scratch.</p>
<pre><code>#include &quot;freescale/imx8qm-mek.dts&quot;
/ {
    domu {
        /*
        * There are 5 MUs, 0A is used by Dom0, 1A is used
        * by ATF, so for DomU, 2A/3A/4A could be used.
        * SC_R_MU_0A
        * SC_R_MU_1A
        * SC_R_MU_2A
        * SC_R_MU_3A
        * SC_R_MU_4A
        * The rsrcs and pads will be configured by uboot scu_rm cmd
        */
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;0&gt;;
        doma {
            compatible = &quot;xen,domu&quot;;
            /*
            * The name entry in VM configuration file
            * needs to be same as here.
            */
            domain_name = &quot;DomU&quot;;
            /*
            * The reg property will be updated by U-Boot to
            * reflect the partition id.
            */
            reg = &lt;0&gt;;
            
            /*
            * Initialize and activate the Mailbox MU2A at boot
            */
            init_on_rsrcs = &lt;
                IMX_SC_R_MU_2A
            &gt;;

            /*
            * Mark the Mailbox and Ethernet adapter power domains available to guest
            */
            rsrcs = &lt;
                IMX_SC_R_MU_2A
                IMX_SC_R_ENET_0
            &gt;;

            /* 
            * Mark the pads for ethernet adapter fec1 available to guest
            */
            pads = &lt;
                IMX8QM_ENET0_MDIO
                IMX8QM_ENET0_MDC
                IMX8QM_ENET0_REFCLK_125M_25M

                IMX8QM_ENET0_RGMII_TXC
                IMX8QM_ENET0_RGMII_TX_CTL
                IMX8QM_ENET0_RGMII_TXD0
                IMX8QM_ENET0_RGMII_TXD1
                IMX8QM_ENET0_RGMII_TXD2
                IMX8QM_ENET0_RGMII_TXD3
                IMX8QM_ENET0_RGMII_RXC
                IMX8QM_ENET0_RGMII_RX_CTL
                IMX8QM_ENET0_RGMII_RXD0
                IMX8QM_ENET0_RGMII_RXD1
                IMX8QM_ENET0_RGMII_RXD2
                IMX8QM_ENET0_RGMII_RXD3
                IMX8QM_COMP_CTL_GPIO_1V8_3V3_ENET_ENETB

                IMX8QM_SCU_GPIO0_07
                IMX8QM_SPI0_CS1
                IMX8QM_SPI2_CS1
                IMX8QM_SAI1_RXFS
                IMX8QM_SAI1_RXC
            &gt;;

            /* GPIOS as default from imxqm XEN device tree */
            gpios = &lt;&amp;lsio_gpio1 13 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 19 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 27 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 28 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio1 30 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 1 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 3 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 6 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 9 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 11 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 19 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 22 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 25 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 26 GPIO_ACTIVE_HIGH&gt;,
                &lt;&amp;lsio_gpio4 27 GPIO_ACTIVE_LOW&gt;,
                &lt;&amp;lsio_gpio4 29 GPIO_ACTIVE_LOW&gt;;
        };
    };
};

/*
 * Add iommus property for the passed through device nodes to allow setting up vfio  
 * The device type &quot;compatible&quot; is changed to prevent the system from loading a  
 * driver the the adapter.  
 * Most other properties are removed from the adapter.
 */
&amp;fec1 {
    iommus = &lt;&amp;smmu 0x12 0x7f80&gt;;
    compatible = &quot;fsl,dummy&quot;;
    status = &quot;okay&quot;;

    /delete-property/ power-domains;
    /delete-property/ clocks;
    /delete-property/ clock-names;
    /delete-property/ assigned-clocks;
    /delete-property/ assigned-clock-rates;
    /delete-property/ phy-handle;
    /delete-property/ pinctrl-names;
    /delete-property/ pinctrl-0;
};

/* 
 * The device is not being used by guest. Just to make sure it is removed from iommu
 * group and disabled.
 */
&amp;fec2 {
    /delete-property/ iommus;
    status = &quot;disabled&quot;;
};

/*
 * Timer device for fec1
&amp;enet0_lpcg {
    iommus = &lt;&amp;smmu 0x12 0x7f80&gt;;
    compatible = &quot;fsl,dummy&quot;;
    status = &quot;okay&quot;;
    /delete-property/ power-domains;
    /delete-property/ clocks;
    /delete-property/ clock-names;
    /delete-property/ assigned-clocks;
    /delete-property/ assigned-clock-rates;
    /delete-property/ pinctrl-0;
};

&amp;enet1_lpcg {
    /delete-property/ iommus;
    status = &quot;disabled&quot;;
};

&amp;lsio_mu2 {
    iommus = &lt;&amp;smmu 0x12 0x7f80&gt;;
    compatible = &quot;fsl,dummy&quot;;
    status = &quot;okay&quot;;
};

/*
* Remove iommus properties from other devices which are not passed through for  Network VM
*/
&amp;usdhc1 {
    /delete-property/ iommus;
};

&amp;usdhc2 {
    /delete-property/ iommus;
};

&amp;usdhc3 {
    /delete-property/ iommus;
};

&amp;sata {
    /delete-property/ iommus;
};

&amp;usbotg3 {
    /delete-property/ iommus;
};

&amp;usbotg3_cdns3 {
    /delete-property/ iommus;
};
</code></pre>
<h3 id="other-notes-about-passthrough"><a class="header" href="#other-notes-about-passthrough">Other Notes About Passthrough</a></h3>
<ul>
<li>All devices which belong to the same VFIO/IOMMU group need to be passed through to the guest.</li>
<li>To prevent the device from being initialized by the host, change the device-compatible property to a dummy such as &quot;fsl,dummy&quot;.</li>
<li>The device status need needs to be &quot;okay&quot; for the device node to be available.</li>
<li>If U-Boot finds devices that appear in the doma <em>rsrcs</em> that contains the properties listed below, the device will get removed from the DTB:
<ul>
<li>power-domains</li>
<li>clocks</li>
<li>clock-names</li>
<li>assigned-clocks</li>
<li>assigned-clock-rates</li>
<li>pinctrl-0</li>
</ul>
</li>
</ul>
<h2 id="changes-in-u-boot"><a class="header" href="#changes-in-u-boot">Changes in U-Boot</a></h2>
<p>In our host device tree, we defined a couple of &quot;rsrcs&quot; resources to be handed over to the guest system. The ownership of these registers needs to be transferred to the guest after loading our device tree and before the actual boot. This can be done in U-Boot with a command:</p>
<pre><code>scu_rm dtb ${fdt_addr}
</code></pre>
<p>The easiest way to accomplish this automatically during boot is to add the &quot;scu_rm&quot; to the default i.MX 8QM U-Boot &quot;boot_os&quot; command and save the changes as below:</p>
<pre><code>setenv boot_os 'scu_rm dtb ${fdt_addr}; booti ${loadaddr} - ${fdt_addr};'
saveenv
</code></pre>
<h2 id="running-platform-device-passthrough-in-qemu"><a class="header" href="#running-platform-device-passthrough-in-qemu">Running Platform Device Passthrough in QEMU</a></h2>
<p>Before you start QEMU, the passedthrough devices need to be bind to the VFIO driver.</p>
<p>In some cases, the default driver needs to be unbind before the device can be bind to VFIO. However, in this case, all devices were changed to use the dummy device type in the device tree, so the step below is not required for this setup.</p>
<pre><code>echo 5d1d0000.mailbox &gt; /sys/bus/platform/devices/5d1d0000.mailbox/driver/unbind
echo 5b040000.ethernet &gt; /sys/bus/platform/devices/5b040000.ethernet/driver/unbind
echo 5b230000.clock-controller &gt; /sys/bus/platform/devices/5b230000.clock-controller/driver/unbind
</code></pre>
<p>The VFIO driver allows user-level access to the devices. Binding required devices to VFIO can be done as below:</p>
<pre><code>echo vfio-platform  &gt; /sys/bus/platform/devices/5d1d0000.mailbox/driver_override
echo 5d1d0000.mailbox &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b040000.ethernet/driver_override
echo 5b040000.ethernet &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b230000.clock-controller/driver_override
echo 5b230000.clock-controller &gt; /sys/bus/platform/drivers/vfio-platform/bind
</code></pre>
<p>After binding the devices to VFIO so it is possible to pass the devices to QEMU using &quot;<strong>-device vfio-platform</strong>&quot; arguments as below. The order in which the device arguments are given to QEMU may have an effect on some device properties such as interrupts.</p>
<pre><code>-device vfio-platform,host=5b230000.clock-controller
-device vfio-platform,host=5b040000.ethernet
-device vfio-platform,host=5d1d0000.mailbox
</code></pre>
<h2 id="guest-setup"><a class="header" href="#guest-setup">Guest Setup</a></h2>
<p>Before starting the virtual machine with passed-through devices, we need to define our virtual machine device tree. One way of gaining a template for our QEMU device tree is by starting our QEMU instance and requesting a dump of its device tree in the DTB format as below.</p>
<p>DTB is a binary format of the device tree so we also need to use the command line tool device tree compiler <strong>dtc</strong> to convert the binary device tree to a more human-friendly device tree source format. Converting the device tree to source format may give a few warnings of missing or unrecognized properties and such but that is normal.</p>
<pre><code>qemu-system-aarch64 \
    -M virt,gic-version=host,dumpdtb=virt.dtb -enable-kvm -nographic

# Convert binary to source device tree format
dtc -I dtb -O dts virt.dtb &gt; virt.dts
</code></pre>
<p>This will provide a &quot;<strong>virt.dts</strong>&quot; file which can be used as a base for adding our passedthrough devices. The U-Boot device tree may change based on the U-Boot version, so the guest device tree may need some maintenance every now and then.</p>
<h3 id="adding-devices-to-guest"><a class="header" href="#adding-devices-to-guest">Adding Devices to Guest</a></h3>
<p>The platform devices which are going to get passed through should be added to the QEMU device tree <strong>platform</strong> bus section.</p>
<p>In this case, the main devices are <strong>fec1</strong>, <strong>enet0_lpcg</strong> and <strong>lsio_mu2</strong>. At the time of writing, the platform bus address in QEMU is &quot;<strong>c000000</strong>&quot; but that can be changed within the following code (needs recompiling QEMU) or it might change during some the QEMU code update.</p>
<pre><code>platform@c000000 {
	compatible = &quot;qemu,platform\0simple-bus&quot;;
	interrupt-parent = &lt;0x8001&gt;;
	#address-cells = &lt;0x02&gt;;
	#size-cells = &lt;0x02&gt;;

    /* Devices register remapping 
	// ranges = &lt;0xc000000 0x00 0xc000000 0x2000000&gt;;
	ranges = &lt;0x00 0x5b230000 0x00 0xc000000 0x00 0x10000&gt;,
			 &lt;0x00 0x5b040000 0x00 0xc010000 0x00 0x10000&gt;,
			 &lt;0x00 0x5d1d0000 0x00 0xc020000 0x00 0x10000&gt;;

    /*
    * Fec1 device configuration
    * Mostly the same that was set in the original host device configuration
    * The original interrupts can be left here as reference but they are updated at the end of config
    */
    fec1: ethernet@5b040000 {
        reg = &lt;0x00 0x5b040000 0x00 0x10000&gt;;
        interrupts = &lt;GIC_SPI 258 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 256 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 257 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 259 IRQ_TYPE_LEVEL_HIGH&gt;;
        clocks = &lt;&amp;enet0_lpcg 4&gt;,
            &lt;&amp;enet0_lpcg 2&gt;,
            &lt;&amp;enet0_lpcg 3&gt;,
            &lt;&amp;enet0_lpcg 0&gt;,
            &lt;&amp;enet0_lpcg 1&gt;;
        clock-names = &quot;ipg&quot;, &quot;ahb&quot;, &quot;enet_clk_ref&quot;, &quot;ptp&quot;, &quot;enet_2x_txclk&quot;;
        assigned-clocks = &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_PM_CLK_PER&gt;,
                &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_C_CLKDIV&gt;;
        assigned-clock-rates = &lt;250000000&gt;, &lt;125000000&gt;;
        fsl,num-tx-queues=&lt;1&gt;;
        fsl,num-rx-queues=&lt;1&gt;;
        power-domains = &lt;&amp;pd IMX_SC_R_ENET_0&gt;;
        status = &quot;okay&quot;;
    };

    /*
    * Fec1 devices clock controller device configuration
    * Mostly the same that was set in the original host device configuration
    * The actual clocks are nor configured so those need to be added to guest
    */
    enet0_lpcg: clock-controller@5b230000 {
        compatible = &quot;fsl,imx8qxp-lpcg&quot;;
        reg = &lt;0x00 0x5b230000 0x00 0x10000&gt;;
        #clock-cells = &lt;1&gt;;
        clocks = &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_PM_CLK_PER&gt;,
            &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_PM_CLK_PER&gt;,
            &lt;&amp;conn_axi_clk&gt;,
            &lt;&amp;clk IMX_SC_R_ENET_0 IMX_SC_C_TXCLK&gt;,
            &lt;&amp;conn_ipg_clk&gt;,
            &lt;&amp;conn_ipg_clk&gt;;
        bit-offset = &lt;0 4 8 12 16 20&gt;;
        clock-output-names = &quot;enet0_lpcg_timer_clk&quot;,
                    &quot;enet0_lpcg_txc_sampling_clk&quot;,
                    &quot;enet0_lpcg_ahb_clk&quot;,
                    &quot;enet0_lpcg_rgmii_txc_clk&quot;,
                    &quot;enet0_lpcg_ipg_clk&quot;,
                    &quot;enet0_lpcg_ipg_s_clk&quot;;
        power-domains = &lt;&amp;pd IMX_SC_R_ENET_0&gt;;
        status = &quot;okay&quot;;
    };

    /*
    * Mailbox device for Fec1 (and SCU)
    * The host needs its own Mailbox (lsio_mu1 by default) and SCU
    * The original interrupt can be left here as reference but that is updated at the end of config
    */
    lsio_mu2: mailbox@5d1d0000 {
		compatible = &quot;fsl,imx8-mu-scu&quot;, &quot;fsl,imx8qm-mu&quot;, &quot;fsl,imx6sx-mu&quot;;
		reg = &lt;0x00 0x5d1d0000 0x00 0x10000&gt;;
        interrupts = &lt;GIC_SPI 178 IRQ_TYPE_LEVEL_HIGH&gt;;
		#mbox-cells = &lt;0x02&gt;;
		status = &quot;okay&quot;;
	};
};
</code></pre>
<p>The actual devices which were passed through may have some dependencies (such as clocks) which also need to be configured in the guest for the main devices to work properly. In most cases, they can be just copy-pasted from the original host configuration with a few minor alterations. Required dependencies need a bit of manual labor and depend on case to case.</p>
<p>The main key is to go through the whole original device tree and list out device node names that are used by the passedthrough devices. This may require several passes as the dependencies may also contain some dependencies of their own. On top of the requirements, it is good also to check if the passedthrough devices are used by some other devices. </p>
<p>Some devices may be used through a controller, such as <strong>lsio_mu2</strong> is used by the main system control unit <strong>scu</strong>. In this case, the dependencies consist of several clock devices and their controller and also the i.MX 8 system control unit <strong>SCU</strong> device with its internals.</p>
<p>The assisting devices can be added just before the start &quot;<strong>platform@c000000</strong>&quot; bus configuration section: </p>
<pre><code>/**
 * Several clocks and a regulator copied from original host config.
 **/
clk_dummy: clock-dummy {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;0&gt;;
	clock-output-names = &quot;clk_dummy&quot;;
};

xtal32k: clock-xtal32k {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;32768&gt;;
	clock-output-names = &quot;xtal_32KHz&quot;;
};

xtal24m: clock-xtal24m {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;24000000&gt;;
	clock-output-names = &quot;xtal_24MHz&quot;;
};

reg_fec2_supply: fec2_nvcc {
	compatible = &quot;regulator-fixed&quot;;
	regulator-name = &quot;fec2_nvcc&quot;;
	regulator-min-microvolt = &lt;1800000&gt;;
	regulator-max-microvolt = &lt;1800000&gt;;
//	gpio = &lt;&amp;max7322 0 GPIO_ACTIVE_HIGH&gt;;
	enable-active-high;
	status = &quot;okay&quot;;
};

conn_axi_clk: clock-conn-axi {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;333333333&gt;;
	clock-output-names = &quot;conn_axi_clk&quot;;
};

conn_ahb_clk: clock-conn-ahb {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;166666666&gt;;
	clock-output-names = &quot;conn_ahb_clk&quot;;
};

conn_ipg_clk: clock-conn-ipg {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;83333333&gt;;
	clock-output-names = &quot;conn_ipg_clk&quot;;
};

conn_bch_clk: clock-conn-bch {
	compatible = &quot;fixed-clock&quot;;
	#clock-cells = &lt;0&gt;;
	clock-frequency = &lt;400000000&gt;;
	clock-output-names = &quot;conn_bch_clk&quot;;
};

/**
 * imx8 SCU device and its content with changed to use &quot;lsio_mu2&quot; mailbox
 * The original scu used lsio_mu1 so we need to use one of lsio_mu2 to lsio_mu4
 **/
scu {
	compatible = &quot;fsl,imx-scu&quot;;
	mbox-names = &quot;tx0&quot;, &quot;rx0&quot;, &quot;gip3&quot;;
	mboxes = &lt;&amp;lsio_mu2 0 0
		&amp;lsio_mu2 1 0
		&amp;lsio_mu2 3 3&gt;;

	pd: imx8qx-pd {
		compatible = &quot;fsl,imx8qm-scu-pd&quot;, &quot;fsl,scu-pd&quot;;
		#power-domain-cells = &lt;1&gt;;
		status = &quot;okay&quot;;

		wakeup-irq = &lt;235 236 237 258 262 267 271
				345 346 347 348&gt;;
	};

	clk: clock-controller {
		compatible = &quot;fsl,imx8qm-clk&quot;, &quot;fsl,scu-clk&quot;;
		#clock-cells = &lt;2&gt;;
		clocks = &lt;&amp;xtal32k &amp;xtal24m&gt;;
		clock-names = &quot;xtal_32KHz&quot;, &quot;xtal_24Mhz&quot;;
	};

	iomuxc: pinctrl {
		compatible = &quot;fsl,imx8qm-iomuxc&quot;;
	};

	ocotp: imx8qm-ocotp {
		compatible = &quot;fsl,imx8qm-scu-ocotp&quot;;
		#address-cells = &lt;1&gt;;
		#size-cells = &lt;1&gt;;
		read-only;

		fec_mac0: mac@1c4 {
			reg = &lt;0x1c4 6&gt;;
		};

		fec_mac1: mac@1c6 {
			reg = &lt;0x1c6 6&gt;;
		};
	};

	rtc: rtc {
		compatible = &quot;fsl,imx8qm-sc-rtc&quot;;
	};

	watchdog {
		compatible = &quot;fsl,imx8qm-sc-wdt&quot;, &quot;fsl,imx-sc-wdt&quot;;
		timeout-sec = &lt;60&gt;;
	};

	tsens: thermal-sensor {
		compatible = &quot;fsl,imx-sc-thermal&quot;;
		tsens-num = &lt;6&gt;;
		#thermal-sensor-cells = &lt;1&gt;;
	};
};

/**
 * And the platform bus that was done earlier would start from here..
 */
platform@c000000 {
    ...
};
</code></pre>
<h3 id="some-final-touches-for-guest-devices"><a class="header" href="#some-final-touches-for-guest-devices">Some Final Touches for Guest Devices</a></h3>
<p>Now we have most of the actual devices setup. Some final modifications for individual devices can be done at the end of the guest device tree configuration. These can be done outside the main node, as we just modify some node properties which are already defined.</p>
<pre><code>/**
 * For fec1 we need to update the interrupts to match the ones used by guest pass-through.
 * Most of the configuration is exactly the same that was set original imx8 config
 * Qemu starts its pass-through interrupts at 0x70 so lets change that
 * It is not strictly required to remove the possible iommus property but lets do that anyway
 */
&amp;fec1 {
    compatible = &quot;fsl,imx8qm-fec&quot;, &quot;fsl,imx6sx-fec&quot;;
    interrupts = &lt;GIC_SPI 0x70 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 0x71 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 0x72 IRQ_TYPE_LEVEL_HIGH&gt;,
            &lt;GIC_SPI 0x73 IRQ_TYPE_LEVEL_HIGH&gt;;
    /delete-property/ iommus;
    pinctrl-names = &quot;default&quot;;
    pinctrl-0 = &lt;&amp;pinctrl_fec1&gt;;
    phy-mode = &quot;rgmii-txid&quot;;
    phy-handle = &lt;&amp;ethphy0&gt;;
    fsl,magic-packet;
    nvmem-cells = &lt;&amp;fec_mac0&gt;;
    nvmem-cell-names = &quot;mac-address&quot;;
    status = &quot;okay&quot;;

    mdio {
        #address-cells = &lt;1&gt;;
        #size-cells = &lt;0&gt;;

        ethphy0: ethernet-phy@0 {
            compatible = &quot;ethernet-phy-ieee802.3-c22&quot;;
            reg = &lt;0&gt;;
            at803x,eee-disabled;
            at803x,vddio-1p8v;
            qca,disable-smarteee;
            vddio-supply = &lt;&amp;vddio0&gt;;

            vddio0: vddio-regulator {
                regulator-min-microvolt = &lt;1800000&gt;;
                regulator-max-microvolt = &lt;1800000&gt;;
            };
        };
    };
};

/**
 * Not much to do for clock controller
 * Remove the iommus as it is not needed in guest and turn the device on
 */
&amp;enet0_lpcg {
    status = &quot;okay&quot;;
    /delete-property/ iommus;
};

/**
 * Same for our mailbox
 * Update the interrupts to match next available interrupt in Qemu
 */
&amp;lsio_mu2 {
    compatible = &quot;fsl,imx8-mu-scu&quot;, &quot;fsl,imx8qm-mu&quot;, &quot;fsl,imx6sx-mu&quot;;
    interrupts = &lt;GIC_SPI 0x74 IRQ_TYPE_LEVEL_HIGH&gt;;
    /delete-property/ iommus;
    status = &quot;okay&quot;;
};

/**
 * In the host devicetree we had some pads which were transferred to guest.
 * There can be found in the original imx8 hosts config.
 **/
&amp;iomuxc {
    pinctrl-names = &quot;default&quot;;
    status = &quot;okay&quot;;

    pinctrl_fec1: fec1grp {
        fsl,pins = &lt;
            IMX8QM_COMP_CTL_GPIO_1V8_3V3_ENET_ENETA_PAD		0x000014a0
            IMX8QM_ENET0_MDC_CONN_ENET0_MDC				0x06000020
            IMX8QM_ENET0_MDIO_CONN_ENET0_MDIO			0x06000020
            IMX8QM_ENET0_RGMII_TX_CTL_CONN_ENET0_RGMII_TX_CTL	0x06000020
            IMX8QM_ENET0_RGMII_TXC_CONN_ENET0_RGMII_TXC		0x06000020
            IMX8QM_ENET0_RGMII_TXD0_CONN_ENET0_RGMII_TXD0		0x06000020
            IMX8QM_ENET0_RGMII_TXD1_CONN_ENET0_RGMII_TXD1		0x06000020
            IMX8QM_ENET0_RGMII_TXD2_CONN_ENET0_RGMII_TXD2		0x06000020
            IMX8QM_ENET0_RGMII_TXD3_CONN_ENET0_RGMII_TXD3		0x06000020
            IMX8QM_ENET0_RGMII_RXC_CONN_ENET0_RGMII_RXC		0x06000020
            IMX8QM_ENET0_RGMII_RX_CTL_CONN_ENET0_RGMII_RX_CTL	0x06000020
            IMX8QM_ENET0_RGMII_RXD0_CONN_ENET0_RGMII_RXD0		0x06000020
            IMX8QM_ENET0_RGMII_RXD1_CONN_ENET0_RGMII_RXD1		0x06000020
            IMX8QM_ENET0_RGMII_RXD2_CONN_ENET0_RGMII_RXD2		0x06000020
            IMX8QM_ENET0_RGMII_RXD3_CONN_ENET0_RGMII_RXD3		0x06000020
        &gt;;
    };
};
</code></pre>
<p>With our additional devices also some headers and definitions need to be included at the beginning of the device tree. These additions can be found also from the original i.MX 8 device tree files. See the full device tree below for reference.</p>
<h2 id="compiling-the-device-tree-source-to-binary-form"><a class="header" href="#compiling-the-device-tree-source-to-binary-form">Compiling the Device Tree Source to Binary Form</a></h2>
<p>The device trees need to be compiled within the Linux kernel source directory. They depend on some kernel device tree headers and in the host device case‚Äîother device tree source files.</p>
<ul>
<li>Full host device tree: <a href="research/passthrough/imx8qm-mek_conn-host.dts">imx8qm-mek_conn-host.dts</a></li>
<li>Full guest device tree: <a href="research/passthrough/imx8qm-mek_conn-guest.dts">imx8qm-mek_conn-guest.dts</a></li>
</ul>
<h3 id="compiling-for-guest"><a class="header" href="#compiling-for-guest">Compiling for Guest</a></h3>
<pre><code>cpp -nostdinc -I include -I arch  -undef -x assembler-with-cpp \
    arch/arm64/boot/dts/freescale/imx8qm-mek_conn-guest.dts imx8qm-mek_conn-guest.dts.preprocessed; \
    dtc -I dts -O dtb -p 0x1000 imx8qm-mek_conn-guest.preprocessed -o imx8qm-mek_conn-guest.dtb
</code></pre>
<h3 id="compiling-for-host"><a class="header" href="#compiling-for-host">Compiling for Host</a></h3>
<pre><code>cpp -nostdinc -I include -I arch  -undef -x assembler-with-cpp \
    arch/arm64/boot/dts/freescale/imx8qm-mek_conn-host.dts imx8qm-mek_conn-host.dts.preprocessed; \
    dtc -I dts -O dtb -p 0x1000 imx8qm-mek_conn-host.preprocessed -o imx8qm-mek_conn-host.dtb
</code></pre>
<h2 id="running-qemu-with-passthrough-platform-devices"><a class="header" href="#running-qemu-with-passthrough-platform-devices">Running QEMU with Passthrough Platform Devices</a></h2>
<p>To get passthrough working, i.MX 8 QM needs to be booted using our freshly built hosts <strong>imx8qm-mek_conn-host.dtb</strong> device tree file.</p>
<p>When the system has booted, we need to set up the passedthrough devices for the VFIO driver and start QEMU with devices passed through.</p>
<p>First, the devices need to be setup for VFIO:</p>
<pre><code>echo vfio-platform  &gt; /sys/bus/platform/devices/5d1d0000.mailbox/driver_override
echo 5d1d0000.mailbox &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b040000.ethernet/driver_override
echo 5b040000.ethernet &gt; /sys/bus/platform/drivers/vfio-platform/bind

echo vfio-platform &gt; /sys/bus/platform/devices/5b230000.clock-controller/driver_override
echo 5b230000.clock-controller &gt; /sys/bus/platform/drivers/vfio-platform/bind
</code></pre>
<p>After, QEMU can be started with our devices over the devices.</p>
<p>This is just as an example. It may require a bit of change in other environments.</p>
<p>In this example, the guest kernel image‚Äîext2 rootfs and guest device tree‚Äîall use the same filename prefix <strong>imx8qm-mek_conn-guest</strong>.</p>
<pre><code>qemu-system-aarch64 \
    -M virt,gic-version=host -enable-kvm \
    -cpu host \
    -m 512M \
    -kernel &quot;imx8qm-mek_conn-guest.Image&quot; \
    -drive file=&quot;imx8qm-mek_conn-guest.ext2&quot;,if=virtio,format=raw -dtb &quot;imx8qm-mek_conn-guest.dtb&quot; \
    -nographic \
    -append &quot;loglevel=7 rootwait root=/dev/vda console=ttyAMA0 earlycon earlyprintk&quot; \
    -device vfio-platform,host=5b230000.clock-controller \
    -device vfio-platform,host=5b040000.ethernet \
    -device vfio-platform,host=5d1d0000.mailbox
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="running-windows-11-in-vm-on-ghaf"><a class="header" href="#running-windows-11-in-vm-on-ghaf">Running Windows 11 in VM on Ghaf</a></h1>
<p>You can run Windows 11 in a VM on Ghaf with NVIDIA Jetson Orin AGX. This method uses <a href="https://www.qemu.org/">QEMU</a> as VMM. For information on how to build and run a Ghaf image for NVIDIA Jetson Orin AGX, see <a href="research/../ref_impl/build_and_run.html#ghaf-image-for-nvidia-jetson-orin-agx">Build and Run</a>.</p>
<h2 id="getting-windows-11-image"><a class="header" href="#getting-windows-11-image">Getting Windows 11 Image</a></h2>
<ol>
<li>
<p>Use your Microsoft account to join the <a href="https://insider.windows.com/en-us/register">Windows Insider Program</a> to be able to install Windows Insider Preview Builds.</p>
</li>
<li>
<p>On the <em>Windows 11 on Arm Insider Preview</em> page, select the <code>Windows 11 Client Arm64 Insider Preview (Canary) - Build 25324</code> build and the language to download a VHDX image file for ARM64.</p>
</li>
<li>
<p>Copy <em>Windows11_InsiderPreview_Client_ARM64_en-us_25324.VHDX</em> to an external USB drive. Connect the USB drive to the NVIDIA device with the latest version of Ghaf installed, and mount it to some folder.</p>
<pre><code>sudo mkdir /mnt
sudo mount /dev/sda /mnt
</code></pre>
<blockquote>
<p><strong>WARNING:</strong> Make sure to use a fresh VHDX image file which has not been booted on some other environment before.</p>
</blockquote>
</li>
</ol>
<h2 id="running-windows-11-in-vm"><a class="header" href="#running-windows-11-in-vm">Running Windows 11 in VM</a></h2>
<ol>
<li>
<p>In Weston terminal, go to the directory with the VHDX image and run the VM using the following Ghaf script:</p>
<pre><code>cd /mnt
windows-launcher ./Windows11_InsiderPreview_Client_ARM64_en-us_25324.VHDX
</code></pre>
<blockquote>
<p><strong>WARNING:</strong> Do not use <strong>sudo</strong> or the root user to run windows-launcher.</p>
</blockquote>
<p>Alternatively, you can launch the Windows 11 VM by clicking the corresponding icon in the Weston taskbar.</p>
<p>When you click it for the first time, you will see a file selection dialog. Once Windows 11 image has been selected, it saves the path to the <code>~/.config/windows-launcher-ui.conf</code> configuration file and launches the VM. Next time, the VM will be immediately launched with one click.</p>
</li>
<li>
<p>You can pass additional parameter to QEMU after the image name. For example:</p>
<pre><code>windows-launcher ./Windows11_InsiderPreview_Client_ARM64_en-us_25324.VHDX -serial stdio
</code></pre>
</li>
<li>
<p>Windows 11 requires Internet access to finish the setup. To boot the VM without an Internet connection, open cmd with Shift+F10 and type <code>OOBE\BYPASSNRO</code>. The VM will reboot and configuration will continue in offline mode.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<p>This is a glossary of terms and abbreviations developed by the Ghaf team.</p>
<p><strong>Abbreviation</strong> is a shortened form of a word or phrase. Usually is used to save space and time, to avoid repetition of long words and phrases.</p>
<p>The styling of abbreviations is inconsistent and includes several possible variations. Some abbreviations are formed by omitting all but the first few letters of a word. Such abbreviations usually end in a period: Mr. for mister, Oct. for October.</p>
<p>When abbreviations are formed from the initial letters of a phrase, they are categorized as either <strong>initialisms</strong> or <strong>acronyms</strong>:</p>
<ul>
<li>
<p>With <strong>initialisms</strong>, each letter is pronounced separately. For example: FBI for Federal Bureau of Investigation, CIA for Central Intelligence Agency, CD for Compact Disk, and also OK for Okay, ‚Äòorl korrekt‚Äò that is a misspelling of &quot;all correct&quot;. Initialisms cannot be pronounced as words.</p>
</li>
<li>
<p><strong>Acronyms</strong> are another type of abbreviation formed from the initial letters but that are pronounced as if they were words themselves. For example: ROFL for ‚Äòrolling on the floor laughing‚Äô, FEMA for Federal Emergency Management Agency, NATO for North Atlantic Treaty Organization.</p>
</li>
</ul>
<p>All acronyms are abbreviations, but not all abbreviations are acronyms. ASAP that comes from ‚Äòas soon as possible‚Äô and appt (for appointment) are both considered abbreviations, but only ASAP is an acronym.</p>
<h3 id="appropriate-use-of-articles-before-abbreviations"><a class="header" href="#appropriate-use-of-articles-before-abbreviations">Appropriate Use of Articles before Abbreviations</a></h3>
<ul>
<li>Articles (a, an, the) are common with initialisms. The indefinite article should be chosen according to the first sound‚Äînot the first letter:
<ul>
<li>‚ÄòA‚Äô is correct before initialisms beginning with a consonant sound, including a vowel pronounced as a ‚Äòw‚Äô or ‚Äòy‚Äô sound. For example: ‚Äòa NASA launch‚Äô, but ‚ÄòNASA launches take place‚Äô.</li>
<li>When an initialism begins with a vowel sound (including silent consonants or a consonant pronounced with an initial vowel sound), ‚Äòan‚Äô should be used instead. For example, ‚Äòread about an FBI raid‚Äô.</li>
</ul>
</li>
<li>Acronyms not require articles except when they are used adjectivally. For example: ‚Äòthe patient was diagnosed with AIDS‚Äô, but ‚Äòthe AIDS patient‚Äô;‚Äòthe NASA launch takes place‚Äô.</li>
</ul>
<p>So, read the abbreviation aloud: it may be either an initialism or an acronym. Focus on the sounds, not on the letters: ‚Äò<em>an</em> unidentified flying object‚Äô but ‚Äò<em>a</em> UFO‚Äô as it pronounced ‚Äúa YOO-ef-OH‚Äù (/ÀåjuÀê…õfÀà…ô ä/). More examples: a EULA (‚ÄúYOO-luh‚Äù), a LAN router, an XML file, an HTML page.</p>
<h3 id="trivia"><a class="header" href="#trivia">Trivia</a></h3>
<p>If you do not find the term or abbreviation you are looking for, share your questions using <a href="https://github.com/tiiuae/ghaf/issues">GitHub Issues</a>.</p>
<p>Wikipedia is not a dictionary.</p>
<hr />
<p>Groups of terms and abbreviations:</p>
<ul>
<li><a href="appendices/glossary.html#project-related">Project Related</a></li>
<li><a href="appendices/glossary.html#core-concepts">Core Concepts</a></li>
<li><a href="appendices/glossary.html#scs-related">SCS Related</a></li>
</ul>
<hr />
<h2 id="project-related"><a class="header" href="#project-related">Project Related</a></h2>
<h3 id="ghaf"><a class="header" href="#ghaf">Ghaf</a></h3>
<p><em>The project code name that represents the Ghaf tree.</em><br />
Source: <a href="https://connectwithnature.ae/knowledge-hub/ghaf-tree">https://connectwithnature.ae/knowledge-hub/ghaf-tree</a></p>
<h3 id="ssrc"><a class="header" href="#ssrc">SSRC</a></h3>
<p><em>Secure Systems Research Center is a global center of excellence in the development of end-to-end security and resilience for cyber-physical and autonomous systems. SSRC is a part of TII.</em><br />
Source: <a href="https://www.tii.ae/secure-systems">https://www.tii.ae/secure-systems</a></p>
<h3 id="tii"><a class="header" href="#tii">TII</a></h3>
<p><em>Technology Innovation Institute is a UAE-based research center that aims to lead global advances in artificial intelligence, autonomous robotics, quantum computing, cryptography and quantum communications, directed energy, secure communication, smart devices, advanced materials, and propulsion and space technologies.</em><br />
Source: <a href="https://www.tii.ae/">https://www.tii.ae/</a></p>
<hr />
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="adr"><a class="header" href="#adr">ADR</a></h3>
<p><em>An Architecture Decision (AD) is a justified software design choice that addresses a functional or non-functional requirement that is architecturally significant. An Architectural Decision Record (ADR) captures a single AD and its rationale; the collection of ADRs created and maintained in a project constitute its decision log.</em><br />
Source: <a href="https://adr.github.io/">https://adr.github.io/</a></p>
<h3 id="bsp"><a class="header" href="#bsp">BSP</a></h3>
<p><em>A board support package is a collection of software used to boot and run the embedded system.</em></p>
<h3 id="dhcp"><a class="header" href="#dhcp">DHCP</a></h3>
<p><em>The Dynamic Host Configuration Protocol is a network protocol that automatically sets IP addresses and other attributes to enable information transfer between network nodes.</em><br />
Source: Computer Networks: A Systems Approach, <a href="https://book.systemsapproach.org/internetworking/basic-ip.html#host-configuration-dhcp">https://book.systemsapproach.org/internetworking/basic-ip.html#host-configuration-dhcp</a></p>
<h3 id="dma"><a class="header" href="#dma">DMA</a></h3>
<p><em>A direct memory access is a process in which data may be moved directly to or from the main memory of a computer system by operations not under the control of the central processing unit.</em><br />
Source: <a href="https://www.collinsdictionary.com/dictionary/english/direct-memory-access">https://www.collinsdictionary.com/dictionary/english/direct-memory-access</a></p>
<h3 id="emmc-e-mmc"><a class="header" href="#emmc-e-mmc">eMMC, e-MMC</a></h3>
<p><em>embedded MultiMediaCard</em></p>
<h3 id="eula"><a class="header" href="#eula">EULA</a></h3>
<p><em>end-user license agreement</em></p>
<h3 id="gui"><a class="header" href="#gui">GUI</a></h3>
<p><em>graphical user interface</em></p>
<h3 id="ids"><a class="header" href="#ids">IDS</a></h3>
<p><em>An intrusion detection system (also intrusion prevention system or IPS) monitors network traffic for suspicious activity and report when such activity is discovered.</em></p>
<h3 id="iommu"><a class="header" href="#iommu">IOMMU</a></h3>
<p><em>input‚Äìoutput memory management unit</em></p>
<h3 id="ip"><a class="header" href="#ip">IP</a></h3>
<p><em>The Internet Protocol is a set of rules for communication over the Internet, such as sending email, streaming video, or connecting to a website.</em></p>
<h3 id="isa"><a class="header" href="#isa">ISA</a></h3>
<p><em>An Instruction Set Architecture is part of the abstract model of a computer that defines how the CPU is controlled by the software.</em><br />
Source: <a href="https://www.arm.com/glossary/isa">https://www.arm.com/glossary/isa</a></p>
<h3 id="kvm"><a class="header" href="#kvm">KVM</a></h3>
<p><em>Kernel-based Virtual Machine, an open-source virtualization technology built into Linux.</em></p>
<h3 id="kvms"><a class="header" href="#kvms">KVMS</a></h3>
<p><em>Kernel-based Virtual Machine Secured, an open-source project.</em><br />
Source: <a href="https://github.com/jkrh/kvms">https://github.com/jkrh/kvms</a></p>
<h3 id="mmu"><a class="header" href="#mmu">MMU</a></h3>
<p><em>memory management unit</em></p>
<h3 id="msi"><a class="header" href="#msi">MSI</a></h3>
<p><em>Message Signaled Interrupts</em></p>
<h3 id="nixos"><a class="header" href="#nixos">NixOS</a></h3>
<p><em>A Linux distribution based on the Nix package manager and build system.</em><br />
Source: <a href="https://nixos.wiki/wiki/Overview_of_the_NixOS_Linux_distribution">https://nixos.wiki/wiki/Overview_of_the_NixOS_Linux_distribution</a></p>
<h3 id="os"><a class="header" href="#os">OS</a></h3>
<p><em>operating system</em></p>
<h3 id="pci"><a class="header" href="#pci">PCI</a></h3>
<p><em>Peripheral Component Interconnect</em></p>
<h3 id="pcie"><a class="header" href="#pcie">PCIe</a></h3>
<p><em>Peripheral Component Interconnect Express</em></p>
<h3 id="qemu"><a class="header" href="#qemu">QEMU</a></h3>
<p><em>A generic and open source machine emulator and virtualizer.</em><br />
Source: <a href="https://www.qemu.org/docs/master/about/index.html">https://www.qemu.org/docs/master/about/index.html</a></p>
<h3 id="sbsa"><a class="header" href="#sbsa">SBSA</a></h3>
<p><em>The Server Base System Architecture specifies a hardware system architecture, based on Arm 64-bit architecture, that server system software, for example operating systems, hypervisors, and firmware can rely on.</em><br />
Source: <a href="https://developer.arm.com/documentation/den0029/latest">Arm¬Æ Server Base System Architecture 7.1 Platform Design Document</a></p>
<h3 id="soc"><a class="header" href="#soc">SoC</a></h3>
<p><em>A system on chip, a microchip that contains the necessary electronic circuits for a fully functional system on a single integrated circuit (IC).</em></p>
<h3 id="ssd"><a class="header" href="#ssd">SSD</a></h3>
<p><em>solid-state drive</em></p>
<h3 id="tcb"><a class="header" href="#tcb">TCB</a></h3>
<p><em>Trusted computing base defines the security requirements by providing separation of users and data or resources.</em><br />
Source: <a href="https://csrc.nist.gov/csrc/media/publications/conference-paper/1998/10/08/proceedings-of-the-21st-nissc-1998/documents/early-cs-papers/dod85.pdf">Department of Defense trusted computer system evaluation criteria, DoD 5200.28-STD, 1985.</a></p>
<h3 id="tls"><a class="header" href="#tls">TLS</a></h3>
<p><em>Transport Layer Security, a security protocol.</em></p>
<h3 id="uart"><a class="header" href="#uart">UART</a></h3>
<p><em>An universal asynchronous receiver-transmitter, a hardware communication protocol.</em></p>
<h3 id="ui"><a class="header" href="#ui">UI</a></h3>
<p><em>user interface</em></p>
<h3 id="vfio"><a class="header" href="#vfio">VFIO</a></h3>
<p><em>Virtual Function I/O</em><br />
Source: <a href="https://docs.kernel.org/driver-api/vfio.html">https://docs.kernel.org/driver-api/vfio.html</a></p>
<h3 id="vm"><a class="header" href="#vm">VM</a></h3>
<p><em>virtual machine</em></p>
<h3 id="vmm"><a class="header" href="#vmm">VMM</a></h3>
<p><em>Virtual Machine Manager</em></p>
<h3 id="zta"><a class="header" href="#zta">ZTA</a></h3>
<p><em>zero trust architecture, zero trust security model</em></p>
<hr />
<h2 id="scs-related"><a class="header" href="#scs-related">SCS Related</a></h2>
<h3 id="ca"><a class="header" href="#ca">CA</a></h3>
<p><em>certificate authority</em></p>
<h3 id="cms"><a class="header" href="#cms">CMS</a></h3>
<p><em>Certificate Management System</em></p>
<h3 id="eddsa"><a class="header" href="#eddsa">EdDSA</a></h3>
<p><em>Edwards-curve Digital Signature Algorithm</em></p>
<h3 id="gpg"><a class="header" href="#gpg">GPG</a></h3>
<p><em>The GNU Privacy Guard (also GnuPG) is a complete and free implementation of the OpenPGP standard as defined by RFC4880.</em><br />
Source: <a href="https://gnupg.org/">https://gnupg.org/</a></p>
<h3 id="hsm"><a class="header" href="#hsm">HSM</a></h3>
<p><em>A hardware security module is a crypto processor designed for the crypto key lifecycle protection.</em></p>
<h3 id="openssl"><a class="header" href="#openssl">OpenSSL</a></h3>
<p><em>Cryptography and SSL/TLS Toolkit.</em><br />
Source: <a href="https://www.openssl.org/">https://www.openssl.org/</a></p>
<h3 id="pki"><a class="header" href="#pki">PKI</a></h3>
<p><em>A public key infrastructure is the framework of encryption and cybersecurity.</em></p>
<h3 id="pynacl"><a class="header" href="#pynacl">PyNaCl</a></h3>
<p><em>A Python binding to libsodium, which is a fork of the Networking and Cryptography library.</em><br />
Source: <a href="https://pypi.org/project/PyNaCl/">https://pypi.org/project/PyNaCl/</a></p>
<h3 id="ra"><a class="header" href="#ra">RA</a></h3>
<p><em>registration authority</em></p>
<h3 id="sbom"><a class="header" href="#sbom">SBOM</a></h3>
<p><em>A software bill of materials is a machine-readable document of all software components, open source licenses, and dependencies in a target software.</em></p>
<h3 id="scs"><a class="header" href="#scs">SCS</a></h3>
<p><em>A supply chain security is a process of securing the machinery of the development, building, and release environment.</em></p>
<h3 id="secure-cryptoprocessor"><a class="header" href="#secure-cryptoprocessor">secure cryptoprocessor</a></h3>
<p><em>A security chip that performs encryption and decryption operations.</em></p>
<h3 id="software-artifact"><a class="header" href="#software-artifact">software artifact</a></h3>
<p><em>An immutable blob of data; primarily refers to software, but SLSA can be used for any artifact.</em><br />
Source: <a href="https://slsa.dev/spec/v0.1/terminology">https://slsa.dev/spec/v0.1/terminology</a></p>
<h3 id="slsa"><a class="header" href="#slsa">SLSA</a></h3>
<p><em>Supply chain Levels for Software Artifacts is a security framework, a check-list of standards and controls to prevent tampering, improve integrity, and secure packages and infrastructure in your projects, businesses or enterprises.</em><br />
Source: <a href="https://slsa.dev/">https://slsa.dev/</a></p>
<div style="break-before: page; page-break-before: always;"></div><!--
    Copyright 2022-2023 TII (SSRC) and the Ghaf contributors
    SPDX-License-Identifier: CC-BY-SA-4.0
-->
<h1 id="contribution-guidelines"><a class="header" href="#contribution-guidelines">Contribution Guidelines</a></h1>
<p>Improvements to code and documentation are welcome! We would love to get contributions from you. For more information, see <a href="https://github.com/tiiuae/ghaf/blob/main/CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
<p>Some things that will increase the chance that your pull request is accepted faster:</p>
<ul>
<li>Spelling tools usage.</li>
<li><a href="https://github.com/tiiuae/ghaf/blob/main/docs/style_guide.md">Following our Style Guide</a>.</li>
<li><a href="https://github.com/tiiuae/ghaf/blob/main/CONTRIBUTING.md#commit-message-guidelines">Writing a good commit message</a>.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
